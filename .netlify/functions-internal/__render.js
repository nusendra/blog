var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require = typeof require !== "undefined" ? require : (x) => {
  throw new Error('Dynamic require of "' + x + '" is not supported');
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* read(parts) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else {
      yield part;
    }
  }
}
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    if (isBlob(value)) {
      length += value.size;
    } else {
      length += Buffer.byteLength(String(value));
    }
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const err = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(err);
        throw err;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error3) {
    if (error3 instanceof FetchBaseError) {
      throw error3;
    } else {
      throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error3.message}`, "system", error3);
    }
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error3) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error3.message}`, "system", error3);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
async function fetch(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const options3 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options3.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options3.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options3.protocol === "data:") {
      const data = dataUriToBuffer$1(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (options3.protocol === "https:" ? import_https.default : import_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error3 = new AbortError("The operation was aborted.");
      reject(error3);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error3);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error3);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options3);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (err) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (error3) {
                reject(error3);
              }
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
        }
      }
      response_.once("end", () => {
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      });
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
        reject(error3);
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), (error3) => {
          reject(error3);
        });
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
          reject(error3);
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), (error3) => {
              reject(error3);
            });
          } else {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), (error3) => {
              reject(error3);
            });
          }
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), (error3) => {
          reject(error3);
        });
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
var import_http, import_https, import_zlib, import_stream, import_util, import_crypto, import_url, src, dataUriToBuffer$1, Readable, wm, Blob, fetchBlob, Blob$1, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, carriage, dashes, carriageLength, getFooter, getBoundary, INTERNALS$2, Body, clone, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    import_http = __toModule(require("http"));
    import_https = __toModule(require("https"));
    import_zlib = __toModule(require("zlib"));
    import_stream = __toModule(require("stream"));
    import_util = __toModule(require("util"));
    import_crypto = __toModule(require("crypto"));
    import_url = __toModule(require("url"));
    src = dataUriToBuffer;
    dataUriToBuffer$1 = src;
    ({ Readable } = import_stream.default);
    wm = new WeakMap();
    Blob = class {
      constructor(blobParts = [], options3 = {}) {
        let size = 0;
        const parts = blobParts.map((element) => {
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer = element;
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length || buffer.size || 0;
          return buffer;
        });
        const type = options3.type === void 0 ? "" : String(options3.type).toLowerCase();
        wm.set(this, {
          type: /[^\u0020-\u007E]/.test(type) ? "" : type,
          size,
          parts
        });
      }
      get size() {
        return wm.get(this).size;
      }
      get type() {
        return wm.get(this).type;
      }
      async text() {
        return Buffer.from(await this.arrayBuffer()).toString();
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of this.stream()) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        return Readable.from(read(wm.get(this).parts));
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = wm.get(this).parts.values();
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            const chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
            blobParts.push(chunk);
            added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;
            relativeStart = 0;
            if (added >= span) {
              break;
            }
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        Object.assign(wm.get(blob), { size: span, parts: blobParts });
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.stream === "function" && object.stream.length === 0 && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    fetchBlob = Blob;
    Blob$1 = fetchBlob;
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && object[NAME] === "AbortSignal";
    };
    carriage = "\r\n";
    dashes = "-".repeat(2);
    carriageLength = Buffer.byteLength(carriage);
    getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_stream.default)
          ;
        else if (isFormData(body)) {
          boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          body = import_stream.default.Readable.from(formDataIterator(body, boundary));
        } else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS$2] = {
          body,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_stream.default) {
          body.on("error", (err) => {
            const error3 = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
            this[INTERNALS$2].error = error3;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_stream.PassThrough({ highWaterMark });
        p2 = new import_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].body = p1;
        body = p2;
      }
      return body;
    };
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      }
      if (isFormData(body)) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body instanceof import_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request;
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      if (isFormData(body)) {
        return getFormDataLength(request[INTERNALS$2].boundary);
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw err;
      }
    };
    validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const err = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" });
        throw err;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback) {
        for (const name of this.keys()) {
          callback(this.get(name), name);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options3 = {}) {
        super(body, options3);
        const status = options3.status || 200;
        const headers = new Headers(options3.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: options3.url,
          status,
          statusText: options3.statusText || "",
          headers,
          counter: options3.counter,
          highWaterMark: options3.highWaterMark
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal !== null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const requestOptions = {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return requestOptions;
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/@sveltejs/adapter-netlify/files/shims.js
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-netlify/files/shims.js"() {
    init_install_fetch();
  }
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "node_modules/kind-of/index.js"(exports2, module2) {
    init_shims();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/is-extendable/index.js
var require_is_extendable = __commonJS({
  "node_modules/is-extendable/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function isExtendable(val) {
      return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
    };
  }
});

// node_modules/extend-shallow/index.js
var require_extend_shallow = __commonJS({
  "node_modules/extend-shallow/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var isObject = require_is_extendable();
    module2.exports = function extend(o) {
      if (!isObject(o)) {
        o = {};
      }
      var len = arguments.length;
      for (var i = 1; i < len; i++) {
        var obj = arguments[i];
        if (isObject(obj)) {
          assign(o, obj);
        }
      }
      return o;
    };
    function assign(a, b) {
      for (var key in b) {
        if (hasOwn(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/section-matter/index.js
var require_section_matter = __commonJS({
  "node_modules/section-matter/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var typeOf = require_kind_of();
    var extend = require_extend_shallow();
    module2.exports = function(input, options3) {
      if (typeof options3 === "function") {
        options3 = { parse: options3 };
      }
      var file = toObject(input);
      var defaults = { section_delimiter: "---", parse: identity };
      var opts = extend({}, defaults, options3);
      var delim = opts.section_delimiter;
      var lines = file.content.split(/\r?\n/);
      var sections = null;
      var section = createSection();
      var content = [];
      var stack = [];
      function initSections(val) {
        file.content = val;
        sections = [];
        content = [];
      }
      function closeSection(val) {
        if (stack.length) {
          section.key = getKey(stack[0], delim);
          section.content = val;
          opts.parse(section, sections);
          sections.push(section);
          section = createSection();
          content = [];
          stack = [];
        }
      }
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var len = stack.length;
        var ln = line.trim();
        if (isDelimiter(ln, delim)) {
          if (ln.length === 3 && i !== 0) {
            if (len === 0 || len === 2) {
              content.push(line);
              continue;
            }
            stack.push(ln);
            section.data = content.join("\n");
            content = [];
            continue;
          }
          if (sections === null) {
            initSections(content.join("\n"));
          }
          if (len === 2) {
            closeSection(content.join("\n"));
          }
          stack.push(ln);
          continue;
        }
        content.push(line);
      }
      if (sections === null) {
        initSections(content.join("\n"));
      } else {
        closeSection(content.join("\n"));
      }
      file.sections = sections;
      return file;
    };
    function isDelimiter(line, delim) {
      if (line.slice(0, delim.length) !== delim) {
        return false;
      }
      if (line.charAt(delim.length + 1) === delim.slice(-1)) {
        return false;
      }
      return true;
    }
    function toObject(input) {
      if (typeOf(input) !== "object") {
        input = { content: input };
      }
      if (typeof input.content !== "string" && !isBuffer(input.content)) {
        throw new TypeError("expected a buffer or string");
      }
      input.content = input.content.toString();
      input.sections = [];
      return input;
    }
    function getKey(val, delim) {
      return val ? val.slice(delim.length).trim() : "";
    }
    function createSection() {
      return { key: "", data: "", content: "" };
    }
    function identity(val) {
      return val;
    }
    function isBuffer(val) {
      if (val && val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/js-yaml/lib/js-yaml/common.js
var require_common = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/common.js"(exports2, module2) {
    init_shims();
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index2, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
          key = sourceKeys[index2];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/exception.js"(exports2, module2) {
    init_shims();
    "use strict";
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      var result = this.name + ": ";
      result += this.reason || "(unknown reason)";
      if (!compact && this.mark) {
        result += " " + this.mark.toString();
      }
      return result;
    };
    module2.exports = YAMLException;
  }
});

// node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/mark.js"(exports2, module2) {
    init_shims();
    "use strict";
    var common = require_common();
    function Mark(name, buffer, position, line, column) {
      this.name = name;
      this.buffer = buffer;
      this.position = position;
      this.line = line;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer)
        return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head = "";
      start = this.position;
      while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
          head = " ... ";
          start += 5;
          break;
        }
      }
      tail = "";
      end = this.position;
      while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
          tail = " ... ";
          end -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start, end);
      return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
    };
    Mark.prototype.toString = function toString(compact) {
      var snippet, where = "";
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ":\n" + snippet;
        }
      }
      return where;
    };
    module2.exports = Mark;
  }
});

// node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type.js"(exports2, module2) {
    init_shims();
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options3) {
      options3 = options3 || {};
      Object.keys(options3).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.tag = tag;
      this.kind = options3["kind"] || null;
      this.resolve = options3["resolve"] || function() {
        return true;
      };
      this.construct = options3["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options3["instanceOf"] || null;
      this.predicate = options3["predicate"] || null;
      this.represent = options3["represent"] || null;
      this.defaultStyle = options3["defaultStyle"] || null;
      this.styleAliases = compileStyleAliases(options3["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema.js"(exports2, module2) {
    init_shims();
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name, result) {
      var exclude = [];
      schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
      });
      schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function(type, index2) {
        return exclude.indexOf(index2) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index2, length;
      function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
      }
      for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
        arguments[index2].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      this.include = definition.include || [];
      this.implicit = definition.implicit || [];
      this.explicit = definition.explicit || [];
      this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
      });
      this.compiledImplicit = compileList(this, "implicit", []);
      this.compiledExplicit = compileList(this, "explicit", []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema.DEFAULT = null;
    Schema.create = function createSchema() {
      var schemas, types2;
      switch (arguments.length) {
        case 1:
          schemas = Schema.DEFAULT;
          types2 = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types2 = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      schemas = common.toArray(schemas);
      types2 = common.toArray(types2);
      if (!schemas.every(function(schema) {
        return schema instanceof Schema;
      })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      }
      if (!types2.every(function(type) {
        return type instanceof Type;
      })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      return new Schema({
        include: schemas,
        explicit: types2
      });
    };
    module2.exports = Schema;
  }
});

// node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/str.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/map.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/null.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/int.js"(exports2, module2) {
    init_shims();
    "use strict";
    var common = require_common();
    var Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index2 = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index2];
      if (ch === "-" || ch === "+") {
        ch = data[++index2];
      }
      if (ch === "0") {
        if (index2 + 1 === max)
          return true;
        ch = data[++index2];
        if (ch === "b") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index2)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        for (; index2 < max; index2++) {
          ch = data[index2];
          if (ch === "_")
            continue;
          if (!isOctCode(data.charCodeAt(index2)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "_")
        return false;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (ch === ":")
          break;
        if (!isDecCode(data.charCodeAt(index2))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      if (ch !== ":")
        return true;
      return /^(:[0-5]?[0-9])+$/.test(data.slice(index2));
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch, base2, digits = [];
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
      }
      if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base2 = 1;
        digits.forEach(function(d2) {
          value += d2 * base2;
          base2 *= 60;
        });
        return sign * value;
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/float.js"(exports2, module2) {
    init_shims();
    "use strict";
    var common = require_common();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign, base2, digits;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      digits = [];
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      } else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseFloat(v, 10));
        });
        value = 0;
        base2 = 1;
        digits.forEach(function(d2) {
          value += d2 * base2;
          base2 *= 60;
        });
        return sign * value;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_json()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports2, module2) {
    init_shims();
    "use strict";
    var NodeBuffer;
    try {
      _require = require;
      NodeBuffer = _require("buffer").Buffer;
    } catch (__) {
    }
    var _require;
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      if (NodeBuffer) {
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index2, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index2] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index2, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        keys = Object.keys(pair);
        result[index2] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/set.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_core()
      ],
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return void 0;
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined(object) {
      return typeof object === "undefined";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Type = require_type();
    function resolveJavascriptRegExp(data) {
      if (data === null)
        return false;
      if (data.length === 0)
        return false;
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        if (modifiers.length > 3)
          return false;
        if (regexp[regexp.length - modifiers.length - 1] !== "/")
          return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data) {
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      if (object.global)
        result += "g";
      if (object.multiline)
        result += "m";
      if (object.ignoreCase)
        result += "i";
      return result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports2, module2) {
    init_shims();
    "use strict";
    var esprima;
    try {
      _require = require;
      esprima = _require("esprima");
    } catch (_) {
      if (typeof window !== "undefined")
        esprima = window.esprima;
    }
    var _require;
    var Type = require_type();
    function resolveJavascriptFunction(data) {
      if (data === null)
        return false;
      try {
        var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    function constructJavascriptFunction(data) {
      var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
      }
      ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      });
      body = ast.body[0].expression.body.range;
      if (ast.body[0].expression.body.type === "BlockStatement") {
        return new Function(params, source.slice(body[0] + 1, body[1] - 1));
      }
      return new Function(params, "return " + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction,
      represent: representJavascriptFunction
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Schema = require_schema();
    module2.exports = Schema.DEFAULT = new Schema({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp(),
        require_function()
      ]
    });
  }
});

// node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/loader.js"(exports2, module2) {
    init_shims();
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var Mark = require_mark();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options3) {
      this.input = input;
      this.filename = options3["filename"] || null;
      this.schema = options3["schema"] || DEFAULT_FULL_SCHEMA;
      this.onWarning = options3["onWarning"] || null;
      this.legacy = options3["legacy"] || false;
      this.json = options3["json"] || false;
      this.listener = options3["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];
    }
    function generateError(state, message) {
      return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index2, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
        key = sourceKeys[index2];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index2, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
          if (Array.isArray(keyNode[index2])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
            keyNode[index2] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
            mergeMappings(state, _result, valueNode[index2], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        _pos = state.position;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
          if (state.result !== null && state.kind !== "scalar") {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
          }
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options3) {
      input = String(input);
      options3 = options3 || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options3);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options3) {
      if (iterator !== null && typeof iterator === "object" && typeof options3 === "undefined") {
        options3 = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options3);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
        iterator(documents[index2]);
      }
    }
    function load2(input, options3) {
      var documents = loadDocuments(input, options3);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    function safeLoadAll(input, iterator, options3) {
      if (typeof iterator === "object" && iterator !== null && typeof options3 === "undefined") {
        options3 = iterator;
        iterator = null;
      }
      return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options3));
    }
    function safeLoad(input, options3) {
      return load2(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options3));
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load2;
    module2.exports.safeLoadAll = safeLoadAll;
    module2.exports.safeLoad = safeLoad;
  }
});

// node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS({
  "node_modules/js-yaml/lib/js-yaml/dumper.js"(exports2, module2) {
    init_shims();
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema, map) {
      var result, keys, index2, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys = Object.keys(map);
      for (index2 = 0, length = keys.length; index2 < length; index2 += 1) {
        tag = keys[index2];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    function State(options3) {
      this.schema = options3["schema"] || DEFAULT_FULL_SCHEMA;
      this.indent = Math.max(1, options3["indent"] || 2);
      this.noArrayIndent = options3["noArrayIndent"] || false;
      this.skipInvalid = options3["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options3["flowLevel"]) ? -1 : options3["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options3["styles"] || null);
      this.sortKeys = options3["sortKeys"] || false;
      this.lineWidth = options3["lineWidth"] || 80;
      this.noRefs = options3["noRefs"] || false;
      this.noCompatMode = options3["noCompatMode"] || false;
      this.condenseFlow = options3["condenseFlow"] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str2) {
      var index2, length, type;
      for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
        type = state.implicitTypes[index2];
        if (type.resolve(str2)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
    }
    function isNsChar(c) {
      return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev) {
      return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i;
      var char, prev_char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
      } else {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char, nextChar;
      var escapeSeq;
      for (var i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char >= 55296 && char <= 56319) {
          nextChar = string.charCodeAt(i + 1);
          if (nextChar >= 56320 && nextChar <= 57343) {
            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
            i++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index2, length;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        if (writeNode(state, level, object[index2], false, false)) {
          if (index2 !== 0)
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index2, length;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        if (writeNode(state, level + 1, object[index2], true, true)) {
          if (!compact || index2 !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (index2 !== 0)
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (!compact || index2 !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index2, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
        type = typeList[index2];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : "?";
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          state.dump = "!<" + state.tag + "> " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index2, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index2]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index2, length;
      if (object !== null && typeof object === "object") {
        index2 = objects.indexOf(object);
        if (index2 !== -1) {
          if (duplicatesIndexes.indexOf(index2) === -1) {
            duplicatesIndexes.push(index2);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
              inspectNode(object[index2], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
              inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options3) {
      options3 = options3 || {};
      var state = new State(options3);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true))
        return state.dump + "\n";
      return "";
    }
    function safeDump(input, options3) {
      return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options3));
    }
    module2.exports.dump = dump;
    module2.exports.safeDump = safeDump;
  }
});

// node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS({
  "node_modules/js-yaml/lib/js-yaml.js"(exports2, module2) {
    init_shims();
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function deprecated(name) {
      return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.safeLoad = loader.safeLoad;
    module2.exports.safeLoadAll = loader.safeLoadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.safeDump = dumper.safeDump;
    module2.exports.YAMLException = require_exception();
    module2.exports.MINIMAL_SCHEMA = require_failsafe();
    module2.exports.SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_SCHEMA = require_default_full();
    module2.exports.scan = deprecated("scan");
    module2.exports.parse = deprecated("parse");
    module2.exports.compose = deprecated("compose");
    module2.exports.addConstructor = deprecated("addConstructor");
  }
});

// node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS({
  "node_modules/js-yaml/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var yaml2 = require_js_yaml();
    module2.exports = yaml2;
  }
});

// node_modules/gray-matter/lib/engines.js
var require_engines = __commonJS({
  "node_modules/gray-matter/lib/engines.js"(exports, module) {
    init_shims();
    "use strict";
    var yaml = require_js_yaml2();
    var engines = exports = module.exports;
    engines.yaml = {
      parse: yaml.safeLoad.bind(yaml),
      stringify: yaml.safeDump.bind(yaml)
    };
    engines.json = {
      parse: JSON.parse.bind(JSON),
      stringify: function(obj, options3) {
        const opts = Object.assign({ replacer: null, space: 2 }, options3);
        return JSON.stringify(obj, opts.replacer, opts.space);
      }
    };
    engines.javascript = {
      parse: function parse(str, options, wrap) {
        try {
          if (wrap !== false) {
            str = "(function() {\nreturn " + str.trim() + ";\n}());";
          }
          return eval(str) || {};
        } catch (err) {
          if (wrap !== false && /(unexpected|identifier)/i.test(err.message)) {
            return parse(str, options, false);
          }
          throw new SyntaxError(err);
        }
      },
      stringify: function() {
        throw new Error("stringifying JavaScript is not supported");
      }
    };
  }
});

// node_modules/strip-bom-string/index.js
var require_strip_bom_string = __commonJS({
  "node_modules/strip-bom-string/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(str2) {
      if (typeof str2 === "string" && str2.charAt(0) === "\uFEFF") {
        return str2.slice(1);
      }
      return str2;
    };
  }
});

// node_modules/gray-matter/lib/utils.js
var require_utils = __commonJS({
  "node_modules/gray-matter/lib/utils.js"(exports2) {
    init_shims();
    "use strict";
    var stripBom = require_strip_bom_string();
    var typeOf = require_kind_of();
    exports2.define = function(obj, key, val) {
      Reflect.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        writable: true,
        value: val
      });
    };
    exports2.isBuffer = function(val) {
      return typeOf(val) === "buffer";
    };
    exports2.isObject = function(val) {
      return typeOf(val) === "object";
    };
    exports2.toBuffer = function(input) {
      return typeof input === "string" ? Buffer.from(input) : input;
    };
    exports2.toString = function(input) {
      if (exports2.isBuffer(input))
        return stripBom(String(input));
      if (typeof input !== "string") {
        throw new TypeError("expected input to be a string or buffer");
      }
      return stripBom(input);
    };
    exports2.arrayify = function(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    };
    exports2.startsWith = function(str2, substr, len) {
      if (typeof len !== "number")
        len = substr.length;
      return str2.slice(0, len) === substr;
    };
  }
});

// node_modules/gray-matter/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/gray-matter/lib/defaults.js"(exports2, module2) {
    init_shims();
    "use strict";
    var engines2 = require_engines();
    var utils = require_utils();
    module2.exports = function(options3) {
      const opts = Object.assign({}, options3);
      opts.delimiters = utils.arrayify(opts.delims || opts.delimiters || "---");
      if (opts.delimiters.length === 1) {
        opts.delimiters.push(opts.delimiters[0]);
      }
      opts.language = (opts.language || opts.lang || "yaml").toLowerCase();
      opts.engines = Object.assign({}, engines2, opts.parsers, opts.engines);
      return opts;
    };
  }
});

// node_modules/gray-matter/lib/engine.js
var require_engine = __commonJS({
  "node_modules/gray-matter/lib/engine.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(name, options3) {
      let engine = options3.engines[name] || options3.engines[aliase(name)];
      if (typeof engine === "undefined") {
        throw new Error('gray-matter engine "' + name + '" is not registered');
      }
      if (typeof engine === "function") {
        engine = { parse: engine };
      }
      return engine;
    };
    function aliase(name) {
      switch (name.toLowerCase()) {
        case "js":
        case "javascript":
          return "javascript";
        case "coffee":
        case "coffeescript":
        case "cson":
          return "coffee";
        case "yaml":
        case "yml":
          return "yaml";
        default: {
          return name;
        }
      }
    }
  }
});

// node_modules/gray-matter/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/gray-matter/lib/stringify.js"(exports2, module2) {
    init_shims();
    "use strict";
    var typeOf = require_kind_of();
    var getEngine = require_engine();
    var defaults = require_defaults();
    module2.exports = function(file, data, options3) {
      if (data == null && options3 == null) {
        switch (typeOf(file)) {
          case "object":
            data = file.data;
            options3 = {};
            break;
          case "string":
            return file;
          default: {
            throw new TypeError("expected file to be a string or object");
          }
        }
      }
      const str2 = file.content;
      const opts = defaults(options3);
      if (data == null) {
        if (!opts.data)
          return file;
        data = opts.data;
      }
      const language = file.language || opts.language;
      const engine = getEngine(language, opts);
      if (typeof engine.stringify !== "function") {
        throw new TypeError('expected "' + language + '.stringify" to be a function');
      }
      data = Object.assign({}, file.data, data);
      const open = opts.delimiters[0];
      const close = opts.delimiters[1];
      const matter = engine.stringify(data, options3).trim();
      let buf = "";
      if (matter !== "{}") {
        buf = newline(open) + newline(matter) + newline(close);
      }
      if (typeof file.excerpt === "string" && file.excerpt !== "") {
        if (str2.indexOf(file.excerpt.trim()) === -1) {
          buf += newline(file.excerpt) + newline(close);
        }
      }
      return buf + newline(str2);
    };
    function newline(str2) {
      return str2.slice(-1) !== "\n" ? str2 + "\n" : str2;
    }
  }
});

// node_modules/gray-matter/lib/excerpt.js
var require_excerpt = __commonJS({
  "node_modules/gray-matter/lib/excerpt.js"(exports2, module2) {
    init_shims();
    "use strict";
    var defaults = require_defaults();
    module2.exports = function(file, options3) {
      const opts = defaults(options3);
      if (file.data == null) {
        file.data = {};
      }
      if (typeof opts.excerpt === "function") {
        return opts.excerpt(file, opts);
      }
      const sep = file.data.excerpt_separator || opts.excerpt_separator;
      if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {
        return file;
      }
      const delimiter = typeof opts.excerpt === "string" ? opts.excerpt : sep || opts.delimiters[0];
      const idx = file.content.indexOf(delimiter);
      if (idx !== -1) {
        file.excerpt = file.content.slice(0, idx);
      }
      return file;
    };
  }
});

// node_modules/gray-matter/lib/to-file.js
var require_to_file = __commonJS({
  "node_modules/gray-matter/lib/to-file.js"(exports2, module2) {
    init_shims();
    "use strict";
    var typeOf = require_kind_of();
    var stringify = require_stringify();
    var utils = require_utils();
    module2.exports = function(file) {
      if (typeOf(file) !== "object") {
        file = { content: file };
      }
      if (typeOf(file.data) !== "object") {
        file.data = {};
      }
      if (file.contents && file.content == null) {
        file.content = file.contents;
      }
      utils.define(file, "orig", utils.toBuffer(file.content));
      utils.define(file, "language", file.language || "");
      utils.define(file, "matter", file.matter || "");
      utils.define(file, "stringify", function(data, options3) {
        if (options3 && options3.language) {
          file.language = options3.language;
        }
        return stringify(file, data, options3);
      });
      file.content = utils.toString(file.content);
      file.isEmpty = false;
      file.excerpt = "";
      return file;
    };
  }
});

// node_modules/gray-matter/lib/parse.js
var require_parse = __commonJS({
  "node_modules/gray-matter/lib/parse.js"(exports2, module2) {
    init_shims();
    "use strict";
    var getEngine = require_engine();
    var defaults = require_defaults();
    module2.exports = function(language, str2, options3) {
      const opts = defaults(options3);
      const engine = getEngine(language, opts);
      if (typeof engine.parse !== "function") {
        throw new TypeError('expected "' + language + '.parse" to be a function');
      }
      return engine.parse(str2, opts);
    };
  }
});

// node_modules/gray-matter/index.js
var require_gray_matter = __commonJS({
  "node_modules/gray-matter/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var fs2 = require("fs");
    var sections = require_section_matter();
    var defaults = require_defaults();
    var stringify = require_stringify();
    var excerpt = require_excerpt();
    var engines2 = require_engines();
    var toFile = require_to_file();
    var parse2 = require_parse();
    var utils = require_utils();
    function matter(input, options3) {
      if (input === "") {
        return { data: {}, content: input, excerpt: "", orig: input };
      }
      let file = toFile(input);
      const cached = matter.cache[file.content];
      if (!options3) {
        if (cached) {
          file = Object.assign({}, cached);
          file.orig = cached.orig;
          return file;
        }
        matter.cache[file.content] = file;
      }
      return parseMatter(file, options3);
    }
    function parseMatter(file, options3) {
      const opts = defaults(options3);
      const open = opts.delimiters[0];
      const close = "\n" + opts.delimiters[1];
      let str2 = file.content;
      if (opts.language) {
        file.language = opts.language;
      }
      const openLen = open.length;
      if (!utils.startsWith(str2, open, openLen)) {
        excerpt(file, opts);
        return file;
      }
      if (str2.charAt(openLen) === open.slice(-1)) {
        return file;
      }
      str2 = str2.slice(openLen);
      const len = str2.length;
      const language = matter.language(str2, opts);
      if (language.name) {
        file.language = language.name;
        str2 = str2.slice(language.raw.length);
      }
      let closeIndex = str2.indexOf(close);
      if (closeIndex === -1) {
        closeIndex = len;
      }
      file.matter = str2.slice(0, closeIndex);
      const block = file.matter.replace(/^\s*#[^\n]+/gm, "").trim();
      if (block === "") {
        file.isEmpty = true;
        file.empty = file.content;
        file.data = {};
      } else {
        file.data = parse2(file.language, file.matter, opts);
      }
      if (closeIndex === len) {
        file.content = "";
      } else {
        file.content = str2.slice(closeIndex + close.length);
        if (file.content[0] === "\r") {
          file.content = file.content.slice(1);
        }
        if (file.content[0] === "\n") {
          file.content = file.content.slice(1);
        }
      }
      excerpt(file, opts);
      if (opts.sections === true || typeof opts.section === "function") {
        sections(file, opts.section);
      }
      return file;
    }
    matter.engines = engines2;
    matter.stringify = function(file, data, options3) {
      if (typeof file === "string")
        file = matter(file, options3);
      return stringify(file, data, options3);
    };
    matter.read = function(filepath, options3) {
      const str2 = fs2.readFileSync(filepath, "utf8");
      const file = matter(str2, options3);
      file.path = filepath;
      return file;
    };
    matter.test = function(str2, options3) {
      return utils.startsWith(str2, defaults(options3).delimiters[0]);
    };
    matter.language = function(str2, options3) {
      const opts = defaults(options3);
      const open = opts.delimiters[0];
      if (matter.test(str2)) {
        str2 = str2.slice(open.length);
      }
      const language = str2.slice(0, str2.search(/\r?\n/));
      return {
        raw: language,
        name: language ? language.trim() : ""
      };
    };
    matter.cache = {};
    matter.clearCache = function() {
      matter.cache = {};
    };
    module2.exports = matter;
  }
});

// node_modules/svelte/compiler.js
var require_compiler = __commonJS({
  "node_modules/svelte/compiler.js"(exports2, module2) {
    init_shims();
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.svelte = {}));
    })(exports2, function(exports3) {
      "use strict";
      const now = typeof process !== "undefined" && process.hrtime ? () => {
        const t = process.hrtime();
        return t[0] * 1e3 + t[1] / 1e6;
      } : () => self.performance.now();
      function collapse_timings(timings) {
        const result = {};
        timings.forEach((timing) => {
          result[timing.label] = Object.assign({
            total: timing.end - timing.start
          }, timing.children && collapse_timings(timing.children));
        });
        return result;
      }
      class Stats {
        constructor() {
          this.start_time = now();
          this.stack = [];
          this.current_children = this.timings = [];
        }
        start(label) {
          const timing = {
            label,
            start: now(),
            end: null,
            children: []
          };
          this.current_children.push(timing);
          this.stack.push(timing);
          this.current_timing = timing;
          this.current_children = timing.children;
        }
        stop(label) {
          if (label !== this.current_timing.label) {
            throw new Error(`Mismatched timing labels (expected ${this.current_timing.label}, got ${label})`);
          }
          this.current_timing.end = now();
          this.stack.pop();
          this.current_timing = this.stack[this.stack.length - 1];
          this.current_children = this.current_timing ? this.current_timing.children : this.timings;
        }
        render() {
          const timings = Object.assign({
            total: now() - this.start_time
          }, collapse_timings(this.timings));
          return {
            timings
          };
        }
      }
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function isInAstralSet(code, set) {
        var pos = 65536;
        for (var i2 = 0; i2 < set.length; i2 += 2) {
          pos += set[i2];
          if (pos > code) {
            return false;
          }
          pos += set[i2 + 1];
          if (pos >= code) {
            return true;
          }
        }
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType2(label, conf) {
        if (conf === void 0)
          conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords$1 = {};
      function kw(name, options3) {
        if (options3 === void 0)
          options3 = {};
        options3.keyword = name;
        return keywords$1[name] = new TokenType(name, options3);
      }
      var types2 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code, ecma2019String) {
        return code === 10 || code === 13 || !ecma2019String && (code === 8232 || code === 8233);
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString = ref.toString;
      function has(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      }
      var isArray = Array.isArray || function(obj) {
        return toString.call(obj) === "[object Array]";
      };
      function wordsRegexp(words) {
        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
      }
      var Position = function Position2(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n2) {
        return new Position(this.line, this.column + n2);
      };
      var SourceLocation = function SourceLocation2(p2, start, end) {
        this.start = start;
        this.end = end;
        if (p2.sourceFile !== null) {
          this.source = p2.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0; ; ) {
          lineBreakG.lastIndex = cur;
          var match = lineBreakG.exec(input);
          if (match && match.index < offset) {
            ++line;
            cur = match.index + match[0].length;
          } else {
            return new Position(line, offset - cur);
          }
        }
      }
      var defaultOptions = {
        ecmaVersion: null,
        sourceType: "script",
        onInsertedSemicolon: null,
        onTrailingComma: null,
        allowReserved: null,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowAwaitOutsideFunction: null,
        allowSuperOutsideMethod: null,
        allowHashBang: false,
        locations: false,
        onToken: null,
        onComment: null,
        ranges: false,
        program: null,
        sourceFile: null,
        directSourceFile: null,
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options3 = {};
        for (var opt in defaultOptions) {
          options3[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options3.ecmaVersion === "latest") {
          options3.ecmaVersion = 1e8;
        } else if (options3.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options3.ecmaVersion = 11;
        } else if (options3.ecmaVersion >= 2015) {
          options3.ecmaVersion -= 2009;
        }
        if (options3.allowReserved == null) {
          options3.allowReserved = options3.ecmaVersion < 5;
        }
        if (isArray(options3.onToken)) {
          var tokens = options3.onToken;
          options3.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray(options3.onComment)) {
          options3.onComment = pushComment(options3, options3.onComment);
        }
        return options3;
      }
      function pushComment(options3, array) {
        return function(block, text2, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text2,
            start,
            end
          };
          if (options3.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options3.ranges) {
            comment.range = [start, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser2(options3, input, startPos) {
        this.options = options3 = getOptions(options3);
        this.sourceFile = options3.sourceFile;
        this.keywords = wordsRegexp(keywords[options3.ecmaVersion >= 6 ? 6 : options3.sourceType === "module" ? "5module" : 5]);
        var reserved3 = "";
        if (options3.allowReserved !== true) {
          reserved3 = reservedWords[options3.ecmaVersion >= 6 ? 6 : options3.ecmaVersion === 5 ? 5 : 3];
          if (options3.sourceType === "module") {
            reserved3 += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved3);
        var reservedStrict = (reserved3 ? reserved3 + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types2.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options3.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = Object.create(null);
        if (this.pos === 0 && options3.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, inNonArrowFunction: { configurable: true } };
      Parser.prototype.parse = function parse3() {
        var node2 = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node2);
      };
      prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.canAwait.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var scope2 = this.scopeStack[i2];
          if (scope2.inClassFieldInit) {
            return false;
          }
          if (scope2.flags & SCOPE_FUNCTION) {
            return (scope2.flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.inNonArrowFunction.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & SCOPE_FUNCTION) > 0 || inClassFieldInit;
      };
      Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i2 = 0; i2 < plugins.length; i2++) {
          cls = plugins[i2](cls);
        }
        return cls;
      };
      Parser.parse = function parse3(input, options3) {
        return new this(options3, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt2(input, pos, options3) {
        var parser2 = new this(options3, input, pos);
        parser2.nextToken();
        return parser2.parseExpression();
      };
      Parser.tokenizer = function tokenizer2(input, options3) {
        return new this(options3, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp = Parser.prototype;
      var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      pp.strictDirective = function(start) {
        for (; ; ) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp.isContextual = function(name) {
        return this.type === types2.name && this.value === name && !this.containsEsc;
      };
      pp.eatContextual = function(name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp.expectContextual = function(name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp.canInsertSemicolon = function() {
        return this.type === types2.eof || this.type === types2.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp.semicolon = function() {
        if (!this.eat(types2.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      function DestructuringErrors() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      }
      pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, "Parenthesized pattern");
        }
      };
      pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$1 = Parser.prototype;
      pp$1.parseTopLevel = function(node2) {
        var exports4 = Object.create(null);
        if (!node2.body) {
          node2.body = [];
        }
        while (this.type !== types2.eof) {
          var stmt = this.parseStatement(null, true, exports4);
          node2.body.push(stmt);
        }
        if (this.inModule) {
          for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
            var name = list2[i2];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node2.body);
        this.next();
        node2.sourceType = this.options.sourceType;
        return this.finishNode(node2, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$1.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$1.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$1.parseStatement = function(context, topLevel, exports4) {
        var starttype = this.type, node2 = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types2._var;
          kind = "let";
        }
        switch (starttype) {
          case types2._break:
          case types2._continue:
            return this.parseBreakContinueStatement(node2, starttype.keyword);
          case types2._debugger:
            return this.parseDebuggerStatement(node2);
          case types2._do:
            return this.parseDoStatement(node2);
          case types2._for:
            return this.parseForStatement(node2);
          case types2._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node2, false, !context);
          case types2._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node2, true);
          case types2._if:
            return this.parseIfStatement(node2);
          case types2._return:
            return this.parseReturnStatement(node2);
          case types2._switch:
            return this.parseSwitchStatement(node2);
          case types2._throw:
            return this.parseThrowStatement(node2);
          case types2._try:
            return this.parseTryStatement(node2);
          case types2._const:
          case types2._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node2, kind);
          case types2._while:
            return this.parseWhileStatement(node2);
          case types2._with:
            return this.parseWithStatement(node2);
          case types2.braceL:
            return this.parseBlock(true, node2);
          case types2.semi:
            return this.parseEmptyStatement(node2);
          case types2._export:
          case types2._import:
            if (this.options.ecmaVersion > 10 && starttype === types2._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node2, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types2._import ? this.parseImport(node2) : this.parseExport(node2, exports4);
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node2, true, !context);
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types2.name && expr.type === "Identifier" && this.eat(types2.colon)) {
              return this.parseLabeledStatement(node2, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node2, expr);
            }
        }
      };
      pp$1.parseBreakContinueStatement = function(node2, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types2.semi) || this.insertSemicolon()) {
          node2.label = null;
        } else if (this.type !== types2.name) {
          this.unexpected();
        } else {
          node2.label = this.parseIdent();
          this.semicolon();
        }
        var i2 = 0;
        for (; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if (node2.label == null || lab.name === node2.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node2.label && isBreak) {
              break;
            }
          }
        }
        if (i2 === this.labels.length) {
          this.raise(node2.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$1.parseDebuggerStatement = function(node2) {
        this.next();
        this.semicolon();
        return this.finishNode(node2, "DebuggerStatement");
      };
      pp$1.parseDoStatement = function(node2) {
        this.next();
        this.labels.push(loopLabel);
        node2.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types2._while);
        node2.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types2.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node2, "DoWhileStatement");
      };
      pp$1.parseForStatement = function(node2) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types2.parenL);
        if (this.type === types2.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node2, null);
        }
        var isLet = this.isLet();
        if (this.type === types2._var || this.type === types2._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types2._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types2._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node2.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node2, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node2, init$1);
        }
        var refDestructuringErrors = new DestructuringErrors();
        var init2 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
        if (this.type === types2._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types2._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node2.await = awaitAt > -1;
            }
          }
          this.toAssignable(init2, false, refDestructuringErrors);
          this.checkLValPattern(init2);
          return this.parseForIn(node2, init2);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, init2);
      };
      pp$1.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$1.parseIfStatement = function(node2) {
        this.next();
        node2.test = this.parseParenExpression();
        node2.consequent = this.parseStatement("if");
        node2.alternate = this.eat(types2._else) ? this.parseStatement("if") : null;
        return this.finishNode(node2, "IfStatement");
      };
      pp$1.parseReturnStatement = function(node2) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types2.semi) || this.insertSemicolon()) {
          node2.argument = null;
        } else {
          node2.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node2, "ReturnStatement");
      };
      pp$1.parseSwitchStatement = function(node2) {
        this.next();
        node2.discriminant = this.parseParenExpression();
        node2.cases = [];
        this.expect(types2.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types2.braceR; ) {
          if (this.type === types2._case || this.type === types2._default) {
            var isCase = this.type === types2._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node2.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types2.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node2, "SwitchStatement");
      };
      pp$1.parseThrowStatement = function(node2) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node2.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node2, "ThrowStatement");
      };
      var empty2 = [];
      pp$1.parseTryStatement = function(node2) {
        this.next();
        node2.block = this.parseBlock();
        node2.handler = null;
        if (this.type === types2._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types2.parenL)) {
            clause.param = this.parseBindingAtom();
            var simple = clause.param.type === "Identifier";
            this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
            this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
            this.expect(types2.parenR);
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node2.handler = this.finishNode(clause, "CatchClause");
        }
        node2.finalizer = this.eat(types2._finally) ? this.parseBlock() : null;
        if (!node2.handler && !node2.finalizer) {
          this.raise(node2.start, "Missing catch or finally clause");
        }
        return this.finishNode(node2, "TryStatement");
      };
      pp$1.parseVarStatement = function(node2, kind) {
        this.next();
        this.parseVar(node2, false, kind);
        this.semicolon();
        return this.finishNode(node2, "VariableDeclaration");
      };
      pp$1.parseWhileStatement = function(node2) {
        this.next();
        node2.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node2.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node2, "WhileStatement");
      };
      pp$1.parseWithStatement = function(node2) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node2.object = this.parseParenExpression();
        node2.body = this.parseStatement("with");
        return this.finishNode(node2, "WithStatement");
      };
      pp$1.parseEmptyStatement = function(node2) {
        this.next();
        return this.finishNode(node2, "EmptyStatement");
      };
      pp$1.parseLabeledStatement = function(node2, maybeName, expr, context) {
        for (var i$12 = 0, list2 = this.labels; i$12 < list2.length; i$12 += 1) {
          var label = list2[i$12];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types2._switch ? "switch" : null;
        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node2.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node2.label = expr;
        return this.finishNode(node2, "LabeledStatement");
      };
      pp$1.parseExpressionStatement = function(node2, expr) {
        node2.expression = expr;
        this.semicolon();
        return this.finishNode(node2, "ExpressionStatement");
      };
      pp$1.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
        if (createNewLexicalScope === void 0)
          createNewLexicalScope = true;
        if (node2 === void 0)
          node2 = this.startNode();
        node2.body = [];
        this.expect(types2.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types2.braceR) {
          var stmt = this.parseStatement(null);
          node2.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node2, "BlockStatement");
      };
      pp$1.parseFor = function(node2, init2) {
        node2.init = init2;
        this.expect(types2.semi);
        node2.test = this.type === types2.semi ? null : this.parseExpression();
        this.expect(types2.semi);
        node2.update = this.type === types2.parenR ? null : this.parseExpression();
        this.expect(types2.parenR);
        node2.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node2, "ForStatement");
      };
      pp$1.parseForIn = function(node2, init2) {
        var isForIn = this.type === types2._in;
        this.next();
        if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
          this.raise(init2.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
        }
        node2.left = init2;
        node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types2.parenR);
        node2.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$1.parseVar = function(node2, isFor, kind) {
        node2.declarations = [];
        node2.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types2.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (kind === "const" && !(this.type === types2._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types2._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types2.comma)) {
            break;
          }
        }
        return node2;
      };
      pp$1.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$1.parseFunction = function(node2, statement, allowExpressionBody, isAsync) {
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types2.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node2.generator = this.eat(types2.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node2.id = statement & FUNC_NULLABLE_ID && this.type !== types2.name ? null : this.parseIdent();
          if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node2.async, node2.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node2.id = this.type === types2.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node2);
        this.parseFunctionBody(node2, allowExpressionBody, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$1.parseFunctionParams = function(node2) {
        this.expect(types2.parenL);
        node2.params = this.parseBindingList(types2.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$1.parseClass = function(node2, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node2, isStatement);
        this.parseClassSuper(node2);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types2.braceL);
        while (this.type !== types2.braceR) {
          var element = this.parseClassElement(node2.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raise(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node2.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$1.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types2.semi)) {
          return null;
        }
        var ecmaVersion = this.options.ecmaVersion;
        var node2 = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        node2.static = false;
        if (this.eatContextual("static")) {
          if (this.isClassElementNameStart() || this.type === types2.star) {
            node2.static = true;
          } else {
            keyName = "static";
          }
        }
        if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types2.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types2.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node2.computed = false;
          node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node2.key.name = keyName;
          this.finishNode(node2.key, "Identifier");
        } else {
          this.parseClassElementName(node2);
        }
        if (ecmaVersion < 13 || this.type === types2.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node2.static && checkKeyName(node2, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node2.key.start, "Constructor can't have get/set modifier");
          }
          node2.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node2);
        }
        return node2;
      };
      pp$1.isClassElementNameStart = function() {
        return this.type === types2.name || this.type === types2.privateId || this.type === types2.num || this.type === types2.string || this.type === types2.bracketL || this.type.keyword;
      };
      pp$1.parseClassElementName = function(element) {
        if (this.type === types2.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value2.params.length !== 0) {
          this.raiseRecoverable(value2.start, "getter should have no params");
        }
        if (method.kind === "set" && value2.params.length !== 1) {
          this.raiseRecoverable(value2.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value2.params[0].type === "RestElement") {
          this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$1.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types2.eq)) {
          var scope2 = this.currentThisScope();
          var inClassFieldInit = scope2.inClassFieldInit;
          scope2.inClassFieldInit = true;
          field.value = this.parseMaybeAssign();
          scope2.inClassFieldInit = inClassFieldInit;
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$1.parseClassId = function(node2, isStatement) {
        if (this.type === types2.name) {
          node2.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node2.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node2.id = null;
        }
      };
      pp$1.parseClassSuper = function(node2) {
        node2.superClass = this.eat(types2._extends) ? this.parseExprSubscripts() : null;
      };
      pp$1.enterClassBody = function() {
        var element = { declared: Object.create(null), used: [] };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$1.exitClassBody = function() {
        var ref2 = this.privateNameStack.pop();
        var declared = ref2.declared;
        var used = ref2.used;
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i2 = 0; i2 < used.length; ++i2) {
          var id2 = used[i2];
          if (!has(declared, id2.name)) {
            if (parent) {
              parent.used.push(id2);
            } else {
              this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node2, name) {
        var computed = node2.computed;
        var key = node2.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
      }
      pp$1.parseExport = function(node2, exports4) {
        this.next();
        if (this.eat(types2.star)) {
          if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
              node2.exported = this.parseIdent(true);
              this.checkExport(exports4, node2.exported.name, this.lastTokStart);
            } else {
              node2.exported = null;
            }
          }
          this.expectContextual("from");
          if (this.type !== types2.string) {
            this.unexpected();
          }
          node2.source = this.parseExprAtom();
          this.semicolon();
          return this.finishNode(node2, "ExportAllDeclaration");
        }
        if (this.eat(types2._default)) {
          this.checkExport(exports4, "default", this.lastTokStart);
          var isAsync;
          if (this.type === types2._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) {
              this.next();
            }
            node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
          } else if (this.type === types2._class) {
            var cNode = this.startNode();
            node2.declaration = this.parseClass(cNode, "nullableID");
          } else {
            node2.declaration = this.parseMaybeAssign();
            this.semicolon();
          }
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node2.declaration = this.parseStatement(null);
          if (node2.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports4, node2.declaration.declarations);
          } else {
            this.checkExport(exports4, node2.declaration.id.name, node2.declaration.id.start);
          }
          node2.specifiers = [];
          node2.source = null;
        } else {
          node2.declaration = null;
          node2.specifiers = this.parseExportSpecifiers(exports4);
          if (this.eatContextual("from")) {
            if (this.type !== types2.string) {
              this.unexpected();
            }
            node2.source = this.parseExprAtom();
          } else {
            for (var i2 = 0, list2 = node2.specifiers; i2 < list2.length; i2 += 1) {
              var spec = list2[i2];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
            }
            node2.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node2, "ExportNamedDeclaration");
      };
      pp$1.checkExport = function(exports4, name, pos) {
        if (!exports4) {
          return;
        }
        if (has(exports4, name)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports4[name] = true;
      };
      pp$1.checkPatternExport = function(exports4, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports4, pat.name, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.checkPatternExport(exports4, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$12 = 0, list$1 = pat.elements; i$12 < list$1.length; i$12 += 1) {
            var elt = list$1[i$12];
            if (elt) {
              this.checkPatternExport(exports4, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports4, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports4, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports4, pat.argument);
        } else if (type === "ParenthesizedExpression") {
          this.checkPatternExport(exports4, pat.expression);
        }
      };
      pp$1.checkVariableExport = function(exports4, decls) {
        if (!exports4) {
          return;
        }
        for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
          var decl = list2[i2];
          this.checkPatternExport(exports4, decl.id);
        }
      };
      pp$1.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$1.parseExportSpecifiers = function(exports4) {
        var nodes = [], first = true;
        this.expect(types2.braceL);
        while (!this.eat(types2.braceR)) {
          if (!first) {
            this.expect(types2.comma);
            if (this.afterTrailingComma(types2.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node2 = this.startNode();
          node2.local = this.parseIdent(true);
          node2.exported = this.eatContextual("as") ? this.parseIdent(true) : node2.local;
          this.checkExport(exports4, node2.exported.name, node2.exported.start);
          nodes.push(this.finishNode(node2, "ExportSpecifier"));
        }
        return nodes;
      };
      pp$1.parseImport = function(node2) {
        this.next();
        if (this.type === types2.string) {
          node2.specifiers = empty2;
          node2.source = this.parseExprAtom();
        } else {
          node2.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node2.source = this.type === types2.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node2, "ImportDeclaration");
      };
      pp$1.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types2.name) {
          var node2 = this.startNode();
          node2.local = this.parseIdent();
          this.checkLValSimple(node2.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
          if (!this.eat(types2.comma)) {
            return nodes;
          }
        }
        if (this.type === types2.star) {
          var node$1 = this.startNode();
          this.next();
          this.expectContextual("as");
          node$1.local = this.parseIdent();
          this.checkLValSimple(node$1.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
          return nodes;
        }
        this.expect(types2.braceL);
        while (!this.eat(types2.braceR)) {
          if (!first) {
            this.expect(types2.comma);
            if (this.afterTrailingComma(types2.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node$2 = this.startNode();
          node$2.imported = this.parseIdent(true);
          if (this.eatContextual("as")) {
            node$2.local = this.parseIdent();
          } else {
            this.checkUnreserved(node$2.imported);
            node$2.local = node$2.imported;
          }
          this.checkLValSimple(node$2.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$2, "ImportSpecifier"));
        }
        return nodes;
      };
      pp$1.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }
      };
      pp$1.isDirectiveCandidate = function(statement) {
        return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$2 = Parser.prototype;
      pp$2.toAssignable = function(node2, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node2) {
          switch (node2.type) {
            case "Identifier":
              if (this.inAsync && node2.name === "await") {
                this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node2.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i2 = 0, list2 = node2.properties; i2 < list2.length; i2 += 1) {
                var prop = list2[i2];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node2.kind !== "init") {
                this.raise(node2.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node2.value, isBinding);
              break;
            case "ArrayExpression":
              node2.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node2.elements, isBinding);
              break;
            case "SpreadElement":
              node2.type = "RestElement";
              this.toAssignable(node2.argument, isBinding);
              if (node2.argument.type === "AssignmentPattern") {
                this.raise(node2.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node2.operator !== "=") {
                this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node2.type = "AssignmentPattern";
              delete node2.operator;
              this.toAssignable(node2.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node2.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node2;
      };
      pp$2.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$2.parseSpread = function(refDestructuringErrors) {
        var node2 = this.startNode();
        this.next();
        node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node2, "SpreadElement");
      };
      pp$2.parseRestBinding = function() {
        var node2 = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types2.name) {
          this.unexpected();
        }
        node2.argument = this.parseBindingAtom();
        return this.finishNode(node2, "RestElement");
      };
      pp$2.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types2.bracketL:
              var node2 = this.startNode();
              this.next();
              node2.elements = this.parseBindingList(types2.bracketR, true, true);
              return this.finishNode(node2, "ArrayPattern");
            case types2.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types2.comma);
          }
          if (allowEmpty && this.type === types2.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types2.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types2.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            var elem = this.parseMaybeDefault(this.start, this.startLoc);
            this.parseBindingListItem(elem);
            elts.push(elem);
          }
        }
        return elts;
      };
      pp$2.parseBindingListItem = function(param) {
        return param;
      };
      pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types2.eq)) {
          return left;
        }
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.left = left;
        node2.right = this.parseMaybeAssign();
        return this.finishNode(node2, "AssignmentPattern");
      };
      pp$2.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (has(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$2.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$12 = 0, list$1 = expr.elements; i$12 < list$1.length; i$12 += 1) {
              var elem = list$1[i$12];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$2.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var pp$3 = Parser.prototype;
      pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name;
        switch (key.type) {
          case "Identifier":
            name = key.name;
            break;
          case "Literal":
            name = String(key.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$3.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types2.comma) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.expressions = [expr];
          while (this.eat(types2.comma)) {
            node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node2, "SequenceExpression");
        }
        return expr;
      };
      pp$3.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types2.parenL || this.type === types2.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.operator = this.value;
          if (this.type === types2.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types2.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node2.left = left;
          this.next();
          node2.right = this.parseMaybeAssign(forInit);
          return this.finishNode(node2, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$3.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types2.question)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.test = expr;
          node2.consequent = this.parseMaybeAssign();
          this.expect(types2.colon);
          node2.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node2, "ConditionalExpression");
        }
        return expr;
      };
      pp$3.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types2._in)) {
          if (prec > minPrec) {
            var logical = this.type === types2.logicalOR || this.type === types2.logicalAND;
            var coalesce = this.type === types2.coalesce;
            if (coalesce) {
              prec = types2.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, forInit);
            var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types2.coalesce || coalesce && (this.type === types2.logicalOR || this.type === types2.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.left = left;
        node2.operator = op;
        node2.right = right;
        return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait();
          sawUnary = true;
        } else if (this.type.prefix) {
          var node2 = this.startNode(), update = this.type === types2.incDec;
          node2.operator = this.value;
          node2.prefix = true;
          this.next();
          node2.argument = this.parseMaybeUnary(null, true, update);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node2.argument);
          } else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier") {
            this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
          } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
            this.raiseRecoverable(node2.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types2.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isPrivateFieldAccess(node2) {
        return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression);
      }
      pp$3.parseExprSubscripts = function(refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$3.parseSubscripts = function(base2, startPos, startLoc, noCalls) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base2 || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base2 = element;
        }
      };
      pp$3.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types2.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types2.bracketL);
        if (computed || optional && this.type !== types2.parenL && this.type !== types2.backQuote || this.eat(types2.dot)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.object = base2;
          if (computed) {
            node2.property = this.parseExpression();
            this.expect(types2.bracketR);
          } else if (this.type === types2.privateId && base2.type !== "Super") {
            node2.property = this.parsePrivateIdent();
          } else {
            node2.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node2.computed = !!computed;
          if (optionalSupported) {
            node2.optional = optional;
          }
          base2 = this.finishNode(node2, "MemberExpression");
        } else if (!noCalls && this.eat(types2.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types2.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types2.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base2;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base2 = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types2.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base2;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base2 = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base2;
      };
      pp$3.parseExprAtom = function(refDestructuringErrors) {
        if (this.type === types2.slash) {
          this.readRegexp();
        }
        var node2, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types2._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node2 = this.startNode();
            this.next();
            if (this.type === types2.parenL && !this.allowDirectSuper) {
              this.raise(node2.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types2.dot && this.type !== types2.bracketL && this.type !== types2.parenL) {
              this.unexpected();
            }
            return this.finishNode(node2, "Super");
          case types2._this:
            node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "ThisExpression");
          case types2.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id2 = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types2._function)) {
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types2.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false);
              }
              if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types2.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id2 = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types2.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true);
              }
            }
            return id2;
          case types2.regexp:
            var value2 = this.value;
            node2 = this.parseLiteral(value2.value);
            node2.regex = { pattern: value2.pattern, flags: value2.flags };
            return node2;
          case types2.num:
          case types2.string:
            return this.parseLiteral(this.value);
          case types2._null:
          case types2._true:
          case types2._false:
            node2 = this.startNode();
            node2.value = this.type === types2._null ? null : this.type === types2._true;
            node2.raw = this.type.keyword;
            this.next();
            return this.finishNode(node2, "Literal");
          case types2.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types2.bracketL:
            node2 = this.startNode();
            this.next();
            node2.elements = this.parseExprList(types2.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node2, "ArrayExpression");
          case types2.braceL:
            return this.parseObj(false, refDestructuringErrors);
          case types2._function:
            node2 = this.startNode();
            this.next();
            return this.parseFunction(node2, 0);
          case types2._class:
            return this.parseClass(this.startNode(), false);
          case types2._new:
            return this.parseNew();
          case types2.backQuote:
            return this.parseTemplate();
          case types2._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport();
            } else {
              return this.unexpected();
            }
          default:
            this.unexpected();
        }
      };
      pp$3.parseExprImport = function() {
        var node2 = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        var meta = this.parseIdent(true);
        switch (this.type) {
          case types2.parenL:
            return this.parseDynamicImport(node2);
          case types2.dot:
            node2.meta = meta;
            return this.parseImportMeta(node2);
          default:
            this.unexpected();
        }
      };
      pp$3.parseDynamicImport = function(node2) {
        this.next();
        node2.source = this.parseMaybeAssign();
        if (!this.eat(types2.parenR)) {
          var errorPos = this.start;
          if (this.eat(types2.comma) && this.eat(types2.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node2, "ImportExpression");
      };
      pp$3.parseImportMeta = function(node2) {
        this.next();
        var containsEsc = this.containsEsc;
        node2.property = this.parseIdent(true);
        if (node2.property.name !== "meta") {
          this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node2, "MetaProperty");
      };
      pp$3.parseLiteral = function(value2) {
        var node2 = this.startNode();
        node2.value = value2;
        node2.raw = this.input.slice(this.start, this.end);
        if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
          node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node2, "Literal");
      };
      pp$3.parseParenExpression = function() {
        this.expect(types2.parenL);
        var val = this.parseExpression();
        this.expect(types2.parenR);
        return val;
      };
      pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types2.parenR) {
            first ? first = false : this.expect(types2.comma);
            if (allowTrailingComma && this.afterTrailingComma(types2.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types2.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types2.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.start, innerEndLoc = this.startLoc;
          this.expect(types2.parenR);
          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types2.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$3.parseParenItem = function(item) {
        return item;
      };
      pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
      };
      var empty$1 = [];
      pp$3.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node2 = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types2.dot)) {
          node2.meta = meta;
          var containsEsc = this.containsEsc;
          node2.property = this.parseIdent(true);
          if (node2.property.name !== "target") {
            this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
          }
          if (!this.inNonArrowFunction) {
            this.raiseRecoverable(node2.start, "'new.target' can only be used in functions");
          }
          return this.finishNode(node2, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types2._import;
        node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
        if (isImport && node2.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        if (this.eat(types2.parenL)) {
          node2.arguments = this.parseExprList(types2.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node2.arguments = empty$1;
        }
        return this.finishNode(node2, "NewExpression");
      };
      pp$3.parseTemplateElement = function(ref2) {
        var isTagged = ref2.isTagged;
        var elem = this.startNode();
        if (this.type === types2.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types2.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$3.parseTemplate = function(ref2) {
        if (ref2 === void 0)
          ref2 = {};
        var isTagged = ref2.isTagged;
        if (isTagged === void 0)
          isTagged = false;
        var node2 = this.startNode();
        this.next();
        node2.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node2.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types2.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types2.dollarBraceL);
          node2.expressions.push(this.parseExpression());
          this.expect(types2.braceR);
          node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node2, "TemplateLiteral");
      };
      pp$3.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types2.name || this.type === types2.num || this.type === types2.string || this.type === types2.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types2.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$3.parseObj = function(isPattern, refDestructuringErrors) {
        var node2 = this.startNode(), first = true, propHash = {};
        node2.properties = [];
        this.next();
        while (!this.eat(types2.braceR)) {
          if (!first) {
            this.expect(types2.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types2.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node2.properties.push(prop);
        }
        return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types2.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types2.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          if (this.type === types2.parenL && refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0) {
              refDestructuringErrors.parenthesizedAssign = this.start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = this.start;
            }
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types2.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types2.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types2.star);
          this.parsePropertyName(prop, refDestructuringErrors);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types2.colon) {
          this.unexpected();
        }
        if (this.eat(types2.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types2.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types2.comma && this.type !== types2.braceR && this.type !== types2.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          prop.kind = prop.key.name;
          this.parsePropertyName(prop);
          prop.value = this.parseMethod(false);
          var paramCount = prop.kind === "get" ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            if (prop.kind === "get") {
              this.raiseRecoverable(start, "getter should have no params");
            } else {
              this.raiseRecoverable(start, "setter should have exactly one param");
            }
          } else {
            if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
              this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
            }
          }
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types2.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$3.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types2.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types2.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types2.num || this.type === types2.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$3.initFunction = function(node2) {
        node2.id = null;
        if (this.options.ecmaVersion >= 6) {
          node2.generator = node2.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = false;
        }
      };
      pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 6) {
          node2.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types2.parenL);
        node2.params = this.parseBindingList(types2.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node2, false, true);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, "FunctionExpression");
      };
      pp$3.parseArrowExpression = function(node2, params, isAsync) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node2.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node2, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, "ArrowFunctionExpression");
      };
      pp$3.parseFunctionBody = function(node2, isArrowFunction, isMethod) {
        var isExpression = isArrowFunction && this.type !== types2.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node2.body = this.parseMaybeAssign();
          node2.expression = true;
          this.checkParams(node2, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
          if (this.strict && node2.id) {
            this.checkLValSimple(node2.id, BIND_OUTSIDE);
          }
          node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node2.expression = false;
          this.adaptDirectivePrologue(node2.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$3.isSimpleParamList = function(params) {
        for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$3.checkParams = function(node2, allowDuplicates) {
        var nameHash = Object.create(null);
        for (var i2 = 0, list2 = node2.params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types2.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types2.comma) {
            elt = null;
          } else if (this.type === types2.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types2.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$3.checkUnreserved = function(ref2) {
        var start = ref2.start;
        var end = ref2.end;
        var name = ref2.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.currentThisScope().inClassFieldInit && name === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re2.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$3.parseIdent = function(liberal, isBinding) {
        var node2 = this.startNode();
        if (this.type === types2.name) {
          node2.name = this.value;
        } else if (this.type.keyword) {
          node2.name = this.type.keyword;
          if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
        } else {
          this.unexpected();
        }
        this.next(!!liberal);
        this.finishNode(node2, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node2);
          if (node2.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node2.start;
          }
        }
        return node2;
      };
      pp$3.parsePrivateIdent = function() {
        var node2 = this.startNode();
        if (this.type === types2.privateId) {
          node2.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node2, "PrivateIdentifier");
        if (this.privateNameStack.length === 0) {
          this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
        } else {
          this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
        }
        return node2;
      };
      pp$3.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node2 = this.startNode();
        this.next();
        if (this.type === types2.semi || this.canInsertSemicolon() || this.type !== types2.star && !this.type.startsExpr) {
          node2.delegate = false;
          node2.argument = null;
        } else {
          node2.delegate = this.eat(types2.star);
          node2.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node2, "YieldExpression");
      };
      pp$3.parseAwait = function() {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node2 = this.startNode();
        this.next();
        node2.argument = this.parseMaybeUnary(null, true);
        return this.finishNode(node2, "AwaitExpression");
      };
      var pp$4 = Parser.prototype;
      pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function() {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$5 = Parser.prototype;
      var Scope = function Scope2(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
        this.inClassFieldInit = false;
      };
      pp$5.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$5.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$5.treatFunctionsAsVarInScope = function(scope2) {
        return scope2.flags & SCOPE_FUNCTION || !this.inModule && scope2.flags & SCOPE_TOP;
      };
      pp$5.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope2 = this.currentScope();
          redeclared = scope2.lexical.indexOf(name) > -1 || scope2.functions.indexOf(name) > -1 || scope2.var.indexOf(name) > -1;
          scope2.lexical.push(name);
          if (this.inModule && scope2.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$5.checkLocalExport = function(id2) {
        if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
          this.undefinedExports[id2.name] = id2;
        }
      };
      pp$5.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$5.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope2 = this.scopeStack[i2];
          if (scope2.flags & SCOPE_VAR) {
            return scope2;
          }
        }
      };
      pp$5.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope2 = this.scopeStack[i2];
          if (scope2.flags & SCOPE_VAR && !(scope2.flags & SCOPE_ARROW)) {
            return scope2;
          }
        }
      };
      var Node = function Node2(parser2, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser2.options.locations) {
          this.loc = new SourceLocation(parser2, loc);
        }
        if (parser2.options.directSourceFile) {
          this.sourceFile = parser2.options.directSourceFile;
        }
        if (parser2.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$6 = Parser.prototype;
      pp$6.startNode = function() {
        return new Node(this, this.start, this.startLoc);
      };
      pp$6.startNodeAt = function(pos, loc) {
        return new Node(this, pos, loc);
      };
      function finishNodeAt(node2, type, pos, loc) {
        node2.type = type;
        node2.end = pos;
        if (this.options.locations) {
          node2.loc.end = loc;
        }
        if (this.options.ranges) {
          node2.range[1] = pos;
        }
        return node2;
      }
      pp$6.finishNode = function(node2, type) {
        return finishNodeAt.call(this, node2, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$6.finishNodeAt = function(node2, type, pos, loc) {
        return finishNodeAt.call(this, node2, type, pos, loc);
      };
      pp$6.copyNode = function(node2) {
        var newNode = new Node(this, node2.start, this.startLoc);
        for (var prop in node2) {
          newNode[prop] = node2[prop];
        }
        return newNode;
      };
      var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types$1 = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p2) {
          return p2.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$7 = Parser.prototype;
      pp$7.initialContext = function() {
        return [types$1.b_stat];
      };
      pp$7.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types$1.f_expr || parent === types$1.f_stat) {
          return true;
        }
        if (prevType === types2.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types2._return || prevType === types2.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types2._else || prevType === types2.semi || prevType === types2.eof || prevType === types2.parenR || prevType === types2.arrow) {
          return true;
        }
        if (prevType === types2.braceL) {
          return parent === types$1.b_stat;
        }
        if (prevType === types2._var || prevType === types2._const || prevType === types2.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$7.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$7.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types2.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      types2.parenR.updateContext = types2.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types$1.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types2.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
        this.exprAllowed = true;
      };
      types2.dollarBraceL.updateContext = function() {
        this.context.push(types$1.b_tmpl);
        this.exprAllowed = true;
      };
      types2.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types2._if || prevType === types2._for || prevType === types2._with || prevType === types2._while;
        this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
        this.exprAllowed = true;
      };
      types2.incDec.updateContext = function() {
      };
      types2._function.updateContext = types2._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types2._else && !(prevType === types2.semi && this.curContext() !== types$1.p_stat) && !(prevType === types2._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types2.colon || prevType === types2.braceL) && this.curContext() === types$1.b_stat)) {
          this.context.push(types$1.f_expr);
        } else {
          this.context.push(types$1.f_stat);
        }
        this.exprAllowed = false;
      };
      types2.backQuote.updateContext = function() {
        if (this.curContext() === types$1.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types$1.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types2.star.updateContext = function(prevType) {
        if (prevType === types2._function) {
          var index2 = this.context.length - 1;
          if (this.context[index2] === types$1.f_expr) {
            this.context[index2] = types$1.f_expr_gen;
          } else {
            this.context[index2] = types$1.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types2.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types2.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion) {
        var d2 = data[ecmaVersion] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
          }
        };
        d2.nonBinary.Script_Extensions = d2.nonBinary.Script;
        d2.nonBinary.gc = d2.nonBinary.General_Category;
        d2.nonBinary.sc = d2.nonBinary.Script;
        d2.nonBinary.scx = d2.nonBinary.Script_Extensions;
      }
      buildUnicodeData(9);
      buildUnicodeData(10);
      buildUnicodeData(11);
      buildUnicodeData(12);
      var pp$8 = Parser.prototype;
      var RegExpValidationState = function RegExpValidationState2(parser2) {
        this.parser = parser2;
        this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "");
        this.unicodeProperties = data[parser2.options.ecmaVersion >= 12 ? 12 : parser2.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern2, flags) {
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern2 + "";
        this.flags = flags;
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s2 = this.source;
        var l = s2.length;
        if (i2 >= l) {
          return -1;
        }
        var c2 = s2.charCodeAt(i2);
        if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l) {
          return c2;
        }
        var next = s2.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s2 = this.source;
        var l = s2.length;
        if (i2 >= l) {
          return l;
        }
        var c2 = s2.charCodeAt(i2), next;
        if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l || (next = s2.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
          return i2 + 1;
        }
        return i2 + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0)
          forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0)
          forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      function codePointToString(ch) {
        if (ch <= 65535) {
          return String.fromCharCode(ch);
        }
        ch -= 65536;
        return String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320);
      }
      pp$8.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        for (var i2 = 0; i2 < flags.length; i2++) {
          var flag = flags.charAt(i2);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i2 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
        }
      };
      pp$8.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$8.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(41)) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(93) || state.eat(125)) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
          var name = list2[i2];
          if (state.groupNames.indexOf(name) === -1) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$8.regexp_disjunction = function(state) {
        this.regexp_alternative(state);
        while (state.eat(124)) {
          this.regexp_alternative(state);
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(123)) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$8.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$8.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(94) || state.eat(36)) {
          return true;
        }
        if (state.eat(92)) {
          if (state.eat(66) || state.eat(98)) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(40) && state.eat(63)) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(60);
          }
          if (state.eat(61) || state.eat(33)) {
            this.regexp_disjunction(state);
            if (!state.eat(41)) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$8.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0)
          noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(63);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$8.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(123)) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(125)) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(40)) {
          if (state.eat(63) && state.eat(58)) {
            this.regexp_disjunction(state);
            if (state.eat(41)) {
              return true;
            }
            state.raise("Unterminated group");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatCapturingGroup = function(state) {
        if (state.eat(40)) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$8.regexp_eatExtendedAtom = function(state) {
        return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$8.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$8.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$8.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_groupSpecifier = function(state) {
        if (state.eat(63)) {
          if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
              state.raise("Duplicate capture group name");
            }
            state.groupNames.push(state.lastStringValue);
            return;
          }
          state.raise("Invalid group");
        }
      };
      pp$8.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(60)) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$8.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$8.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$8.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$8.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$8.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n2 = state.lastIntValue;
          if (state.switchU) {
            if (n2 > state.maxBackReference) {
              state.maxBackReference = n2;
            }
            return true;
          }
          if (n2 <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatKGroupName = function(state) {
        if (state.eat(107)) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$8.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$8.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(99)) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0)
          forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(117)) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$8.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(47)) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return true;
        }
        if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
            return true;
          }
          state.raise("Invalid property name");
        }
        return false;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value2 = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value2);
            return true;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
          return true;
        }
        return false;
      };
      pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value2) {
        if (!has(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value2)) {
          state.raise("Invalid property value");
        }
      };
      pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (!state.unicodeProperties.binary.test(nameOrValue)) {
          state.raise("Invalid property name");
        }
      };
      pp$8.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$8.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$8.regexp_eatCharacterClass = function(state) {
        if (state.eat(91)) {
          state.eat(94);
          this.regexp_classRanges(state);
          if (state.eat(93)) {
            return true;
          }
          state.raise("Unterminated character class");
        }
        return false;
      };
      pp$8.regexp_classRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(45) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$8.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(98)) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(45)) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(99)) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$8.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(120)) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$8.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$8.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$8.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token2(p2) {
        this.type = p2.type;
        this.value = p2.value;
        this.start = p2.start;
        this.end = p2.end;
        if (p2.options.locations) {
          this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
        }
        if (p2.options.ranges) {
          this.range = [p2.start, p2.end];
        }
      };
      var pp$9 = Parser.prototype;
      pp$9.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp$9.getToken = function() {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp$9[Symbol.iterator] = function() {
          var this$1 = this;
          return {
            next: function() {
              var token = this$1.getToken();
              return {
                done: token.type === types2.eof,
                value: token
              };
            }
          };
        };
      }
      pp$9.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$9.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types2.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp$9.readToken = function(code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp$9.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp$9.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          lineBreakG.lastIndex = start;
          var match;
          while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
            ++this.curLine;
            this.lineStart = match.index + match[0].length;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp$9.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp$9.skipSpace = function() {
        loop:
          while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.pos + 1) === 10) {
                  ++this.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.pos;
                if (this.options.locations) {
                  ++this.curLine;
                  this.lineStart = this.pos;
                }
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break loop;
                }
                break;
              default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                  ++this.pos;
                } else {
                  break loop;
                }
            }
          }
      };
      pp$9.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp$9.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types2.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types2.dot);
        }
      };
      pp$9.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types2.assign, 2);
        }
        return this.finishOp(types2.slash, 1);
      };
      pp$9.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types2.star : types2.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types2.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types2.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp$9.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types2.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types2.logicalOR : types2.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types2.assign, 2);
        }
        return this.finishOp(code === 124 ? types2.bitwiseOR : types2.bitwiseAND, 1);
      };
      pp$9.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types2.assign, 2);
        }
        return this.finishOp(types2.bitwiseXOR, 1);
      };
      pp$9.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types2.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types2.assign, 2);
        }
        return this.finishOp(types2.plusMin, 1);
      };
      pp$9.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types2.assign, size + 1);
          }
          return this.finishOp(types2.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types2.relational, size);
      };
      pp$9.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types2.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types2.arrow);
        }
        return this.finishOp(code === 61 ? types2.eq : types2.prefix, 1);
      };
      pp$9.readToken_question = function() {
        var ecmaVersion = this.options.ecmaVersion;
        if (ecmaVersion >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types2.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types2.assign, 3);
              }
            }
            return this.finishOp(types2.coalesce, 2);
          }
        }
        return this.finishOp(types2.question, 1);
      };
      pp$9.readToken_numberSign = function() {
        var ecmaVersion = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart(code, true) || code === 92) {
            return this.finishToken(types2.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
      };
      pp$9.getTokenFromCode = function(code) {
        switch (code) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++this.pos;
            return this.finishToken(types2.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types2.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types2.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types2.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types2.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types2.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types2.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types2.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types2.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types2.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types2.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
      };
      pp$9.finishOp = function(type, size) {
        var str2 = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str2);
      };
      pp$9.readRegexp = function() {
        var escaped4, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped4) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped4 = ch === "\\";
          } else {
            escaped4 = false;
          }
          ++this.pos;
        }
        var pattern2 = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern2, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value2 = null;
        try {
          value2 = new RegExp(pattern2, flags);
        } catch (e) {
        }
        return this.finishToken(types2.regexp, { pattern: pattern2, flags, value: value2 });
      };
      pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i2 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str2, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str2, 8);
        }
        return parseFloat(str2.replace(/_/g, ""));
      }
      function stringToBigInt(str2) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str2.replace(/_/g, ""));
      }
      pp$9.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types2.num, val);
      };
      pp$9.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types2.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types2.num, val);
      };
      pp$9.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      function codePointToString$1(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      pp$9.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else {
            if (isNewLine(ch, this.options.ecmaVersion >= 10)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types2.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp$9.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp$9.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp$9.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types2.template || this.type === types2.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types2.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types2.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types2.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp$9.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            case "`":
              return this.finishToken(types2.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp$9.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return codePointToString$1(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(codePos, "Invalid escape sequence in template string");
              return null;
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp$9.readHexChar = function(len) {
        var codePos = this.pos;
        var n2 = this.readInt(16, len);
        if (n2 === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n2;
      };
      pp$9.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString$1(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp$9.readWord = function() {
        var word = this.readWord1();
        var type = types2.name;
        if (this.keywords.test(word)) {
          type = keywords$1[word];
        }
        return this.finishToken(type, word);
      };
      var version = "8.4.1";
      Parser.acorn = {
        Parser,
        version,
        defaultOptions,
        Position,
        SourceLocation,
        getLineInfo,
        Node,
        TokenType,
        tokTypes: types2,
        keywordTypes: keywords$1,
        TokContext,
        tokContexts: types$1,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse2(input, options3) {
        return Parser.parse(input, options3);
      }
      function parseExpressionAt(input, pos, options3) {
        return Parser.parseExpressionAt(input, pos, options3);
      }
      class WalkerBase {
        constructor() {
          this.should_skip = false;
          this.should_remove = false;
          this.replacement = null;
          this.context = {
            skip: () => this.should_skip = true,
            remove: () => this.should_remove = true,
            replace: (node2) => this.replacement = node2
          };
        }
        replace(parent, prop, index2, node2) {
          if (parent) {
            if (index2 !== null) {
              parent[prop][index2] = node2;
            } else {
              parent[prop] = node2;
            }
          }
        }
        remove(parent, prop, index2) {
          if (parent) {
            if (index2 !== null) {
              parent[prop].splice(index2, 1);
            } else {
              delete parent[prop];
            }
          }
        }
      }
      class SyncWalker extends WalkerBase {
        constructor(enter, leave) {
          super();
          this.enter = enter;
          this.leave = leave;
        }
        visit(node2, parent, prop, index2) {
          if (node2) {
            if (this.enter) {
              const _should_skip = this.should_skip;
              const _should_remove = this.should_remove;
              const _replacement = this.replacement;
              this.should_skip = false;
              this.should_remove = false;
              this.replacement = null;
              this.enter.call(this.context, node2, parent, prop, index2);
              if (this.replacement) {
                node2 = this.replacement;
                this.replace(parent, prop, index2, node2);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index2);
              }
              const skipped = this.should_skip;
              const removed = this.should_remove;
              this.should_skip = _should_skip;
              this.should_remove = _should_remove;
              this.replacement = _replacement;
              if (skipped)
                return node2;
              if (removed)
                return null;
            }
            for (const key in node2) {
              const value2 = node2[key];
              if (typeof value2 !== "object") {
                continue;
              } else if (Array.isArray(value2)) {
                for (let i2 = 0; i2 < value2.length; i2 += 1) {
                  if (value2[i2] !== null && typeof value2[i2].type === "string") {
                    if (!this.visit(value2[i2], node2, key, i2)) {
                      i2--;
                    }
                  }
                }
              } else if (value2 !== null && typeof value2.type === "string") {
                this.visit(value2, node2, key, null);
              }
            }
            if (this.leave) {
              const _replacement = this.replacement;
              const _should_remove = this.should_remove;
              this.replacement = null;
              this.should_remove = false;
              this.leave.call(this.context, node2, parent, prop, index2);
              if (this.replacement) {
                node2 = this.replacement;
                this.replace(parent, prop, index2, node2);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index2);
              }
              const removed = this.should_remove;
              this.replacement = _replacement;
              this.should_remove = _should_remove;
              if (removed)
                return null;
            }
          }
          return node2;
        }
      }
      function walk(ast, { enter, leave }) {
        const instance = new SyncWalker(enter, leave);
        return instance.visit(ast, null);
      }
      const id = Math.round(Math.random() * 1e20).toString(36);
      const re = new RegExp(`_${id}_(?:(\\d+)|(AT)|(HASH))_(\\w+)?`, "g");
      const get_comment_handlers = (comments, raw) => ({
        onComment: (block, value2, start, end) => {
          if (block && /\n/.test(value2)) {
            let a = start;
            while (a > 0 && raw[a - 1] !== "\n")
              a -= 1;
            let b2 = a;
            while (/[ \t]/.test(raw[b2]))
              b2 += 1;
            const indentation = raw.slice(a, b2);
            value2 = value2.replace(new RegExp(`^${indentation}`, "gm"), "");
          }
          comments.push({ type: block ? "Block" : "Line", value: value2, start, end });
        },
        enter(node2) {
          let comment;
          while (comments[0] && comments[0].start < node2.start) {
            comment = comments.shift();
            comment.value = comment.value.replace(re, (match, id2, at, hash3, value2) => {
              if (hash3)
                return `#${value2}`;
              if (at)
                return `@${value2}`;
              return match;
            });
            const next = comments[0] || node2;
            comment.has_trailing_newline = comment.type === "Line" || /\n/.test(raw.slice(comment.end, next.start));
            (node2.leadingComments || (node2.leadingComments = [])).push(comment);
          }
        },
        leave(node2) {
          if (comments[0]) {
            const slice = raw.slice(node2.end, comments[0].start);
            if (/^[,) \t]*$/.test(slice)) {
              node2.trailingComments = [comments.shift()];
            }
          }
        }
      });
      function is_reference(node2, parent) {
        if (node2.type === "MemberExpression") {
          return !node2.computed && is_reference(node2.object, node2);
        }
        if (node2.type === "Identifier") {
          if (!parent)
            return true;
          switch (parent.type) {
            case "MemberExpression":
              return parent.computed || node2 === parent.object;
            case "MethodDefinition":
              return parent.computed;
            case "PropertyDefinition":
              return parent.computed || node2 === parent.value;
            case "Property":
              return parent.computed || node2 === parent.value;
            case "ExportSpecifier":
            case "ImportSpecifier":
              return node2 === parent.local;
            case "LabeledStatement":
            case "BreakStatement":
            case "ContinueStatement":
              return false;
            default:
              return true;
          }
        }
        return false;
      }
      function analyze(expression2) {
        const map = new WeakMap();
        const globals2 = new Map();
        const scope2 = new Scope$1(null, false);
        const references = [];
        let current_scope = scope2;
        walk(expression2, {
          enter(node2, parent) {
            switch (node2.type) {
              case "Identifier":
                if (is_reference(node2, parent)) {
                  references.push([current_scope, node2]);
                }
                break;
              case "ImportDeclaration":
                node2.specifiers.forEach((specifier) => {
                  current_scope.declarations.set(specifier.local.name, specifier);
                });
                break;
              case "FunctionExpression":
              case "FunctionDeclaration":
              case "ArrowFunctionExpression":
                if (node2.type === "FunctionDeclaration") {
                  if (node2.id) {
                    current_scope.declarations.set(node2.id.name, node2);
                  }
                  map.set(node2, current_scope = new Scope$1(current_scope, false));
                } else {
                  map.set(node2, current_scope = new Scope$1(current_scope, false));
                  if (node2.type === "FunctionExpression" && node2.id) {
                    current_scope.declarations.set(node2.id.name, node2);
                  }
                }
                node2.params.forEach((param) => {
                  extract_names(param).forEach((name) => {
                    current_scope.declarations.set(name, node2);
                  });
                });
                break;
              case "ForStatement":
              case "ForInStatement":
              case "ForOfStatement":
                map.set(node2, current_scope = new Scope$1(current_scope, true));
                break;
              case "BlockStatement":
                map.set(node2, current_scope = new Scope$1(current_scope, true));
                break;
              case "ClassDeclaration":
              case "VariableDeclaration":
                current_scope.add_declaration(node2);
                break;
              case "CatchClause":
                map.set(node2, current_scope = new Scope$1(current_scope, true));
                if (node2.param) {
                  extract_names(node2.param).forEach((name) => {
                    current_scope.declarations.set(name, node2.param);
                  });
                }
                break;
            }
          },
          leave(node2) {
            if (map.has(node2)) {
              current_scope = current_scope.parent;
            }
          }
        });
        for (let i2 = references.length - 1; i2 >= 0; --i2) {
          const [scope3, reference] = references[i2];
          if (!scope3.references.has(reference.name)) {
            add_reference(scope3, reference.name);
          }
          if (!scope3.find_owner(reference.name)) {
            globals2.set(reference.name, reference);
          }
        }
        return { map, scope: scope2, globals: globals2 };
      }
      function add_reference(scope2, name) {
        scope2.references.add(name);
        if (scope2.parent)
          add_reference(scope2.parent, name);
      }
      class Scope$1 {
        constructor(parent, block) {
          this.parent = parent;
          this.block = block;
          this.declarations = new Map();
          this.initialised_declarations = new Set();
          this.references = new Set();
        }
        add_declaration(node2) {
          if (node2.type === "VariableDeclaration") {
            if (node2.kind === "var" && this.block && this.parent) {
              this.parent.add_declaration(node2);
            } else {
              const handle_declarator = (declarator) => {
                extract_names(declarator.id).forEach((name) => {
                  this.declarations.set(name, node2);
                  if (declarator.init)
                    this.initialised_declarations.add(name);
                });
              };
              node2.declarations.forEach(handle_declarator);
            }
          } else if (node2.id) {
            this.declarations.set(node2.id.name, node2);
          }
        }
        find_owner(name) {
          if (this.declarations.has(name))
            return this;
          return this.parent && this.parent.find_owner(name);
        }
        has(name) {
          return this.declarations.has(name) || !!this.parent && this.parent.has(name);
        }
      }
      function extract_names(param) {
        return extract_identifiers(param).map((node2) => node2.name);
      }
      function extract_identifiers(param, nodes = []) {
        switch (param.type) {
          case "Identifier":
            nodes.push(param);
            break;
          case "MemberExpression":
            let object = param;
            while (object.type === "MemberExpression") {
              object = object.object;
            }
            nodes.push(object);
            break;
          case "ObjectPattern":
            const handle_prop = (prop) => {
              if (prop.type === "RestElement") {
                extract_identifiers(prop.argument, nodes);
              } else {
                extract_identifiers(prop.value, nodes);
              }
            };
            param.properties.forEach(handle_prop);
            break;
          case "ArrayPattern":
            const handle_element = (element) => {
              if (element)
                extract_identifiers(element, nodes);
            };
            param.elements.forEach(handle_element);
            break;
          case "RestElement":
            extract_identifiers(param.argument, nodes);
            break;
          case "AssignmentPattern":
            extract_identifiers(param.left, nodes);
            break;
        }
        return nodes;
      }
      function handle(node2, state) {
        const handler2 = handlers[node2.type];
        if (!handler2) {
          throw new Error(`Not implemented ${node2.type}`);
        }
        const result = handler2(node2, state);
        if (node2.leadingComments) {
          result.unshift(c(node2.leadingComments.map((comment) => comment.type === "Block" ? `/*${comment.value}*/${comment.has_trailing_newline ? `
${state.indent}` : ` `}` : `//${comment.value}${comment.has_trailing_newline ? `
${state.indent}` : ` `}`).join(``)));
        }
        if (node2.trailingComments) {
          state.comments.push(node2.trailingComments[0]);
        }
        return result;
      }
      function c(content, node2) {
        return {
          content,
          loc: node2 && node2.loc,
          has_newline: /\n/.test(content)
        };
      }
      const OPERATOR_PRECEDENCE = {
        "||": 2,
        "&&": 3,
        "??": 4,
        "|": 5,
        "^": 6,
        "&": 7,
        "==": 8,
        "!=": 8,
        "===": 8,
        "!==": 8,
        "<": 9,
        ">": 9,
        "<=": 9,
        ">=": 9,
        in: 9,
        instanceof: 9,
        "<<": 10,
        ">>": 10,
        ">>>": 10,
        "+": 11,
        "-": 11,
        "*": 12,
        "%": 12,
        "/": 12,
        "**": 13
      };
      const EXPRESSIONS_PRECEDENCE = {
        ArrayExpression: 20,
        TaggedTemplateExpression: 20,
        ThisExpression: 20,
        Identifier: 20,
        Literal: 18,
        TemplateLiteral: 20,
        Super: 20,
        SequenceExpression: 20,
        MemberExpression: 19,
        CallExpression: 19,
        NewExpression: 19,
        AwaitExpression: 17,
        ClassExpression: 17,
        FunctionExpression: 17,
        ObjectExpression: 17,
        UpdateExpression: 16,
        UnaryExpression: 15,
        BinaryExpression: 14,
        LogicalExpression: 13,
        ConditionalExpression: 4,
        ArrowFunctionExpression: 3,
        AssignmentExpression: 3,
        YieldExpression: 2,
        RestElement: 1
      };
      function needs_parens(node2, parent, is_right) {
        if (node2.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node2.operator !== "??" || parent.operator !== "??" && node2.operator === "??")) {
          return true;
        }
        const precedence = EXPRESSIONS_PRECEDENCE[node2.type];
        const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
        if (precedence !== parent_precedence) {
          return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
        }
        if (precedence !== 13 && precedence !== 14) {
          return false;
        }
        if (node2.operator === "**" && parent.operator === "**") {
          return !is_right;
        }
        if (is_right) {
          return OPERATOR_PRECEDENCE[node2.operator] <= OPERATOR_PRECEDENCE[parent.operator];
        }
        return OPERATOR_PRECEDENCE[node2.operator] < OPERATOR_PRECEDENCE[parent.operator];
      }
      function has_call_expression(node2) {
        while (node2) {
          if (node2.type[0] === "CallExpression") {
            return true;
          } else if (node2.type === "MemberExpression") {
            node2 = node2.object;
          } else {
            return false;
          }
        }
      }
      const has_newline = (chunks) => {
        for (let i2 = 0; i2 < chunks.length; i2 += 1) {
          if (chunks[i2].has_newline)
            return true;
        }
        return false;
      };
      const get_length = (chunks) => {
        let total = 0;
        for (let i2 = 0; i2 < chunks.length; i2 += 1) {
          total += chunks[i2].content.length;
        }
        return total;
      };
      const sum = (a, b2) => a + b2;
      const join = (nodes, separator) => {
        if (nodes.length === 0)
          return [];
        const joined = [...nodes[0]];
        for (let i2 = 1; i2 < nodes.length; i2 += 1) {
          joined.push(separator, ...nodes[i2]);
        }
        return joined;
      };
      const scoped = (fn) => {
        const scoped_fn = (node2, state) => {
          return fn(node2, {
            ...state,
            scope: state.scope_map.get(node2)
          });
        };
        return scoped_fn;
      };
      const deconflict = (name, names2) => {
        const original = name;
        let i2 = 1;
        while (names2.has(name)) {
          name = `${original}$${i2++}`;
        }
        return name;
      };
      const handle_body = (nodes, state) => {
        const chunks = [];
        const body = nodes.map((statement) => {
          const chunks2 = handle(statement, {
            ...state,
            indent: state.indent
          });
          let add_newline = false;
          while (state.comments.length) {
            const comment = state.comments.shift();
            const prefix = add_newline ? `
${state.indent}` : ` `;
            chunks2.push(c(comment.type === "Block" ? `${prefix}/*${comment.value}*/` : `${prefix}//${comment.value}`));
            add_newline = comment.type === "Line";
          }
          return chunks2;
        });
        let needed_padding = false;
        for (let i2 = 0; i2 < body.length; i2 += 1) {
          const needs_padding = has_newline(body[i2]);
          if (i2 > 0) {
            chunks.push(c(needs_padding || needed_padding ? `

${state.indent}` : `
${state.indent}`));
          }
          chunks.push(...body[i2]);
          needed_padding = needs_padding;
        }
        return chunks;
      };
      const handle_var_declaration = (node2, state) => {
        const chunks = [c(`${node2.kind} `)];
        const declarators = node2.declarations.map((d2) => handle(d2, {
          ...state,
          indent: state.indent + (node2.declarations.length === 1 ? "" : "	")
        }));
        const multiple_lines = declarators.some(has_newline) || declarators.map(get_length).reduce(sum, 0) + (state.indent.length + declarators.length - 1) * 2 > 80;
        const separator = c(multiple_lines ? `,
${state.indent}	` : ", ");
        if (multiple_lines) {
          chunks.push(...join(declarators, separator));
        } else {
          chunks.push(...join(declarators, separator));
        }
        return chunks;
      };
      const handlers = {
        Program(node2, state) {
          return handle_body(node2.body, state);
        },
        BlockStatement: scoped((node2, state) => {
          return [
            c(`{
${state.indent}	`),
            ...handle_body(node2.body, { ...state, indent: state.indent + "	" }),
            c(`
${state.indent}}`)
          ];
        }),
        EmptyStatement(node2, state) {
          return [];
        },
        ParenthesizedExpression(node2, state) {
          return handle(node2.expression, state);
        },
        ExpressionStatement(node2, state) {
          if (node2.expression.type === "AssignmentExpression" && node2.expression.left.type === "ObjectPattern") {
            return [
              c("("),
              ...handle(node2.expression, state),
              c(");")
            ];
          }
          return [
            ...handle(node2.expression, state),
            c(";")
          ];
        },
        IfStatement(node2, state) {
          const chunks = [
            c("if ("),
            ...handle(node2.test, state),
            c(") "),
            ...handle(node2.consequent, state)
          ];
          if (node2.alternate) {
            chunks.push(c(" else "), ...handle(node2.alternate, state));
          }
          return chunks;
        },
        LabeledStatement(node2, state) {
          return [
            ...handle(node2.label, state),
            c(": "),
            ...handle(node2.body, state)
          ];
        },
        BreakStatement(node2, state) {
          return node2.label ? [c("break "), ...handle(node2.label, state), c(";")] : [c("break;")];
        },
        ContinueStatement(node2, state) {
          return node2.label ? [c("continue "), ...handle(node2.label, state), c(";")] : [c("continue;")];
        },
        WithStatement(node2, state) {
          return [
            c("with ("),
            ...handle(node2.object, state),
            c(") "),
            ...handle(node2.body, state)
          ];
        },
        SwitchStatement(node2, state) {
          const chunks = [
            c("switch ("),
            ...handle(node2.discriminant, state),
            c(") {")
          ];
          node2.cases.forEach((block) => {
            if (block.test) {
              chunks.push(c(`
${state.indent}	case `), ...handle(block.test, { ...state, indent: `${state.indent}	` }), c(":"));
            } else {
              chunks.push(c(`
${state.indent}	default:`));
            }
            block.consequent.forEach((statement) => {
              chunks.push(c(`
${state.indent}		`), ...handle(statement, { ...state, indent: `${state.indent}		` }));
            });
          });
          chunks.push(c(`
${state.indent}}`));
          return chunks;
        },
        ReturnStatement(node2, state) {
          if (node2.argument) {
            return [
              c("return "),
              ...handle(node2.argument, state),
              c(";")
            ];
          } else {
            return [c("return;")];
          }
        },
        ThrowStatement(node2, state) {
          return [
            c("throw "),
            ...handle(node2.argument, state),
            c(";")
          ];
        },
        TryStatement(node2, state) {
          const chunks = [
            c("try "),
            ...handle(node2.block, state)
          ];
          if (node2.handler) {
            if (node2.handler.param) {
              chunks.push(c(" catch("), ...handle(node2.handler.param, state), c(") "));
            } else {
              chunks.push(c(" catch "));
            }
            chunks.push(...handle(node2.handler.body, state));
          }
          if (node2.finalizer) {
            chunks.push(c(" finally "), ...handle(node2.finalizer, state));
          }
          return chunks;
        },
        WhileStatement(node2, state) {
          return [
            c("while ("),
            ...handle(node2.test, state),
            c(") "),
            ...handle(node2.body, state)
          ];
        },
        DoWhileStatement(node2, state) {
          return [
            c("do "),
            ...handle(node2.body, state),
            c(" while ("),
            ...handle(node2.test, state),
            c(");")
          ];
        },
        ForStatement: scoped((node2, state) => {
          const chunks = [c("for (")];
          if (node2.init) {
            if (node2.init.type === "VariableDeclaration") {
              chunks.push(...handle_var_declaration(node2.init, state));
            } else {
              chunks.push(...handle(node2.init, state));
            }
          }
          chunks.push(c("; "));
          if (node2.test)
            chunks.push(...handle(node2.test, state));
          chunks.push(c("; "));
          if (node2.update)
            chunks.push(...handle(node2.update, state));
          chunks.push(c(") "), ...handle(node2.body, state));
          return chunks;
        }),
        ForInStatement: scoped((node2, state) => {
          const chunks = [
            c(`for ${node2.await ? "await " : ""}(`)
          ];
          if (node2.left.type === "VariableDeclaration") {
            chunks.push(...handle_var_declaration(node2.left, state));
          } else {
            chunks.push(...handle(node2.left, state));
          }
          chunks.push(c(node2.type === "ForInStatement" ? ` in ` : ` of `), ...handle(node2.right, state), c(") "), ...handle(node2.body, state));
          return chunks;
        }),
        DebuggerStatement(node2, state) {
          return [c("debugger", node2), c(";")];
        },
        FunctionDeclaration: scoped((node2, state) => {
          const chunks = [];
          if (node2.async)
            chunks.push(c("async "));
          chunks.push(c(node2.generator ? "function* " : "function "));
          if (node2.id)
            chunks.push(...handle(node2.id, state));
          chunks.push(c("("));
          const params = node2.params.map((p2) => handle(p2, {
            ...state,
            indent: state.indent + "	"
          }));
          const multiple_lines = params.some(has_newline) || params.map(get_length).reduce(sum, 0) + (state.indent.length + params.length - 1) * 2 > 80;
          const separator = c(multiple_lines ? `,
${state.indent}` : ", ");
          if (multiple_lines) {
            chunks.push(c(`
${state.indent}	`), ...join(params, separator), c(`
${state.indent}`));
          } else {
            chunks.push(...join(params, separator));
          }
          chunks.push(c(") "), ...handle(node2.body, state));
          return chunks;
        }),
        VariableDeclaration(node2, state) {
          return handle_var_declaration(node2, state).concat(c(";"));
        },
        VariableDeclarator(node2, state) {
          if (node2.init) {
            return [
              ...handle(node2.id, state),
              c(" = "),
              ...handle(node2.init, state)
            ];
          } else {
            return handle(node2.id, state);
          }
        },
        ClassDeclaration(node2, state) {
          const chunks = [c("class ")];
          if (node2.id)
            chunks.push(...handle(node2.id, state), c(" "));
          if (node2.superClass) {
            chunks.push(c("extends "), ...handle(node2.superClass, state), c(" "));
          }
          chunks.push(...handle(node2.body, state));
          return chunks;
        },
        ImportDeclaration(node2, state) {
          const chunks = [c("import ")];
          const { length } = node2.specifiers;
          const source = handle(node2.source, state);
          if (length > 0) {
            let i2 = 0;
            while (i2 < length) {
              if (i2 > 0) {
                chunks.push(c(", "));
              }
              const specifier = node2.specifiers[i2];
              if (specifier.type === "ImportDefaultSpecifier") {
                chunks.push(c(specifier.local.name, specifier));
                i2 += 1;
              } else if (specifier.type === "ImportNamespaceSpecifier") {
                chunks.push(c("* as " + specifier.local.name, specifier));
                i2 += 1;
              } else {
                break;
              }
            }
            if (i2 < length) {
              const specifiers = node2.specifiers.slice(i2).map((specifier) => {
                const name = handle(specifier.imported, state)[0];
                const as = handle(specifier.local, state)[0];
                if (name.content === as.content) {
                  return [as];
                }
                return [name, c(" as "), as];
              });
              const width = get_length(chunks) + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length + 6 + get_length(source);
              if (width > 80) {
                chunks.push(c(`{
	`), ...join(specifiers, c(",\n	")), c("\n}"));
              } else {
                chunks.push(c(`{ `), ...join(specifiers, c(", ")), c(" }"));
              }
            }
            chunks.push(c(" from "));
          }
          chunks.push(...source, c(";"));
          return chunks;
        },
        ImportExpression(node2, state) {
          return [c("import("), ...handle(node2.source, state), c(")")];
        },
        ExportDefaultDeclaration(node2, state) {
          const chunks = [
            c(`export default `),
            ...handle(node2.declaration, state)
          ];
          if (node2.declaration.type !== "FunctionDeclaration") {
            chunks.push(c(";"));
          }
          return chunks;
        },
        ExportNamedDeclaration(node2, state) {
          const chunks = [c("export ")];
          if (node2.declaration) {
            chunks.push(...handle(node2.declaration, state));
          } else {
            const specifiers = node2.specifiers.map((specifier) => {
              const name = handle(specifier.local, state)[0];
              const as = handle(specifier.exported, state)[0];
              if (name.content === as.content) {
                return [name];
              }
              return [name, c(" as "), as];
            });
            const width = 7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;
            if (width > 80) {
              chunks.push(c("{\n	"), ...join(specifiers, c(",\n	")), c("\n}"));
            } else {
              chunks.push(c("{ "), ...join(specifiers, c(", ")), c(" }"));
            }
            if (node2.source) {
              chunks.push(c(" from "), ...handle(node2.source, state));
            }
          }
          chunks.push(c(";"));
          return chunks;
        },
        ExportAllDeclaration(node2, state) {
          return [
            c(`export * from `),
            ...handle(node2.source, state),
            c(`;`)
          ];
        },
        MethodDefinition(node2, state) {
          const chunks = [];
          if (node2.static) {
            chunks.push(c("static "));
          }
          if (node2.kind === "get" || node2.kind === "set") {
            chunks.push(c(node2.kind + " "));
          }
          if (node2.value.async) {
            chunks.push(c("async "));
          }
          if (node2.value.generator) {
            chunks.push(c("*"));
          }
          if (node2.computed) {
            chunks.push(c("["), ...handle(node2.key, state), c("]"));
          } else {
            chunks.push(...handle(node2.key, state));
          }
          chunks.push(c("("));
          const { params } = node2.value;
          for (let i2 = 0; i2 < params.length; i2 += 1) {
            chunks.push(...handle(params[i2], state));
            if (i2 < params.length - 1)
              chunks.push(c(", "));
          }
          chunks.push(c(") "), ...handle(node2.value.body, state));
          return chunks;
        },
        ArrowFunctionExpression: scoped((node2, state) => {
          const chunks = [];
          if (node2.async)
            chunks.push(c("async "));
          if (node2.params.length === 1 && node2.params[0].type === "Identifier") {
            chunks.push(...handle(node2.params[0], state));
          } else {
            const params = node2.params.map((param) => handle(param, {
              ...state,
              indent: state.indent + "	"
            }));
            chunks.push(c("("), ...join(params, c(", ")), c(")"));
          }
          chunks.push(c(" => "));
          if (node2.body.type === "ObjectExpression") {
            chunks.push(c("("), ...handle(node2.body, state), c(")"));
          } else {
            chunks.push(...handle(node2.body, state));
          }
          return chunks;
        }),
        ThisExpression(node2, state) {
          return [c("this", node2)];
        },
        Super(node2, state) {
          return [c("super", node2)];
        },
        RestElement(node2, state) {
          return [c("..."), ...handle(node2.argument, state)];
        },
        YieldExpression(node2, state) {
          if (node2.argument) {
            return [c(node2.delegate ? `yield* ` : `yield `), ...handle(node2.argument, state)];
          }
          return [c(node2.delegate ? `yield*` : `yield`)];
        },
        AwaitExpression(node2, state) {
          if (node2.argument) {
            const precedence = EXPRESSIONS_PRECEDENCE[node2.argument.type];
            if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
              return [c("await ("), ...handle(node2.argument, state), c(")")];
            } else {
              return [c("await "), ...handle(node2.argument, state)];
            }
          }
          return [c("await")];
        },
        TemplateLiteral(node2, state) {
          const chunks = [c("`")];
          const { quasis, expressions } = node2;
          for (let i2 = 0; i2 < expressions.length; i2++) {
            chunks.push(c(quasis[i2].value.raw), c("${"), ...handle(expressions[i2], state), c("}"));
          }
          chunks.push(c(quasis[quasis.length - 1].value.raw), c("`"));
          return chunks;
        },
        TaggedTemplateExpression(node2, state) {
          return handle(node2.tag, state).concat(handle(node2.quasi, state));
        },
        ArrayExpression(node2, state) {
          const chunks = [c("[")];
          const elements = [];
          let sparse_commas = [];
          for (let i2 = 0; i2 < node2.elements.length; i2 += 1) {
            const element = node2.elements[i2];
            if (element) {
              elements.push([...sparse_commas, ...handle(element, {
                ...state,
                indent: state.indent + "	"
              })]);
              sparse_commas = [];
            } else {
              sparse_commas.push(c(","));
            }
          }
          const multiple_lines = elements.some(has_newline) || elements.map(get_length).reduce(sum, 0) + (state.indent.length + elements.length - 1) * 2 > 80;
          if (multiple_lines) {
            chunks.push(c(`
${state.indent}	`), ...join(elements, c(`,
${state.indent}	`)), c(`
${state.indent}`), ...sparse_commas);
          } else {
            chunks.push(...join(elements, c(", ")), ...sparse_commas);
          }
          chunks.push(c("]"));
          return chunks;
        },
        ObjectExpression(node2, state) {
          if (node2.properties.length === 0) {
            return [c("{}")];
          }
          let has_inline_comment = false;
          const chunks = [];
          const separator = c(", ");
          node2.properties.forEach((p2, i2) => {
            chunks.push(...handle(p2, {
              ...state,
              indent: state.indent + "	"
            }));
            if (state.comments.length) {
              chunks.push(c(", "));
              while (state.comments.length) {
                const comment = state.comments.shift();
                chunks.push(c(comment.type === "Block" ? `/*${comment.value}*/
${state.indent}	` : `//${comment.value}
${state.indent}	`));
                if (comment.type === "Line") {
                  has_inline_comment = true;
                }
              }
            } else {
              if (i2 < node2.properties.length - 1) {
                chunks.push(separator);
              }
            }
          });
          const multiple_lines = has_inline_comment || has_newline(chunks) || get_length(chunks) > 40;
          if (multiple_lines) {
            separator.content = `,
${state.indent}	`;
          }
          return [
            c(multiple_lines ? `{
${state.indent}	` : `{ `),
            ...chunks,
            c(multiple_lines ? `
${state.indent}}` : ` }`)
          ];
        },
        Property(node2, state) {
          const value2 = handle(node2.value, state);
          if (node2.key === node2.value) {
            return value2;
          }
          if (!node2.computed && node2.value.type === "AssignmentPattern" && node2.value.left.type === "Identifier" && node2.value.left.name === node2.key.name) {
            return value2;
          }
          if (!node2.computed && node2.value.type === "Identifier" && (node2.key.type === "Identifier" && node2.key.name === value2[0].content || node2.key.type === "Literal" && node2.key.value === value2[0].content)) {
            return value2;
          }
          const key = handle(node2.key, state);
          if (node2.value.type === "FunctionExpression" && !node2.value.id) {
            state = {
              ...state,
              scope: state.scope_map.get(node2.value)
            };
            const chunks = node2.kind !== "init" ? [c(`${node2.kind} `)] : [];
            if (node2.value.async) {
              chunks.push(c("async "));
            }
            if (node2.value.generator) {
              chunks.push(c("*"));
            }
            chunks.push(...node2.computed ? [c("["), ...key, c("]")] : key, c("("), ...join(node2.value.params.map((param) => handle(param, state)), c(", ")), c(") "), ...handle(node2.value.body, state));
            return chunks;
          }
          if (node2.computed) {
            return [
              c("["),
              ...key,
              c("]: "),
              ...value2
            ];
          }
          return [
            ...key,
            c(": "),
            ...value2
          ];
        },
        ObjectPattern(node2, state) {
          const chunks = [c("{ ")];
          for (let i2 = 0; i2 < node2.properties.length; i2 += 1) {
            chunks.push(...handle(node2.properties[i2], state));
            if (i2 < node2.properties.length - 1)
              chunks.push(c(", "));
          }
          chunks.push(c(" }"));
          return chunks;
        },
        SequenceExpression(node2, state) {
          const expressions = node2.expressions.map((e) => handle(e, state));
          return [
            c("("),
            ...join(expressions, c(", ")),
            c(")")
          ];
        },
        UnaryExpression(node2, state) {
          const chunks = [c(node2.operator)];
          if (node2.operator.length > 1) {
            chunks.push(c(" "));
          }
          if (EXPRESSIONS_PRECEDENCE[node2.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
            chunks.push(c("("), ...handle(node2.argument, state), c(")"));
          } else {
            chunks.push(...handle(node2.argument, state));
          }
          return chunks;
        },
        UpdateExpression(node2, state) {
          return node2.prefix ? [c(node2.operator), ...handle(node2.argument, state)] : [...handle(node2.argument, state), c(node2.operator)];
        },
        AssignmentExpression(node2, state) {
          return [
            ...handle(node2.left, state),
            c(` ${node2.operator || "="} `),
            ...handle(node2.right, state)
          ];
        },
        BinaryExpression(node2, state) {
          const chunks = [];
          if (needs_parens(node2.left, node2, false)) {
            chunks.push(c("("), ...handle(node2.left, state), c(")"));
          } else {
            chunks.push(...handle(node2.left, state));
          }
          chunks.push(c(` ${node2.operator} `));
          if (needs_parens(node2.right, node2, true)) {
            chunks.push(c("("), ...handle(node2.right, state), c(")"));
          } else {
            chunks.push(...handle(node2.right, state));
          }
          return chunks;
        },
        ConditionalExpression(node2, state) {
          const chunks = [];
          if (EXPRESSIONS_PRECEDENCE[node2.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) {
            chunks.push(...handle(node2.test, state));
          } else {
            chunks.push(c("("), ...handle(node2.test, state), c(")"));
          }
          const child_state = { ...state, indent: state.indent + "	" };
          const consequent = handle(node2.consequent, child_state);
          const alternate = handle(node2.alternate, child_state);
          const multiple_lines = has_newline(consequent) || has_newline(alternate) || get_length(chunks) + get_length(consequent) + get_length(alternate) > 50;
          if (multiple_lines) {
            chunks.push(c(`
${state.indent}? `), ...consequent, c(`
${state.indent}: `), ...alternate);
          } else {
            chunks.push(c(` ? `), ...consequent, c(` : `), ...alternate);
          }
          return chunks;
        },
        NewExpression(node2, state) {
          const chunks = [c("new ")];
          if (EXPRESSIONS_PRECEDENCE[node2.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || has_call_expression(node2.callee)) {
            chunks.push(c("("), ...handle(node2.callee, state), c(")"));
          } else {
            chunks.push(...handle(node2.callee, state));
          }
          const args = node2.arguments.map((arg) => handle(arg, {
            ...state,
            indent: state.indent + "	"
          }));
          const separator = args.some(has_newline) ? c(",\n" + state.indent) : c(", ");
          chunks.push(c("("), ...join(args, separator), c(")"));
          return chunks;
        },
        ChainExpression(node2, state) {
          return handle(node2.expression, state);
        },
        CallExpression(node2, state) {
          const chunks = [];
          if (EXPRESSIONS_PRECEDENCE[node2.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression) {
            chunks.push(c("("), ...handle(node2.callee, state), c(")"));
          } else {
            chunks.push(...handle(node2.callee, state));
          }
          if (node2.optional) {
            chunks.push(c("?."));
          }
          const args = node2.arguments.map((arg) => handle(arg, state));
          const multiple_lines = args.slice(0, -1).some(has_newline);
          if (multiple_lines) {
            const args2 = node2.arguments.map((arg) => handle(arg, {
              ...state,
              indent: `${state.indent}	`
            }));
            chunks.push(c(`(
${state.indent}	`), ...join(args2, c(`,
${state.indent}	`)), c(`
${state.indent})`));
          } else {
            chunks.push(c("("), ...join(args, c(", ")), c(")"));
          }
          return chunks;
        },
        MemberExpression(node2, state) {
          const chunks = [];
          if (EXPRESSIONS_PRECEDENCE[node2.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
            chunks.push(c("("), ...handle(node2.object, state), c(")"));
          } else {
            chunks.push(...handle(node2.object, state));
          }
          if (node2.computed) {
            if (node2.optional) {
              chunks.push(c("?."));
            }
            chunks.push(c("["), ...handle(node2.property, state), c("]"));
          } else {
            chunks.push(c(node2.optional ? "?." : "."), ...handle(node2.property, state));
          }
          return chunks;
        },
        MetaProperty(node2, state) {
          return [...handle(node2.meta, state), c("."), ...handle(node2.property, state)];
        },
        Identifier(node2, state) {
          let name = node2.name;
          if (name[0] === "@") {
            name = state.getName(name.slice(1));
          } else if (node2.name[0] === "#") {
            const owner = state.scope.find_owner(node2.name);
            if (!owner) {
              throw new Error(`Could not find owner for node`);
            }
            if (!state.deconflicted.has(owner)) {
              state.deconflicted.set(owner, new Map());
            }
            const deconflict_map = state.deconflicted.get(owner);
            if (!deconflict_map.has(node2.name)) {
              deconflict_map.set(node2.name, deconflict(node2.name.slice(1), owner.references));
            }
            name = deconflict_map.get(node2.name);
          }
          return [c(name, node2)];
        },
        Literal(node2, state) {
          if (typeof node2.value === "string") {
            return [
              c((node2.raw || JSON.stringify(node2.value)).replace(re, (_m, _i, at, hash3, name) => {
                if (at)
                  return "@" + name;
                if (hash3)
                  return "#" + name;
                throw new Error(`this shouldn't happen`);
              }), node2)
            ];
          }
          return [c(node2.raw || String(node2.value), node2)];
        }
      };
      handlers.ForOfStatement = handlers.ForInStatement;
      handlers.FunctionExpression = handlers.FunctionDeclaration;
      handlers.ClassExpression = handlers.ClassDeclaration;
      handlers.ClassBody = handlers.BlockStatement;
      handlers.SpreadElement = handlers.RestElement;
      handlers.ArrayPattern = handlers.ArrayExpression;
      handlers.LogicalExpression = handlers.BinaryExpression;
      handlers.AssignmentPattern = handlers.AssignmentExpression;
      var charToInteger = {};
      var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      for (var i = 0; i < chars2.length; i++) {
        charToInteger[chars2.charCodeAt(i)] = i;
      }
      function decode(mappings) {
        var decoded = [];
        var line = [];
        var segment = [
          0,
          0,
          0,
          0,
          0
        ];
        var j = 0;
        for (var i2 = 0, shift = 0, value2 = 0; i2 < mappings.length; i2++) {
          var c2 = mappings.charCodeAt(i2);
          if (c2 === 44) {
            segmentify(line, segment, j);
            j = 0;
          } else if (c2 === 59) {
            segmentify(line, segment, j);
            j = 0;
            decoded.push(line);
            line = [];
            segment[0] = 0;
          } else {
            var integer = charToInteger[c2];
            if (integer === void 0) {
              throw new Error("Invalid character (" + String.fromCharCode(c2) + ")");
            }
            var hasContinuationBit = integer & 32;
            integer &= 31;
            value2 += integer << shift;
            if (hasContinuationBit) {
              shift += 5;
            } else {
              var shouldNegate = value2 & 1;
              value2 >>>= 1;
              if (shouldNegate) {
                value2 = value2 === 0 ? -2147483648 : -value2;
              }
              segment[j] += value2;
              j++;
              value2 = shift = 0;
            }
          }
        }
        segmentify(line, segment, j);
        decoded.push(line);
        return decoded;
      }
      function segmentify(line, segment, j) {
        if (j === 4)
          line.push([segment[0], segment[1], segment[2], segment[3]]);
        else if (j === 5)
          line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);
        else if (j === 1)
          line.push([segment[0]]);
      }
      function encode(decoded) {
        var sourceFileIndex = 0;
        var sourceCodeLine = 0;
        var sourceCodeColumn = 0;
        var nameIndex = 0;
        var mappings = "";
        for (var i2 = 0; i2 < decoded.length; i2++) {
          var line = decoded[i2];
          if (i2 > 0)
            mappings += ";";
          if (line.length === 0)
            continue;
          var generatedCodeColumn = 0;
          var lineMappings = [];
          for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
            var segment = line_1[_i];
            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
            generatedCodeColumn = segment[0];
            if (segment.length > 1) {
              segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);
              sourceFileIndex = segment[1];
              sourceCodeLine = segment[2];
              sourceCodeColumn = segment[3];
            }
            if (segment.length === 5) {
              segmentMappings += encodeInteger(segment[4] - nameIndex);
              nameIndex = segment[4];
            }
            lineMappings.push(segmentMappings);
          }
          mappings += lineMappings.join(",");
        }
        return mappings;
      }
      function encodeInteger(num) {
        var result = "";
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          var clamped = num & 31;
          num >>>= 5;
          if (num > 0) {
            clamped |= 32;
          }
          result += chars2[clamped];
        } while (num > 0);
        return result;
      }
      let btoa$1 = () => {
        throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
      };
      if (typeof window !== "undefined" && typeof window.btoa === "function") {
        btoa$1 = (str2) => window.btoa(unescape(encodeURIComponent(str2)));
      } else if (typeof Buffer === "function") {
        btoa$1 = (str2) => Buffer.from(str2, "utf-8").toString("base64");
      }
      function print(node2, opts = {}) {
        if (Array.isArray(node2)) {
          return print({
            type: "Program",
            body: node2,
            sourceType: "module"
          }, opts);
        }
        const {
          getName: getName2 = (x2) => {
            throw new Error(`Unhandled sigil @${x2}`);
          }
        } = opts;
        let { map: scope_map, scope: scope2 } = analyze(node2);
        const deconflicted = new WeakMap();
        const chunks = handle(node2, {
          indent: "",
          getName: getName2,
          scope: scope2,
          scope_map,
          deconflicted,
          comments: []
        });
        let code = "";
        let current_column = 0;
        let mappings = [];
        let current_line = [];
        for (let i2 = 0; i2 < chunks.length; i2 += 1) {
          const chunk = chunks[i2];
          code += chunk.content;
          if (chunk.loc) {
            current_line.push([
              current_column,
              0,
              chunk.loc.start.line - 1,
              chunk.loc.start.column
            ]);
          }
          for (let i3 = 0; i3 < chunk.content.length; i3 += 1) {
            if (chunk.content[i3] === "\n") {
              mappings.push(current_line);
              current_line = [];
              current_column = 0;
            } else {
              current_column += 1;
            }
          }
          if (chunk.loc) {
            current_line.push([
              current_column,
              0,
              chunk.loc.end.line - 1,
              chunk.loc.end.column
            ]);
          }
        }
        mappings.push(current_line);
        const map = {
          version: 3,
          names: [],
          sources: [opts.sourceMapSource || null],
          sourcesContent: [opts.sourceMapContent || null],
          mappings: opts.sourceMapEncodeMappings == void 0 || opts.sourceMapEncodeMappings ? encode(mappings) : mappings
        };
        Object.defineProperties(map, {
          toString: {
            enumerable: false,
            value: function toString2() {
              return JSON.stringify(this);
            }
          },
          toUrl: {
            enumerable: false,
            value: function toUrl() {
              return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
            }
          }
        });
        return {
          code,
          map
        };
      }
      const sigils = {
        "@": "AT",
        "#": "HASH"
      };
      const join$1 = (strings) => {
        let str2 = strings[0];
        for (let i2 = 1; i2 < strings.length; i2 += 1) {
          str2 += `_${id}_${i2 - 1}_${strings[i2]}`;
        }
        return str2.replace(/([@#])(\w+)/g, (_m, sigil, name) => `_${id}_${sigils[sigil]}_${name}`);
      };
      const flatten_body = (array, target) => {
        for (let i2 = 0; i2 < array.length; i2 += 1) {
          const statement = array[i2];
          if (Array.isArray(statement)) {
            flatten_body(statement, target);
            continue;
          }
          if (statement.type === "ExpressionStatement") {
            if (statement.expression === EMPTY)
              continue;
            if (Array.isArray(statement.expression)) {
              let node2 = statement.expression[0];
              while (Array.isArray(node2))
                node2 = node2[0];
              if (node2)
                node2.leadingComments = statement.leadingComments;
              flatten_body(statement.expression, target);
              continue;
            }
            if (/(Expression|Literal)$/.test(statement.expression.type)) {
              target.push(statement);
              continue;
            }
            if (statement.leadingComments)
              statement.expression.leadingComments = statement.leadingComments;
            if (statement.trailingComments)
              statement.expression.trailingComments = statement.trailingComments;
            target.push(statement.expression);
            continue;
          }
          target.push(statement);
        }
        return target;
      };
      const flatten_properties = (array, target) => {
        for (let i2 = 0; i2 < array.length; i2 += 1) {
          const property = array[i2];
          if (property.value === EMPTY)
            continue;
          if (property.key === property.value && Array.isArray(property.key)) {
            flatten_properties(property.key, target);
            continue;
          }
          target.push(property);
        }
        return target;
      };
      const flatten = (nodes, target) => {
        for (let i2 = 0; i2 < nodes.length; i2 += 1) {
          const node2 = nodes[i2];
          if (node2 === EMPTY)
            continue;
          if (Array.isArray(node2)) {
            flatten(node2, target);
            continue;
          }
          target.push(node2);
        }
        return target;
      };
      const EMPTY = { type: "Empty" };
      const acorn_opts = (comments, raw) => {
        const { onComment } = get_comment_handlers(comments, raw);
        return {
          ecmaVersion: 2020,
          sourceType: "module",
          allowAwaitOutsideFunction: true,
          allowImportExportEverywhere: true,
          allowReturnOutsideFunction: true,
          onComment
        };
      };
      const inject = (raw, node2, values, comments) => {
        comments.forEach((comment) => {
          comment.value = comment.value.replace(re, (m, i2) => +i2 in values ? values[+i2] : m);
        });
        const { enter, leave } = get_comment_handlers(comments, raw);
        walk(node2, {
          enter,
          leave(node3) {
            if (node3.type === "Identifier") {
              re.lastIndex = 0;
              const match = re.exec(node3.name);
              if (match) {
                if (match[1]) {
                  if (+match[1] in values) {
                    let value2 = values[+match[1]];
                    if (typeof value2 === "string") {
                      value2 = {
                        type: "Identifier",
                        name: value2,
                        leadingComments: node3.leadingComments,
                        trailingComments: node3.trailingComments
                      };
                    } else if (typeof value2 === "number") {
                      value2 = {
                        type: "Literal",
                        value: value2,
                        leadingComments: node3.leadingComments,
                        trailingComments: node3.trailingComments
                      };
                    }
                    this.replace(value2 || EMPTY);
                  }
                } else {
                  node3.name = `${match[2] ? `@` : `#`}${match[4]}`;
                }
              }
            }
            if (node3.type === "Literal") {
              if (typeof node3.value === "string") {
                re.lastIndex = 0;
                const new_value = node3.value.replace(re, (m, i2) => +i2 in values ? values[+i2] : m);
                const has_changed = new_value !== node3.value;
                node3.value = new_value;
                if (has_changed && node3.raw) {
                  node3.raw = `${node3.raw[0]}${JSON.stringify(node3.value).slice(1, -1)}${node3.raw[node3.raw.length - 1]}`;
                }
              }
            }
            if (node3.type === "TemplateElement") {
              re.lastIndex = 0;
              node3.value.raw = node3.value.raw.replace(re, (m, i2) => +i2 in values ? values[+i2] : m);
            }
            if (node3.type === "Program" || node3.type === "BlockStatement") {
              node3.body = flatten_body(node3.body, []);
            }
            if (node3.type === "ObjectExpression" || node3.type === "ObjectPattern") {
              node3.properties = flatten_properties(node3.properties, []);
            }
            if (node3.type === "ArrayExpression" || node3.type === "ArrayPattern") {
              node3.elements = flatten(node3.elements, []);
            }
            if (node3.type === "FunctionExpression" || node3.type === "FunctionDeclaration" || node3.type === "ArrowFunctionExpression") {
              node3.params = flatten(node3.params, []);
            }
            if (node3.type === "CallExpression" || node3.type === "NewExpression") {
              node3.arguments = flatten(node3.arguments, []);
            }
            if (node3.type === "ImportDeclaration" || node3.type === "ExportNamedDeclaration") {
              node3.specifiers = flatten(node3.specifiers, []);
            }
            if (node3.type === "ForStatement") {
              node3.init = node3.init === EMPTY ? null : node3.init;
              node3.test = node3.test === EMPTY ? null : node3.test;
              node3.update = node3.update === EMPTY ? null : node3.update;
            }
            leave(node3);
          }
        });
      };
      function b(strings, ...values) {
        const str2 = join$1(strings);
        const comments = [];
        try {
          const ast = parse2(str2, acorn_opts(comments, str2));
          inject(str2, ast, values, comments);
          return ast.body;
        } catch (err) {
          handle_error(str2, err);
        }
      }
      function x(strings, ...values) {
        const str2 = join$1(strings);
        const comments = [];
        try {
          const expression2 = parseExpressionAt(str2, 0, acorn_opts(comments, str2));
          const match = /\S+/.exec(str2.slice(expression2.end));
          if (match) {
            throw new Error(`Unexpected token '${match[0]}'`);
          }
          inject(str2, expression2, values, comments);
          return expression2;
        } catch (err) {
          handle_error(str2, err);
        }
      }
      function p(strings, ...values) {
        const str2 = `{${join$1(strings)}}`;
        const comments = [];
        try {
          const expression2 = parseExpressionAt(str2, 0, acorn_opts(comments, str2));
          inject(str2, expression2, values, comments);
          return expression2.properties[0];
        } catch (err) {
          handle_error(str2, err);
        }
      }
      function handle_error(str2, err) {
        re.lastIndex = 0;
        str2 = str2.replace(re, (m, i2, at, hash3, name) => {
          if (at)
            return `@${name}`;
          if (hash3)
            return `#${name}`;
          return "${...}";
        });
        console.log(`failed to parse:
${str2}`);
        throw err;
      }
      const parse$1 = (source, opts) => {
        const comments = [];
        const { onComment, enter, leave } = get_comment_handlers(comments, source);
        const ast = parse2(source, { onComment, ...opts });
        walk(ast, { enter, leave });
        return ast;
      };
      const parseExpressionAt$1 = (source, index2, opts) => {
        const comments = [];
        const { onComment, enter, leave } = get_comment_handlers(comments, source);
        const ast = parseExpressionAt(source, index2, { onComment, ...opts });
        walk(ast, { enter, leave });
        return ast;
      };
      const parse$2 = (source) => parse$1(source, {
        sourceType: "module",
        ecmaVersion: 12,
        locations: true
      });
      const parse_expression_at = (source, index2) => parseExpressionAt$1(source, index2, {
        sourceType: "module",
        ecmaVersion: 12,
        locations: true
      });
      const whitespace = /[ \t\r\n]/;
      const dimensions = /^(?:offset|client)(?:Width|Height)$/;
      function list(items, conjunction = "or") {
        if (items.length === 1)
          return items[0];
        return `${items.slice(0, -1).join(", ")} ${conjunction} ${items[items.length - 1]}`;
      }
      var parser_errors = {
        css_syntax_error: (message) => ({
          code: "css-syntax-error",
          message
        }),
        duplicate_attribute: {
          code: "duplicate-attribute",
          message: "Attributes need to be unique"
        },
        duplicate_element: (slug, name) => ({
          code: `duplicate-${slug}`,
          message: `A component can only have one <${name}> tag`
        }),
        duplicate_style: {
          code: "duplicate-style",
          message: "You can only have one top-level <style> tag per component"
        },
        empty_attribute_shorthand: {
          code: "empty-attribute-shorthand",
          message: "Attribute shorthand cannot be empty"
        },
        empty_directive_name: (type) => ({
          code: "empty-directive-name",
          message: `${type} name cannot be empty`
        }),
        empty_global_selector: {
          code: "css-syntax-error",
          message: ":global() must contain a selector"
        },
        expected_block_type: {
          code: "expected-block-type",
          message: "Expected if, each or await"
        },
        expected_name: {
          code: "expected-name",
          message: "Expected name"
        },
        invalid_catch_placement_unclosed_block: (block) => ({
          code: "invalid-catch-placement",
          message: `Expected to close ${block} before seeing {:catch} block`
        }),
        invalid_catch_placement_without_await: {
          code: "invalid-catch-placement",
          message: "Cannot have an {:catch} block outside an {#await ...} block"
        },
        invalid_component_definition: {
          code: "invalid-component-definition",
          message: "invalid component definition"
        },
        invalid_closing_tag_unopened: (name) => ({
          code: "invalid-closing-tag",
          message: `</${name}> attempted to close an element that was not open`
        }),
        invalid_closing_tag_autoclosed: (name, reason) => ({
          code: "invalid-closing-tag",
          message: `</${name}> attempted to close <${name}> that was already automatically closed by <${reason}>`
        }),
        invalid_debug_args: {
          code: "invalid-debug-args",
          message: "{@debug ...} arguments must be identifiers, not arbitrary expressions"
        },
        invalid_declaration: {
          code: "invalid-declaration",
          message: "Declaration cannot be empty"
        },
        invalid_directive_value: {
          code: "invalid-directive-value",
          message: "Directive value must be a JavaScript expression enclosed in curly braces"
        },
        invalid_elseif: {
          code: "invalid-elseif",
          message: "'elseif' should be 'else if'"
        },
        invalid_elseif_placement_outside_if: {
          code: "invalid-elseif-placement",
          message: "Cannot have an {:else if ...} block outside an {#if ...} block"
        },
        invalid_elseif_placement_unclosed_block: (block) => ({
          code: "invalid-elseif-placement",
          message: `Expected to close ${block} before seeing {:else if ...} block`
        }),
        invalid_else_placement_outside_if: {
          code: "invalid-else-placement",
          message: "Cannot have an {:else} block outside an {#if ...} or {#each ...} block"
        },
        invalid_else_placement_unclosed_block: (block) => ({
          code: "invalid-else-placement",
          message: `Expected to close ${block} before seeing {:else} block`
        }),
        invalid_element_content: (slug, name) => ({
          code: `invalid-${slug}-content`,
          message: `<${name}> cannot have children`
        }),
        invalid_element_placement: (slug, name) => ({
          code: `invalid-${slug}-placement`,
          message: `<${name}> tags cannot be inside elements or blocks`
        }),
        invalid_ref_directive: (name) => ({
          code: "invalid-ref-directive",
          message: `The ref directive is no longer supported \u2014 use \`bind:this={${name}}\` instead`
        }),
        invalid_ref_selector: {
          code: "invalid-ref-selector",
          message: "ref selectors are no longer supported"
        },
        invalid_self_placement: {
          code: "invalid-self-placement",
          message: "<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components"
        },
        invalid_script_instance: {
          code: "invalid-script",
          message: "A component can only have one instance-level <script> element"
        },
        invalid_script_module: {
          code: "invalid-script",
          message: 'A component can only have one <script context="module"> element'
        },
        invalid_script_context_attribute: {
          code: "invalid-script",
          message: "context attribute must be static"
        },
        invalid_script_context_value: {
          code: "invalid-script",
          message: 'If the context attribute is supplied, its value must be "module"'
        },
        invalid_tag_name: {
          code: "invalid-tag-name",
          message: "Expected valid tag name"
        },
        invalid_tag_name_svelte_element: (tags, match) => ({
          code: "invalid-tag-name",
          message: `Valid <svelte:...> tag names are ${list(tags)}${match ? " (did you mean " + match + "?)" : ""}`
        }),
        invalid_then_placement_unclosed_block: (block) => ({
          code: "invalid-then-placement",
          message: `Expected to close ${block} before seeing {:then} block`
        }),
        invalid_then_placement_without_await: {
          code: "invalid-then-placement",
          message: "Cannot have an {:then} block outside an {#await ...} block"
        },
        invalid_void_content: (name) => ({
          code: "invalid-void-content",
          message: `<${name}> is a void element and cannot have children, or a closing tag`
        }),
        missing_component_definition: {
          code: "missing-component-definition",
          message: "<svelte:component> must have a 'this' attribute"
        },
        missing_attribute_value: {
          code: "missing-attribute-value",
          message: "Expected value for the attribute"
        },
        unclosed_script: {
          code: "unclosed-script",
          message: "<script> must have a closing tag"
        },
        unclosed_style: {
          code: "unclosed-style",
          message: "<style> must have a closing tag"
        },
        unclosed_comment: {
          code: "unclosed-comment",
          message: "comment was left open, expected -->"
        },
        unclosed_attribute_value: (token) => ({
          code: "unclosed-attribute-value",
          message: `Expected to close the attribute value with ${token}`
        }),
        unexpected_block_close: {
          code: "unexpected-block-close",
          message: "Unexpected block closing tag"
        },
        unexpected_eof: {
          code: "unexpected-eof",
          message: "Unexpected end of input"
        },
        unexpected_eof_token: (token) => ({
          code: "unexpected-eof",
          message: `Unexpected ${token}`
        }),
        unexpected_token: (token) => ({
          code: "unexpected-token",
          message: `Expected ${token}`
        }),
        unexpected_token_destructure: {
          code: "unexpected-token",
          message: "Expected identifier or destructure pattern"
        }
      };
      function read_expression(parser2) {
        try {
          const node2 = parse_expression_at(parser2.template, parser2.index);
          let num_parens = 0;
          for (let i2 = parser2.index; i2 < node2.start; i2 += 1) {
            if (parser2.template[i2] === "(")
              num_parens += 1;
          }
          let index2 = node2.end;
          while (num_parens > 0) {
            const char = parser2.template[index2];
            if (char === ")") {
              num_parens -= 1;
            } else if (!whitespace.test(char)) {
              parser2.error(parser_errors.unexpected_token(")"), index2);
            }
            index2 += 1;
          }
          parser2.index = index2;
          return node2;
        } catch (err) {
          parser2.acorn_error(err);
        }
      }
      function get_context(parser2, attributes, start) {
        const context = attributes.find((attribute) => attribute.name === "context");
        if (!context)
          return "default";
        if (context.value.length !== 1 || context.value[0].type !== "Text") {
          parser2.error(parser_errors.invalid_script_context_attribute, start);
        }
        const value2 = context.value[0].data;
        if (value2 !== "module") {
          parser2.error(parser_errors.invalid_script_context_value, context.start);
        }
        return value2;
      }
      function read_script(parser2, start, attributes) {
        const script_start = parser2.index;
        const data2 = parser2.read_until(/<\/script\s*>/, parser_errors.unclosed_script);
        if (parser2.index >= parser2.template.length) {
          parser2.error(parser_errors.unclosed_script);
        }
        const source = parser2.template.slice(0, script_start).replace(/[^\n]/g, " ") + data2;
        parser2.read(/<\/script\s*>/);
        let ast;
        try {
          ast = parse$2(source);
        } catch (err) {
          parser2.acorn_error(err);
        }
        ast.start = script_start;
        return {
          type: "Script",
          start,
          end: parser2.index,
          context: get_context(parser2, attributes, start),
          content: ast
        };
      }
      var MIN_SIZE = 16 * 1024;
      var SafeUint32Array = typeof Uint32Array !== "undefined" ? Uint32Array : Array;
      var adoptBuffer = function adoptBuffer2(buffer, size) {
        if (buffer === null || buffer.length < size) {
          return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
        }
        return buffer;
      };
      var TYPE = {
        EOF: 0,
        Ident: 1,
        Function: 2,
        AtKeyword: 3,
        Hash: 4,
        String: 5,
        BadString: 6,
        Url: 7,
        BadUrl: 8,
        Delim: 9,
        Number: 10,
        Percentage: 11,
        Dimension: 12,
        WhiteSpace: 13,
        CDO: 14,
        CDC: 15,
        Colon: 16,
        Semicolon: 17,
        Comma: 18,
        LeftSquareBracket: 19,
        RightSquareBracket: 20,
        LeftParenthesis: 21,
        RightParenthesis: 22,
        LeftCurlyBracket: 23,
        RightCurlyBracket: 24,
        Comment: 25
      };
      var NAME2 = Object.keys(TYPE).reduce(function(result, key) {
        result[TYPE[key]] = key;
        return result;
      }, {});
      var _const = {
        TYPE,
        NAME: NAME2
      };
      var EOF = 0;
      function isDigit(code) {
        return code >= 48 && code <= 57;
      }
      function isHexDigit$1(code) {
        return isDigit(code) || code >= 65 && code <= 70 || code >= 97 && code <= 102;
      }
      function isUppercaseLetter(code) {
        return code >= 65 && code <= 90;
      }
      function isLowercaseLetter(code) {
        return code >= 97 && code <= 122;
      }
      function isLetter(code) {
        return isUppercaseLetter(code) || isLowercaseLetter(code);
      }
      function isNonAscii(code) {
        return code >= 128;
      }
      function isNameStart(code) {
        return isLetter(code) || isNonAscii(code) || code === 95;
      }
      function isName(code) {
        return isNameStart(code) || isDigit(code) || code === 45;
      }
      function isNonPrintable(code) {
        return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
      }
      function isNewline(code) {
        return code === 10 || code === 13 || code === 12;
      }
      function isWhiteSpace(code) {
        return isNewline(code) || code === 32 || code === 9;
      }
      function isValidEscape(first, second) {
        if (first !== 92) {
          return false;
        }
        if (isNewline(second) || second === EOF) {
          return false;
        }
        return true;
      }
      function isIdentifierStart$1(first, second, third) {
        if (first === 45) {
          return isNameStart(second) || second === 45 || isValidEscape(second, third);
        }
        if (isNameStart(first)) {
          return true;
        }
        if (first === 92) {
          return isValidEscape(first, second);
        }
        return false;
      }
      function isNumberStart(first, second, third) {
        if (first === 43 || first === 45) {
          if (isDigit(second)) {
            return 2;
          }
          return second === 46 && isDigit(third) ? 3 : 0;
        }
        if (first === 46) {
          return isDigit(second) ? 2 : 0;
        }
        if (isDigit(first)) {
          return 1;
        }
        return 0;
      }
      function isBOM(code) {
        if (code === 65279) {
          return 1;
        }
        if (code === 65534) {
          return 1;
        }
        return 0;
      }
      var CATEGORY = new Array(128);
      charCodeCategory.Eof = 128;
      charCodeCategory.WhiteSpace = 130;
      charCodeCategory.Digit = 131;
      charCodeCategory.NameStart = 132;
      charCodeCategory.NonPrintable = 133;
      for (var i$1 = 0; i$1 < CATEGORY.length; i$1++) {
        switch (true) {
          case isWhiteSpace(i$1):
            CATEGORY[i$1] = charCodeCategory.WhiteSpace;
            break;
          case isDigit(i$1):
            CATEGORY[i$1] = charCodeCategory.Digit;
            break;
          case isNameStart(i$1):
            CATEGORY[i$1] = charCodeCategory.NameStart;
            break;
          case isNonPrintable(i$1):
            CATEGORY[i$1] = charCodeCategory.NonPrintable;
            break;
          default:
            CATEGORY[i$1] = i$1 || charCodeCategory.Eof;
        }
      }
      function charCodeCategory(code) {
        return code < 128 ? CATEGORY[code] : charCodeCategory.NameStart;
      }
      var charCodeDefinitions = {
        isDigit,
        isHexDigit: isHexDigit$1,
        isUppercaseLetter,
        isLowercaseLetter,
        isLetter,
        isNonAscii,
        isNameStart,
        isName,
        isNonPrintable,
        isNewline,
        isWhiteSpace,
        isValidEscape,
        isIdentifierStart: isIdentifierStart$1,
        isNumberStart,
        isBOM,
        charCodeCategory
      };
      var isDigit$1 = charCodeDefinitions.isDigit;
      var isHexDigit$2 = charCodeDefinitions.isHexDigit;
      var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
      var isName$1 = charCodeDefinitions.isName;
      var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
      var isValidEscape$1 = charCodeDefinitions.isValidEscape;
      function getCharCode(source, offset) {
        return offset < source.length ? source.charCodeAt(offset) : 0;
      }
      function getNewlineLength(source, offset, code) {
        if (code === 13 && getCharCode(source, offset + 1) === 10) {
          return 2;
        }
        return 1;
      }
      function cmpChar(testStr, offset, referenceCode) {
        var code = testStr.charCodeAt(offset);
        if (isUppercaseLetter$1(code)) {
          code = code | 32;
        }
        return code === referenceCode;
      }
      function cmpStr(testStr, start, end, referenceStr) {
        if (end - start !== referenceStr.length) {
          return false;
        }
        if (start < 0 || end > testStr.length) {
          return false;
        }
        for (var i2 = start; i2 < end; i2++) {
          var testCode = testStr.charCodeAt(i2);
          var referenceCode = referenceStr.charCodeAt(i2 - start);
          if (isUppercaseLetter$1(testCode)) {
            testCode = testCode | 32;
          }
          if (testCode !== referenceCode) {
            return false;
          }
        }
        return true;
      }
      function findWhiteSpaceStart(source, offset) {
        for (; offset >= 0; offset--) {
          if (!isWhiteSpace$1(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset + 1;
      }
      function findWhiteSpaceEnd(source, offset) {
        for (; offset < source.length; offset++) {
          if (!isWhiteSpace$1(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset;
      }
      function findDecimalNumberEnd(source, offset) {
        for (; offset < source.length; offset++) {
          if (!isDigit$1(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset;
      }
      function consumeEscaped(source, offset) {
        offset += 2;
        if (isHexDigit$2(getCharCode(source, offset - 1))) {
          for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
            if (!isHexDigit$2(getCharCode(source, offset))) {
              break;
            }
          }
          var code = getCharCode(source, offset);
          if (isWhiteSpace$1(code)) {
            offset += getNewlineLength(source, offset, code);
          }
        }
        return offset;
      }
      function consumeName(source, offset) {
        for (; offset < source.length; offset++) {
          var code = source.charCodeAt(offset);
          if (isName$1(code)) {
            continue;
          }
          if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
            offset = consumeEscaped(source, offset) - 1;
            continue;
          }
          break;
        }
        return offset;
      }
      function consumeNumber(source, offset) {
        var code = source.charCodeAt(offset);
        if (code === 43 || code === 45) {
          code = source.charCodeAt(offset += 1);
        }
        if (isDigit$1(code)) {
          offset = findDecimalNumberEnd(source, offset + 1);
          code = source.charCodeAt(offset);
        }
        if (code === 46 && isDigit$1(source.charCodeAt(offset + 1))) {
          code = source.charCodeAt(offset += 2);
          offset = findDecimalNumberEnd(source, offset);
        }
        if (cmpChar(source, offset, 101)) {
          var sign = 0;
          code = source.charCodeAt(offset + 1);
          if (code === 45 || code === 43) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
          }
          if (isDigit$1(code)) {
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
          }
        }
        return offset;
      }
      function consumeBadUrlRemnants(source, offset) {
        for (; offset < source.length; offset++) {
          var code = source.charCodeAt(offset);
          if (code === 41) {
            offset++;
            break;
          }
          if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
            offset = consumeEscaped(source, offset);
          }
        }
        return offset;
      }
      var utils = {
        consumeEscaped,
        consumeName,
        consumeNumber,
        consumeBadUrlRemnants,
        cmpChar,
        cmpStr,
        getNewlineLength,
        findWhiteSpaceStart,
        findWhiteSpaceEnd
      };
      var TYPE$1 = _const.TYPE;
      var NAME$1 = _const.NAME;
      var cmpStr$1 = utils.cmpStr;
      var EOF$1 = TYPE$1.EOF;
      var WHITESPACE = TYPE$1.WhiteSpace;
      var COMMENT = TYPE$1.Comment;
      var OFFSET_MASK = 16777215;
      var TYPE_SHIFT = 24;
      var TokenStream = function() {
        this.offsetAndType = null;
        this.balance = null;
        this.reset();
      };
      TokenStream.prototype = {
        reset: function() {
          this.eof = false;
          this.tokenIndex = -1;
          this.tokenType = 0;
          this.tokenStart = this.firstCharOffset;
          this.tokenEnd = this.firstCharOffset;
        },
        lookupType: function(offset) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
          }
          return EOF$1;
        },
        lookupOffset: function(offset) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK;
          }
          return this.source.length;
        },
        lookupValue: function(offset, referenceStr) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return cmpStr$1(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);
          }
          return false;
        },
        getTokenStart: function(tokenIndex) {
          if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
          }
          if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
          }
          return this.firstCharOffset;
        },
        getRawLength: function(startToken, mode) {
          var cursor = startToken;
          var balanceEnd2;
          var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
          var type;
          loop:
            for (; cursor < this.tokenCount; cursor++) {
              balanceEnd2 = this.balance[cursor];
              if (balanceEnd2 < startToken) {
                break loop;
              }
              type = this.offsetAndType[cursor] >> TYPE_SHIFT;
              switch (mode(type, this.source, offset)) {
                case 1:
                  break loop;
                case 2:
                  cursor++;
                  break loop;
                default:
                  offset = this.offsetAndType[cursor] & OFFSET_MASK;
                  if (this.balance[balanceEnd2] === cursor) {
                    cursor = balanceEnd2;
                  }
              }
            }
          return cursor - this.tokenIndex;
        },
        isBalanceEdge: function(pos) {
          return this.balance[this.tokenIndex] < pos;
        },
        isDelim: function(code, offset) {
          if (offset) {
            return this.lookupType(offset) === TYPE$1.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
          }
          return this.tokenType === TYPE$1.Delim && this.source.charCodeAt(this.tokenStart) === code;
        },
        getTokenValue: function() {
          return this.source.substring(this.tokenStart, this.tokenEnd);
        },
        getTokenLength: function() {
          return this.tokenEnd - this.tokenStart;
        },
        substrToCursor: function(start) {
          return this.source.substring(start, this.tokenStart);
        },
        skipWS: function() {
          for (var i2 = this.tokenIndex, skipTokenCount = 0; i2 < this.tokenCount; i2++, skipTokenCount++) {
            if (this.offsetAndType[i2] >> TYPE_SHIFT !== WHITESPACE) {
              break;
            }
          }
          if (skipTokenCount > 0) {
            this.skip(skipTokenCount);
          }
        },
        skipSC: function() {
          while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
            this.next();
          }
        },
        skip: function(tokenCount) {
          var next = this.tokenIndex + tokenCount;
          if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
          } else {
            this.tokenIndex = this.tokenCount;
            this.next();
          }
        },
        next: function() {
          var next = this.tokenIndex + 1;
          if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
          } else {
            this.tokenIndex = this.tokenCount;
            this.eof = true;
            this.tokenType = EOF$1;
            this.tokenStart = this.tokenEnd = this.source.length;
          }
        },
        forEachToken(fn) {
          for (var i2 = 0, offset = this.firstCharOffset; i2 < this.tokenCount; i2++) {
            var start = offset;
            var item = this.offsetAndType[i2];
            var end = item & OFFSET_MASK;
            var type = item >> TYPE_SHIFT;
            offset = end;
            fn(type, start, end, i2);
          }
        },
        dump() {
          var tokens = new Array(this.tokenCount);
          this.forEachToken((type, start, end, index2) => {
            tokens[index2] = {
              idx: index2,
              type: NAME$1[type],
              chunk: this.source.substring(start, end),
              balance: this.balance[index2]
            };
          });
          return tokens;
        }
      };
      var TokenStream_1 = TokenStream;
      var TYPE$2 = _const.TYPE;
      var isNewline$1 = charCodeDefinitions.isNewline;
      var isName$2 = charCodeDefinitions.isName;
      var isValidEscape$2 = charCodeDefinitions.isValidEscape;
      var isNumberStart$1 = charCodeDefinitions.isNumberStart;
      var isIdentifierStart$2 = charCodeDefinitions.isIdentifierStart;
      var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
      var isBOM$1 = charCodeDefinitions.isBOM;
      var cmpStr$2 = utils.cmpStr;
      var getNewlineLength$1 = utils.getNewlineLength;
      var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
      var consumeEscaped$1 = utils.consumeEscaped;
      var consumeName$1 = utils.consumeName;
      var consumeNumber$1 = utils.consumeNumber;
      var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;
      var OFFSET_MASK$1 = 16777215;
      var TYPE_SHIFT$1 = 24;
      function tokenize(source, stream) {
        function getCharCode2(offset2) {
          return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
        }
        function consumeNumericToken() {
          offset = consumeNumber$1(source, offset);
          if (isIdentifierStart$2(getCharCode2(offset), getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            type = TYPE$2.Dimension;
            offset = consumeName$1(source, offset);
            return;
          }
          if (getCharCode2(offset) === 37) {
            type = TYPE$2.Percentage;
            offset++;
            return;
          }
          type = TYPE$2.Number;
        }
        function consumeIdentLikeToken() {
          const nameStartOffset = offset;
          offset = consumeName$1(source, offset);
          if (cmpStr$2(source, nameStartOffset, offset, "url") && getCharCode2(offset) === 40) {
            offset = findWhiteSpaceEnd$1(source, offset + 1);
            if (getCharCode2(offset) === 34 || getCharCode2(offset) === 39) {
              type = TYPE$2.Function;
              offset = nameStartOffset + 4;
              return;
            }
            consumeUrlToken();
            return;
          }
          if (getCharCode2(offset) === 40) {
            type = TYPE$2.Function;
            offset++;
            return;
          }
          type = TYPE$2.Ident;
        }
        function consumeStringToken(endingCodePoint) {
          if (!endingCodePoint) {
            endingCodePoint = getCharCode2(offset++);
          }
          type = TYPE$2.String;
          for (; offset < source.length; offset++) {
            var code2 = source.charCodeAt(offset);
            switch (charCodeCategory$1(code2)) {
              case endingCodePoint:
                offset++;
                return;
              case charCodeCategory$1.Eof:
                return;
              case charCodeCategory$1.WhiteSpace:
                if (isNewline$1(code2)) {
                  offset += getNewlineLength$1(source, offset, code2);
                  type = TYPE$2.BadString;
                  return;
                }
                break;
              case 92:
                if (offset === source.length - 1) {
                  break;
                }
                var nextCode = getCharCode2(offset + 1);
                if (isNewline$1(nextCode)) {
                  offset += getNewlineLength$1(source, offset + 1, nextCode);
                } else if (isValidEscape$2(code2, nextCode)) {
                  offset = consumeEscaped$1(source, offset) - 1;
                }
                break;
            }
          }
        }
        function consumeUrlToken() {
          type = TYPE$2.Url;
          offset = findWhiteSpaceEnd$1(source, offset);
          for (; offset < source.length; offset++) {
            var code2 = source.charCodeAt(offset);
            switch (charCodeCategory$1(code2)) {
              case 41:
                offset++;
                return;
              case charCodeCategory$1.Eof:
                return;
              case charCodeCategory$1.WhiteSpace:
                offset = findWhiteSpaceEnd$1(source, offset);
                if (getCharCode2(offset) === 41 || offset >= source.length) {
                  if (offset < source.length) {
                    offset++;
                  }
                  return;
                }
                offset = consumeBadUrlRemnants$1(source, offset);
                type = TYPE$2.BadUrl;
                return;
              case 34:
              case 39:
              case 40:
              case charCodeCategory$1.NonPrintable:
                offset = consumeBadUrlRemnants$1(source, offset);
                type = TYPE$2.BadUrl;
                return;
              case 92:
                if (isValidEscape$2(code2, getCharCode2(offset + 1))) {
                  offset = consumeEscaped$1(source, offset) - 1;
                  break;
                }
                offset = consumeBadUrlRemnants$1(source, offset);
                type = TYPE$2.BadUrl;
                return;
            }
          }
        }
        if (!stream) {
          stream = new TokenStream_1();
        }
        source = String(source || "");
        var sourceLength = source.length;
        var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1);
        var balance = adoptBuffer(stream.balance, sourceLength + 1);
        var tokenCount = 0;
        var start = isBOM$1(getCharCode2(0));
        var offset = start;
        var balanceCloseType = 0;
        var balanceStart = 0;
        var balancePrev = 0;
        while (offset < sourceLength) {
          var code = source.charCodeAt(offset);
          var type = 0;
          balance[tokenCount] = sourceLength;
          switch (charCodeCategory$1(code)) {
            case charCodeCategory$1.WhiteSpace:
              type = TYPE$2.WhiteSpace;
              offset = findWhiteSpaceEnd$1(source, offset + 1);
              break;
            case 34:
              consumeStringToken();
              break;
            case 35:
              if (isName$2(getCharCode2(offset + 1)) || isValidEscape$2(getCharCode2(offset + 1), getCharCode2(offset + 2))) {
                type = TYPE$2.Hash;
                offset = consumeName$1(source, offset + 1);
              } else {
                type = TYPE$2.Delim;
                offset++;
              }
              break;
            case 39:
              consumeStringToken();
              break;
            case 40:
              type = TYPE$2.LeftParenthesis;
              offset++;
              break;
            case 41:
              type = TYPE$2.RightParenthesis;
              offset++;
              break;
            case 43:
              if (isNumberStart$1(code, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
                consumeNumericToken();
              } else {
                type = TYPE$2.Delim;
                offset++;
              }
              break;
            case 44:
              type = TYPE$2.Comma;
              offset++;
              break;
            case 45:
              if (isNumberStart$1(code, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
                consumeNumericToken();
              } else {
                if (getCharCode2(offset + 1) === 45 && getCharCode2(offset + 2) === 62) {
                  type = TYPE$2.CDC;
                  offset = offset + 3;
                } else {
                  if (isIdentifierStart$2(code, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
                    consumeIdentLikeToken();
                  } else {
                    type = TYPE$2.Delim;
                    offset++;
                  }
                }
              }
              break;
            case 46:
              if (isNumberStart$1(code, getCharCode2(offset + 1), getCharCode2(offset + 2))) {
                consumeNumericToken();
              } else {
                type = TYPE$2.Delim;
                offset++;
              }
              break;
            case 47:
              if (getCharCode2(offset + 1) === 42) {
                type = TYPE$2.Comment;
                offset = source.indexOf("*/", offset + 2) + 2;
                if (offset === 1) {
                  offset = source.length;
                }
              } else {
                type = TYPE$2.Delim;
                offset++;
              }
              break;
            case 58:
              type = TYPE$2.Colon;
              offset++;
              break;
            case 59:
              type = TYPE$2.Semicolon;
              offset++;
              break;
            case 60:
              if (getCharCode2(offset + 1) === 33 && getCharCode2(offset + 2) === 45 && getCharCode2(offset + 3) === 45) {
                type = TYPE$2.CDO;
                offset = offset + 4;
              } else {
                type = TYPE$2.Delim;
                offset++;
              }
              break;
            case 64:
              if (isIdentifierStart$2(getCharCode2(offset + 1), getCharCode2(offset + 2), getCharCode2(offset + 3))) {
                type = TYPE$2.AtKeyword;
                offset = consumeName$1(source, offset + 1);
              } else {
                type = TYPE$2.Delim;
                offset++;
              }
              break;
            case 91:
              type = TYPE$2.LeftSquareBracket;
              offset++;
              break;
            case 92:
              if (isValidEscape$2(code, getCharCode2(offset + 1))) {
                consumeIdentLikeToken();
              } else {
                type = TYPE$2.Delim;
                offset++;
              }
              break;
            case 93:
              type = TYPE$2.RightSquareBracket;
              offset++;
              break;
            case 123:
              type = TYPE$2.LeftCurlyBracket;
              offset++;
              break;
            case 125:
              type = TYPE$2.RightCurlyBracket;
              offset++;
              break;
            case charCodeCategory$1.Digit:
              consumeNumericToken();
              break;
            case charCodeCategory$1.NameStart:
              consumeIdentLikeToken();
              break;
            case charCodeCategory$1.Eof:
              break;
            default:
              type = TYPE$2.Delim;
              offset++;
          }
          switch (type) {
            case balanceCloseType:
              balancePrev = balanceStart & OFFSET_MASK$1;
              balanceStart = balance[balancePrev];
              balanceCloseType = balanceStart >> TYPE_SHIFT$1;
              balance[tokenCount] = balancePrev;
              balance[balancePrev++] = tokenCount;
              for (; balancePrev < tokenCount; balancePrev++) {
                if (balance[balancePrev] === sourceLength) {
                  balance[balancePrev] = tokenCount;
                }
              }
              break;
            case TYPE$2.LeftParenthesis:
            case TYPE$2.Function:
              balance[tokenCount] = balanceStart;
              balanceCloseType = TYPE$2.RightParenthesis;
              balanceStart = balanceCloseType << TYPE_SHIFT$1 | tokenCount;
              break;
            case TYPE$2.LeftSquareBracket:
              balance[tokenCount] = balanceStart;
              balanceCloseType = TYPE$2.RightSquareBracket;
              balanceStart = balanceCloseType << TYPE_SHIFT$1 | tokenCount;
              break;
            case TYPE$2.LeftCurlyBracket:
              balance[tokenCount] = balanceStart;
              balanceCloseType = TYPE$2.RightCurlyBracket;
              balanceStart = balanceCloseType << TYPE_SHIFT$1 | tokenCount;
              break;
          }
          offsetAndType[tokenCount++] = type << TYPE_SHIFT$1 | offset;
        }
        offsetAndType[tokenCount] = TYPE$2.EOF << TYPE_SHIFT$1 | offset;
        balance[tokenCount] = sourceLength;
        balance[sourceLength] = sourceLength;
        while (balanceStart !== 0) {
          balancePrev = balanceStart & OFFSET_MASK$1;
          balanceStart = balance[balancePrev];
          balance[balancePrev] = sourceLength;
        }
        stream.source = source;
        stream.firstCharOffset = start;
        stream.offsetAndType = offsetAndType;
        stream.tokenCount = tokenCount;
        stream.balance = balance;
        stream.reset();
        stream.next();
        return stream;
      }
      Object.keys(_const).forEach(function(key) {
        tokenize[key] = _const[key];
      });
      Object.keys(charCodeDefinitions).forEach(function(key) {
        tokenize[key] = charCodeDefinitions[key];
      });
      Object.keys(utils).forEach(function(key) {
        tokenize[key] = utils[key];
      });
      var tokenizer = tokenize;
      var isBOM$2 = tokenizer.isBOM;
      var N = 10;
      var F = 12;
      var R = 13;
      function computeLinesAndColumns(host, source) {
        var sourceLength = source.length;
        var lines = adoptBuffer(host.lines, sourceLength);
        var line = host.startLine;
        var columns = adoptBuffer(host.columns, sourceLength);
        var column = host.startColumn;
        var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;
        for (var i2 = startOffset; i2 < sourceLength; i2++) {
          var code = source.charCodeAt(i2);
          lines[i2] = line;
          columns[i2] = column++;
          if (code === N || code === R || code === F) {
            if (code === R && i2 + 1 < sourceLength && source.charCodeAt(i2 + 1) === N) {
              i2++;
              lines[i2] = line;
              columns[i2] = column;
            }
            line++;
            column = 1;
          }
        }
        lines[i2] = line;
        columns[i2] = column;
        host.lines = lines;
        host.columns = columns;
      }
      var OffsetToLocation = function() {
        this.lines = null;
        this.columns = null;
        this.linesAndColumnsComputed = false;
      };
      OffsetToLocation.prototype = {
        setSource: function(source, startOffset, startLine, startColumn) {
          this.source = source;
          this.startOffset = typeof startOffset === "undefined" ? 0 : startOffset;
          this.startLine = typeof startLine === "undefined" ? 1 : startLine;
          this.startColumn = typeof startColumn === "undefined" ? 1 : startColumn;
          this.linesAndColumnsComputed = false;
        },
        ensureLinesAndColumnsComputed: function() {
          if (!this.linesAndColumnsComputed) {
            computeLinesAndColumns(this, this.source);
            this.linesAndColumnsComputed = true;
          }
        },
        getLocation: function(offset, filename) {
          this.ensureLinesAndColumnsComputed();
          return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
          };
        },
        getLocationRange: function(start, end, filename) {
          this.ensureLinesAndColumnsComputed();
          return {
            source: filename,
            start: {
              offset: this.startOffset + start,
              line: this.lines[start],
              column: this.columns[start]
            },
            end: {
              offset: this.startOffset + end,
              line: this.lines[end],
              column: this.columns[end]
            }
          };
        }
      };
      var OffsetToLocation_1 = OffsetToLocation;
      var createCustomError = function createCustomError2(name, message) {
        var error4 = Object.create(SyntaxError.prototype);
        var errorStack = new Error();
        error4.name = name;
        error4.message = message;
        Object.defineProperty(error4, "stack", {
          get: function() {
            return (errorStack.stack || "").replace(/^(.+\n){1,3}/, name + ": " + message + "\n");
          }
        });
        return error4;
      };
      var MAX_LINE_LENGTH = 100;
      var OFFSET_CORRECTION = 60;
      var TAB_REPLACEMENT = "    ";
      function sourceFragment(error4, extraLines) {
        function processLines(start, end) {
          return lines.slice(start, end).map(function(line2, idx) {
            var num = String(start + idx + 1);
            while (num.length < maxNumLength) {
              num = " " + num;
            }
            return num + " |" + line2;
          }).join("\n");
        }
        var lines = error4.source.split(/\r\n?|\n|\f/);
        var line = error4.line;
        var column = error4.column;
        var startLine = Math.max(1, line - extraLines) - 1;
        var endLine = Math.min(line + extraLines, lines.length + 1);
        var maxNumLength = Math.max(4, String(endLine).length) + 1;
        var cutLeft = 0;
        column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
        if (column > MAX_LINE_LENGTH) {
          cutLeft = column - OFFSET_CORRECTION + 3;
          column = OFFSET_CORRECTION - 2;
        }
        for (var i2 = startLine; i2 <= endLine; i2++) {
          if (i2 >= 0 && i2 < lines.length) {
            lines[i2] = lines[i2].replace(/\t/g, TAB_REPLACEMENT);
            lines[i2] = (cutLeft > 0 && lines[i2].length > cutLeft ? "\u2026" : "") + lines[i2].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i2].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
          }
        }
        return [
          processLines(startLine, line),
          new Array(column + maxNumLength + 2).join("-") + "^",
          processLines(line, endLine)
        ].filter(Boolean).join("\n");
      }
      var SyntaxError$1 = function(message, source, offset, line, column) {
        var error4 = createCustomError("SyntaxError", message);
        error4.source = source;
        error4.offset = offset;
        error4.line = line;
        error4.column = column;
        error4.sourceFragment = function(extraLines) {
          return sourceFragment(error4, isNaN(extraLines) ? 0 : extraLines);
        };
        Object.defineProperty(error4, "formattedMessage", {
          get: function() {
            return "Parse error: " + error4.message + "\n" + sourceFragment(error4, 2);
          }
        });
        error4.parseError = {
          offset,
          line,
          column
        };
        return error4;
      };
      var _SyntaxError = SyntaxError$1;
      function createItem(data2) {
        return {
          prev: null,
          next: null,
          data: data2
        };
      }
      function allocateCursor(node2, prev, next) {
        var cursor;
        if (cursors !== null) {
          cursor = cursors;
          cursors = cursors.cursor;
          cursor.prev = prev;
          cursor.next = next;
          cursor.cursor = node2.cursor;
        } else {
          cursor = {
            prev,
            next,
            cursor: node2.cursor
          };
        }
        node2.cursor = cursor;
        return cursor;
      }
      function releaseCursor(node2) {
        var cursor = node2.cursor;
        node2.cursor = cursor.cursor;
        cursor.prev = null;
        cursor.next = null;
        cursor.cursor = cursors;
        cursors = cursor;
      }
      var cursors = null;
      var List = function() {
        this.cursor = null;
        this.head = null;
        this.tail = null;
      };
      List.createItem = createItem;
      List.prototype.createItem = createItem;
      List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
        var cursor = this.cursor;
        while (cursor !== null) {
          if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
          }
          if (cursor.next === nextOld) {
            cursor.next = nextNew;
          }
          cursor = cursor.cursor;
        }
      };
      List.prototype.getSize = function() {
        var size = 0;
        var cursor = this.head;
        while (cursor) {
          size++;
          cursor = cursor.next;
        }
        return size;
      };
      List.prototype.fromArray = function(array) {
        var cursor = null;
        this.head = null;
        for (var i2 = 0; i2 < array.length; i2++) {
          var item = createItem(array[i2]);
          if (cursor !== null) {
            cursor.next = item;
          } else {
            this.head = item;
          }
          item.prev = cursor;
          cursor = item;
        }
        this.tail = cursor;
        return this;
      };
      List.prototype.toArray = function() {
        var cursor = this.head;
        var result = [];
        while (cursor) {
          result.push(cursor.data);
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.toJSON = List.prototype.toArray;
      List.prototype.isEmpty = function() {
        return this.head === null;
      };
      List.prototype.first = function() {
        return this.head && this.head.data;
      };
      List.prototype.last = function() {
        return this.tail && this.tail.data;
      };
      List.prototype.each = function(fn, context) {
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, null, this.head);
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          fn.call(context, item.data, item, this);
        }
        releaseCursor(this);
      };
      List.prototype.forEach = List.prototype.each;
      List.prototype.eachRight = function(fn, context) {
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, this.tail, null);
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          fn.call(context, item.data, item, this);
        }
        releaseCursor(this);
      };
      List.prototype.forEachRight = List.prototype.eachRight;
      List.prototype.reduce = function(fn, initialValue, context) {
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, null, this.head);
        var acc = initialValue;
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          acc = fn.call(context, acc, item.data, item, this);
        }
        releaseCursor(this);
        return acc;
      };
      List.prototype.reduceRight = function(fn, initialValue, context) {
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, this.tail, null);
        var acc = initialValue;
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          acc = fn.call(context, acc, item.data, item, this);
        }
        releaseCursor(this);
        return acc;
      };
      List.prototype.nextUntil = function(start, fn, context) {
        if (start === null) {
          return;
        }
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, null, start);
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          if (fn.call(context, item.data, item, this)) {
            break;
          }
        }
        releaseCursor(this);
      };
      List.prototype.prevUntil = function(start, fn, context) {
        if (start === null) {
          return;
        }
        var item;
        if (context === void 0) {
          context = this;
        }
        var cursor = allocateCursor(this, start, null);
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          if (fn.call(context, item.data, item, this)) {
            break;
          }
        }
        releaseCursor(this);
      };
      List.prototype.some = function(fn, context) {
        var cursor = this.head;
        if (context === void 0) {
          context = this;
        }
        while (cursor !== null) {
          if (fn.call(context, cursor.data, cursor, this)) {
            return true;
          }
          cursor = cursor.next;
        }
        return false;
      };
      List.prototype.map = function(fn, context) {
        var result = new List();
        var cursor = this.head;
        if (context === void 0) {
          context = this;
        }
        while (cursor !== null) {
          result.appendData(fn.call(context, cursor.data, cursor, this));
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.filter = function(fn, context) {
        var result = new List();
        var cursor = this.head;
        if (context === void 0) {
          context = this;
        }
        while (cursor !== null) {
          if (fn.call(context, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
          }
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.clear = function() {
        this.head = null;
        this.tail = null;
      };
      List.prototype.copy = function() {
        var result = new List();
        var cursor = this.head;
        while (cursor !== null) {
          result.insert(createItem(cursor.data));
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.prepend = function(item) {
        this.updateCursors(null, item, this.head, item);
        if (this.head !== null) {
          this.head.prev = item;
          item.next = this.head;
        } else {
          this.tail = item;
        }
        this.head = item;
        return this;
      };
      List.prototype.prependData = function(data2) {
        return this.prepend(createItem(data2));
      };
      List.prototype.append = function(item) {
        return this.insert(item);
      };
      List.prototype.appendData = function(data2) {
        return this.insert(createItem(data2));
      };
      List.prototype.insert = function(item, before) {
        if (before !== void 0 && before !== null) {
          this.updateCursors(before.prev, item, before, item);
          if (before.prev === null) {
            if (this.head !== before) {
              throw new Error("before doesn't belong to list");
            }
            this.head = item;
            before.prev = item;
            item.next = before;
            this.updateCursors(null, item);
          } else {
            before.prev.next = item;
            item.prev = before.prev;
            before.prev = item;
            item.next = before;
          }
        } else {
          this.updateCursors(this.tail, item, null, item);
          if (this.tail !== null) {
            this.tail.next = item;
            item.prev = this.tail;
          } else {
            this.head = item;
          }
          this.tail = item;
        }
        return this;
      };
      List.prototype.insertData = function(data2, before) {
        return this.insert(createItem(data2), before);
      };
      List.prototype.remove = function(item) {
        this.updateCursors(item, item.prev, item, item.next);
        if (item.prev !== null) {
          item.prev.next = item.next;
        } else {
          if (this.head !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.head = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        } else {
          if (this.tail !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.tail = item.prev;
        }
        item.prev = null;
        item.next = null;
        return item;
      };
      List.prototype.push = function(data2) {
        this.insert(createItem(data2));
      };
      List.prototype.pop = function() {
        if (this.tail !== null) {
          return this.remove(this.tail);
        }
      };
      List.prototype.unshift = function(data2) {
        this.prepend(createItem(data2));
      };
      List.prototype.shift = function() {
        if (this.head !== null) {
          return this.remove(this.head);
        }
      };
      List.prototype.prependList = function(list2) {
        return this.insertList(list2, this.head);
      };
      List.prototype.appendList = function(list2) {
        return this.insertList(list2);
      };
      List.prototype.insertList = function(list2, before) {
        if (list2.head === null) {
          return this;
        }
        if (before !== void 0 && before !== null) {
          this.updateCursors(before.prev, list2.tail, before, list2.head);
          if (before.prev !== null) {
            before.prev.next = list2.head;
            list2.head.prev = before.prev;
          } else {
            this.head = list2.head;
          }
          before.prev = list2.tail;
          list2.tail.next = before;
        } else {
          this.updateCursors(this.tail, list2.tail, null, list2.head);
          if (this.tail !== null) {
            this.tail.next = list2.head;
            list2.head.prev = this.tail;
          } else {
            this.head = list2.head;
          }
          this.tail = list2.tail;
        }
        list2.head = null;
        list2.tail = null;
        return this;
      };
      List.prototype.replace = function(oldItem, newItemOrList) {
        if ("head" in newItemOrList) {
          this.insertList(newItemOrList, oldItem);
        } else {
          this.insert(newItemOrList, oldItem);
        }
        this.remove(oldItem);
      };
      var List_1 = List;
      var TYPE$3 = tokenizer.TYPE;
      var WHITESPACE$1 = TYPE$3.WhiteSpace;
      var COMMENT$1 = TYPE$3.Comment;
      var sequence = function readSequence2(recognizer) {
        var children = this.createList();
        var child = null;
        var context = {
          recognizer,
          space: null,
          ignoreWS: false,
          ignoreWSAfter: false
        };
        this.scanner.skipSC();
        while (!this.scanner.eof) {
          switch (this.scanner.tokenType) {
            case COMMENT$1:
              this.scanner.next();
              continue;
            case WHITESPACE$1:
              if (context.ignoreWS) {
                this.scanner.next();
              } else {
                context.space = this.WhiteSpace();
              }
              continue;
          }
          child = recognizer.getNode.call(this, context);
          if (child === void 0) {
            break;
          }
          if (context.space !== null) {
            children.push(context.space);
            context.space = null;
          }
          children.push(child);
          if (context.ignoreWSAfter) {
            context.ignoreWSAfter = false;
            context.ignoreWS = true;
          } else {
            context.ignoreWS = false;
          }
        }
        return children;
      };
      var { findWhiteSpaceStart: findWhiteSpaceStart$1, cmpStr: cmpStr$3 } = utils;
      var noop2 = function() {
      };
      var TYPE$4 = _const.TYPE;
      var NAME$2 = _const.NAME;
      var WHITESPACE$2 = TYPE$4.WhiteSpace;
      var COMMENT$2 = TYPE$4.Comment;
      var IDENT = TYPE$4.Ident;
      var FUNCTION = TYPE$4.Function;
      var URL$1 = TYPE$4.Url;
      var HASH = TYPE$4.Hash;
      var PERCENTAGE = TYPE$4.Percentage;
      var NUMBER = TYPE$4.Number;
      var NUMBERSIGN = 35;
      var NULL = 0;
      function createParseContext(name) {
        return function() {
          return this[name]();
        };
      }
      function processConfig(config) {
        var parserConfig = {
          context: {},
          scope: {},
          atrule: {},
          pseudo: {}
        };
        if (config.parseContext) {
          for (var name in config.parseContext) {
            switch (typeof config.parseContext[name]) {
              case "function":
                parserConfig.context[name] = config.parseContext[name];
                break;
              case "string":
                parserConfig.context[name] = createParseContext(config.parseContext[name]);
                break;
            }
          }
        }
        if (config.scope) {
          for (var name in config.scope) {
            parserConfig.scope[name] = config.scope[name];
          }
        }
        if (config.atrule) {
          for (var name in config.atrule) {
            var atrule2 = config.atrule[name];
            if (atrule2.parse) {
              parserConfig.atrule[name] = atrule2.parse;
            }
          }
        }
        if (config.pseudo) {
          for (var name in config.pseudo) {
            var pseudo2 = config.pseudo[name];
            if (pseudo2.parse) {
              parserConfig.pseudo[name] = pseudo2.parse;
            }
          }
        }
        if (config.node) {
          for (var name in config.node) {
            parserConfig[name] = config.node[name].parse;
          }
        }
        return parserConfig;
      }
      var create = function createParser(config) {
        var parser2 = {
          scanner: new TokenStream_1(),
          locationMap: new OffsetToLocation_1(),
          filename: "<unknown>",
          needPositions: false,
          onParseError: noop2,
          onParseErrorThrow: false,
          parseAtrulePrelude: true,
          parseRulePrelude: true,
          parseValue: true,
          parseCustomProperty: false,
          readSequence: sequence,
          createList: function() {
            return new List_1();
          },
          createSingleNodeList: function(node2) {
            return new List_1().appendData(node2);
          },
          getFirstListNode: function(list2) {
            return list2 && list2.first();
          },
          getLastListNode: function(list2) {
            return list2.last();
          },
          parseWithFallback: function(consumer, fallback) {
            var startToken = this.scanner.tokenIndex;
            try {
              return consumer.call(this);
            } catch (e) {
              if (this.onParseErrorThrow) {
                throw e;
              }
              var fallbackNode = fallback.call(this, startToken);
              this.onParseErrorThrow = true;
              this.onParseError(e, fallbackNode);
              this.onParseErrorThrow = false;
              return fallbackNode;
            }
          },
          lookupNonWSType: function(offset) {
            do {
              var type = this.scanner.lookupType(offset++);
              if (type !== WHITESPACE$2) {
                return type;
              }
            } while (type !== NULL);
            return NULL;
          },
          eat: function(tokenType) {
            if (this.scanner.tokenType !== tokenType) {
              var offset = this.scanner.tokenStart;
              var message = NAME$2[tokenType] + " is expected";
              switch (tokenType) {
                case IDENT:
                  if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
                    offset = this.scanner.tokenEnd - 1;
                    message = "Identifier is expected but function found";
                  } else {
                    message = "Identifier is expected";
                  }
                  break;
                case HASH:
                  if (this.scanner.isDelim(NUMBERSIGN)) {
                    this.scanner.next();
                    offset++;
                    message = "Name is expected";
                  }
                  break;
                case PERCENTAGE:
                  if (this.scanner.tokenType === NUMBER) {
                    offset = this.scanner.tokenEnd;
                    message = "Percent sign is expected";
                  }
                  break;
                default:
                  if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
                    offset = offset + 1;
                  }
              }
              this.error(message, offset);
            }
            this.scanner.next();
          },
          consume: function(tokenType) {
            var value2 = this.scanner.getTokenValue();
            this.eat(tokenType);
            return value2;
          },
          consumeFunctionName: function() {
            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);
            this.eat(FUNCTION);
            return name;
          },
          getLocation: function(start, end) {
            if (this.needPositions) {
              return this.locationMap.getLocationRange(start, end, this.filename);
            }
            return null;
          },
          getLocationFromList: function(list2) {
            if (this.needPositions) {
              var head = this.getFirstListNode(list2);
              var tail = this.getLastListNode(list2);
              return this.locationMap.getLocationRange(head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart, tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart, this.filename);
            }
            return null;
          },
          error: function(message, offset) {
            var location = typeof offset !== "undefined" && offset < this.scanner.source.length ? this.locationMap.getLocation(offset) : this.scanner.eof ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1)) : this.locationMap.getLocation(this.scanner.tokenStart);
            throw new _SyntaxError(message || "Unexpected input", this.scanner.source, location.offset, location.line, location.column);
          }
        };
        config = processConfig(config || {});
        for (var key in config) {
          parser2[key] = config[key];
        }
        return function(source, options3) {
          options3 = options3 || {};
          var context = options3.context || "default";
          var onComment = options3.onComment;
          var ast;
          tokenizer(source, parser2.scanner);
          parser2.locationMap.setSource(source, options3.offset, options3.line, options3.column);
          parser2.filename = options3.filename || "<unknown>";
          parser2.needPositions = Boolean(options3.positions);
          parser2.onParseError = typeof options3.onParseError === "function" ? options3.onParseError : noop2;
          parser2.onParseErrorThrow = false;
          parser2.parseAtrulePrelude = "parseAtrulePrelude" in options3 ? Boolean(options3.parseAtrulePrelude) : true;
          parser2.parseRulePrelude = "parseRulePrelude" in options3 ? Boolean(options3.parseRulePrelude) : true;
          parser2.parseValue = "parseValue" in options3 ? Boolean(options3.parseValue) : true;
          parser2.parseCustomProperty = "parseCustomProperty" in options3 ? Boolean(options3.parseCustomProperty) : false;
          if (!parser2.context.hasOwnProperty(context)) {
            throw new Error("Unknown context `" + context + "`");
          }
          if (typeof onComment === "function") {
            parser2.scanner.forEachToken((type, start, end) => {
              if (type === COMMENT$2) {
                const loc = parser2.getLocation(start, end);
                const value2 = cmpStr$3(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
                onComment(value2, loc);
              }
            });
          }
          ast = parser2.context[context].call(parser2, options3);
          if (!parser2.scanner.eof) {
            parser2.error();
          }
          return ast;
        };
      };
      var cmpChar$1 = tokenizer.cmpChar;
      var cmpStr$4 = tokenizer.cmpStr;
      var TYPE$5 = tokenizer.TYPE;
      var IDENT$1 = TYPE$5.Ident;
      var STRING = TYPE$5.String;
      var NUMBER$1 = TYPE$5.Number;
      var FUNCTION$1 = TYPE$5.Function;
      var URL$2 = TYPE$5.Url;
      var HASH$1 = TYPE$5.Hash;
      var DIMENSION = TYPE$5.Dimension;
      var PERCENTAGE$1 = TYPE$5.Percentage;
      var LEFTPARENTHESIS = TYPE$5.LeftParenthesis;
      var LEFTSQUAREBRACKET = TYPE$5.LeftSquareBracket;
      var COMMA = TYPE$5.Comma;
      var DELIM = TYPE$5.Delim;
      var NUMBERSIGN$1 = 35;
      var ASTERISK = 42;
      var PLUSSIGN = 43;
      var HYPHENMINUS = 45;
      var SOLIDUS = 47;
      var U = 117;
      var _default = function defaultRecognizer(context) {
        switch (this.scanner.tokenType) {
          case HASH$1:
            return this.Hash();
          case COMMA:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Operator();
          case LEFTPARENTHESIS:
            return this.Parentheses(this.readSequence, context.recognizer);
          case LEFTSQUAREBRACKET:
            return this.Brackets(this.readSequence, context.recognizer);
          case STRING:
            return this.String();
          case DIMENSION:
            return this.Dimension();
          case PERCENTAGE$1:
            return this.Percentage();
          case NUMBER$1:
            return this.Number();
          case FUNCTION$1:
            return cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
          case URL$2:
            return this.Url();
          case IDENT$1:
            if (cmpChar$1(this.scanner.source, this.scanner.tokenStart, U) && cmpChar$1(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
              return this.UnicodeRange();
            } else {
              return this.Identifier();
            }
          case DELIM:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS) {
              return this.Operator();
            }
            if (code === NUMBERSIGN$1) {
              this.error("Hex or identifier is expected", this.scanner.tokenStart + 1);
            }
            break;
        }
      };
      var atrulePrelude = {
        getNode: _default
      };
      var TYPE$6 = tokenizer.TYPE;
      var DELIM$1 = TYPE$6.Delim;
      var IDENT$2 = TYPE$6.Ident;
      var DIMENSION$1 = TYPE$6.Dimension;
      var PERCENTAGE$2 = TYPE$6.Percentage;
      var NUMBER$2 = TYPE$6.Number;
      var HASH$2 = TYPE$6.Hash;
      var COLON = TYPE$6.Colon;
      var LEFTSQUAREBRACKET$1 = TYPE$6.LeftSquareBracket;
      var NUMBERSIGN$2 = 35;
      var ASTERISK$1 = 42;
      var PLUSSIGN$1 = 43;
      var SOLIDUS$1 = 47;
      var FULLSTOP = 46;
      var GREATERTHANSIGN = 62;
      var VERTICALLINE = 124;
      var TILDE = 126;
      function getNode(context) {
        switch (this.scanner.tokenType) {
          case LEFTSQUAREBRACKET$1:
            return this.AttributeSelector();
          case HASH$2:
            return this.IdSelector();
          case COLON:
            if (this.scanner.lookupType(1) === COLON) {
              return this.PseudoElementSelector();
            } else {
              return this.PseudoClassSelector();
            }
          case IDENT$2:
            return this.TypeSelector();
          case NUMBER$2:
          case PERCENTAGE$2:
            return this.Percentage();
          case DIMENSION$1:
            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
              this.error("Identifier is expected", this.scanner.tokenStart + 1);
            }
            break;
          case DELIM$1:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            switch (code) {
              case PLUSSIGN$1:
              case GREATERTHANSIGN:
              case TILDE:
                context.space = null;
                context.ignoreWSAfter = true;
                return this.Combinator();
              case SOLIDUS$1:
                return this.Combinator();
              case FULLSTOP:
                return this.ClassSelector();
              case ASTERISK$1:
              case VERTICALLINE:
                return this.TypeSelector();
              case NUMBERSIGN$2:
                return this.IdSelector();
            }
            break;
        }
      }
      var selector = {
        getNode
      };
      var expression = function() {
        return this.createSingleNodeList(this.Raw(this.scanner.tokenIndex, null, false));
      };
      var TYPE$7 = tokenizer.TYPE;
      var WhiteSpace = TYPE$7.WhiteSpace;
      var Semicolon = TYPE$7.Semicolon;
      var LeftCurlyBracket = TYPE$7.LeftCurlyBracket;
      var Delim = TYPE$7.Delim;
      var EXCLAMATIONMARK = 33;
      function getOffsetExcludeWS() {
        if (this.scanner.tokenIndex > 0) {
          if (this.scanner.lookupType(-1) === WhiteSpace) {
            return this.scanner.tokenIndex > 1 ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1) : this.scanner.firstCharOffset;
          }
        }
        return this.scanner.tokenStart;
      }
      function balanceEnd() {
        return 0;
      }
      function leftCurlyBracket(tokenType) {
        return tokenType === LeftCurlyBracket ? 1 : 0;
      }
      function leftCurlyBracketOrSemicolon(tokenType) {
        return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
      }
      function exclamationMarkOrSemicolon(tokenType, source, offset) {
        if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {
          return 1;
        }
        return tokenType === Semicolon ? 1 : 0;
      }
      function semicolonIncluded(tokenType) {
        return tokenType === Semicolon ? 2 : 0;
      }
      var Raw = {
        name: "Raw",
        structure: {
          value: String
        },
        parse: function(startToken, mode, excludeWhiteSpace) {
          var startOffset = this.scanner.getTokenStart(startToken);
          var endOffset;
          this.scanner.skip(this.scanner.getRawLength(startToken, mode || balanceEnd));
          if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
            endOffset = getOffsetExcludeWS.call(this);
          } else {
            endOffset = this.scanner.tokenStart;
          }
          return {
            type: "Raw",
            loc: this.getLocation(startOffset, endOffset),
            value: this.scanner.source.substring(startOffset, endOffset)
          };
        },
        generate: function(node2) {
          this.chunk(node2.value);
        },
        mode: {
          default: balanceEnd,
          leftCurlyBracket,
          leftCurlyBracketOrSemicolon,
          exclamationMarkOrSemicolon,
          semicolonIncluded
        }
      };
      var TYPE$8 = tokenizer.TYPE;
      var rawMode = Raw.mode;
      var COMMA$1 = TYPE$8.Comma;
      var WHITESPACE$3 = TYPE$8.WhiteSpace;
      var _var = function() {
        var children = this.createList();
        this.scanner.skipSC();
        children.push(this.Identifier());
        this.scanner.skipSC();
        if (this.scanner.tokenType === COMMA$1) {
          children.push(this.Operator());
          const startIndex = this.scanner.tokenIndex;
          const value2 = this.parseCustomProperty ? this.Value(null) : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false);
          if (value2.type === "Value" && value2.children.isEmpty()) {
            for (let offset = startIndex - this.scanner.tokenIndex; offset <= 0; offset++) {
              if (this.scanner.lookupType(offset) === WHITESPACE$3) {
                value2.children.appendData({
                  type: "WhiteSpace",
                  loc: null,
                  value: " "
                });
                break;
              }
            }
          }
          children.push(value2);
        }
        return children;
      };
      var value = {
        getNode: _default,
        "expression": expression,
        "var": _var
      };
      var scope = {
        AtrulePrelude: atrulePrelude,
        Selector: selector,
        Value: value
      };
      var fontFace = {
        parse: {
          prelude: null,
          block: function() {
            return this.Block(true);
          }
        }
      };
      var TYPE$9 = tokenizer.TYPE;
      var STRING$1 = TYPE$9.String;
      var IDENT$3 = TYPE$9.Ident;
      var URL$3 = TYPE$9.Url;
      var FUNCTION$2 = TYPE$9.Function;
      var LEFTPARENTHESIS$1 = TYPE$9.LeftParenthesis;
      var _import = {
        parse: {
          prelude: function() {
            var children = this.createList();
            this.scanner.skipSC();
            switch (this.scanner.tokenType) {
              case STRING$1:
                children.push(this.String());
                break;
              case URL$3:
              case FUNCTION$2:
                children.push(this.Url());
                break;
              default:
                this.error("String or url() is expected");
            }
            if (this.lookupNonWSType(0) === IDENT$3 || this.lookupNonWSType(0) === LEFTPARENTHESIS$1) {
              children.push(this.WhiteSpace());
              children.push(this.MediaQueryList());
            }
            return children;
          },
          block: null
        }
      };
      var media = {
        parse: {
          prelude: function() {
            return this.createSingleNodeList(this.MediaQueryList());
          },
          block: function() {
            return this.Block(false);
          }
        }
      };
      var page = {
        parse: {
          prelude: function() {
            return this.createSingleNodeList(this.SelectorList());
          },
          block: function() {
            return this.Block(true);
          }
        }
      };
      var TYPE$a = tokenizer.TYPE;
      var WHITESPACE$4 = TYPE$a.WhiteSpace;
      var COMMENT$3 = TYPE$a.Comment;
      var IDENT$4 = TYPE$a.Ident;
      var FUNCTION$3 = TYPE$a.Function;
      var COLON$1 = TYPE$a.Colon;
      var LEFTPARENTHESIS$2 = TYPE$a.LeftParenthesis;
      function consumeRaw() {
        return this.createSingleNodeList(this.Raw(this.scanner.tokenIndex, null, false));
      }
      function parentheses() {
        this.scanner.skipSC();
        if (this.scanner.tokenType === IDENT$4 && this.lookupNonWSType(1) === COLON$1) {
          return this.createSingleNodeList(this.Declaration());
        }
        return readSequence.call(this);
      }
      function readSequence() {
        var children = this.createList();
        var space = null;
        var child;
        this.scanner.skipSC();
        scan:
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case WHITESPACE$4:
                space = this.WhiteSpace();
                continue;
              case COMMENT$3:
                this.scanner.next();
                continue;
              case FUNCTION$3:
                child = this.Function(consumeRaw, this.scope.AtrulePrelude);
                break;
              case IDENT$4:
                child = this.Identifier();
                break;
              case LEFTPARENTHESIS$2:
                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                break;
              default:
                break scan;
            }
            if (space !== null) {
              children.push(space);
              space = null;
            }
            children.push(child);
          }
        return children;
      }
      var supports = {
        parse: {
          prelude: function() {
            var children = readSequence.call(this);
            if (this.getFirstListNode(children) === null) {
              this.error("Condition is expected");
            }
            return children;
          },
          block: function() {
            return this.Block(false);
          }
        }
      };
      var atrule = {
        "font-face": fontFace,
        "import": _import,
        "media": media,
        "page": page,
        "supports": supports
      };
      var dir = {
        parse: function() {
          return this.createSingleNodeList(this.Identifier());
        }
      };
      var has$1 = {
        parse: function() {
          return this.createSingleNodeList(this.SelectorList());
        }
      };
      var lang = {
        parse: function() {
          return this.createSingleNodeList(this.Identifier());
        }
      };
      var selectorList = {
        parse: function selectorList2() {
          return this.createSingleNodeList(this.SelectorList());
        }
      };
      var matches = selectorList;
      var not = selectorList;
      var ALLOW_OF_CLAUSE = true;
      var nthWithOfClause = {
        parse: function nthWithOfClause2() {
          return this.createSingleNodeList(this.Nth(ALLOW_OF_CLAUSE));
        }
      };
      var nthChild = nthWithOfClause;
      var nthLastChild = nthWithOfClause;
      var DISALLOW_OF_CLAUSE = false;
      var nth = {
        parse: function nth2() {
          return this.createSingleNodeList(this.Nth(DISALLOW_OF_CLAUSE));
        }
      };
      var nthLastOfType = nth;
      var nthOfType = nth;
      var slotted = {
        parse: function compoundSelector() {
          return this.createSingleNodeList(this.Selector());
        }
      };
      var pseudo = {
        "dir": dir,
        "has": has$1,
        "lang": lang,
        "matches": matches,
        "not": not,
        "nth-child": nthChild,
        "nth-last-child": nthLastChild,
        "nth-last-of-type": nthLastOfType,
        "nth-of-type": nthOfType,
        "slotted": slotted
      };
      var cmpChar$2 = tokenizer.cmpChar;
      var isDigit$2 = tokenizer.isDigit;
      var TYPE$b = tokenizer.TYPE;
      var WHITESPACE$5 = TYPE$b.WhiteSpace;
      var COMMENT$4 = TYPE$b.Comment;
      var IDENT$5 = TYPE$b.Ident;
      var NUMBER$3 = TYPE$b.Number;
      var DIMENSION$2 = TYPE$b.Dimension;
      var PLUSSIGN$2 = 43;
      var HYPHENMINUS$1 = 45;
      var N$1 = 110;
      var DISALLOW_SIGN = true;
      var ALLOW_SIGN = false;
      function checkInteger(offset, disallowSign) {
        var pos = this.scanner.tokenStart + offset;
        var code = this.scanner.source.charCodeAt(pos);
        if (code === PLUSSIGN$2 || code === HYPHENMINUS$1) {
          if (disallowSign) {
            this.error("Number sign is not allowed");
          }
          pos++;
        }
        for (; pos < this.scanner.tokenEnd; pos++) {
          if (!isDigit$2(this.scanner.source.charCodeAt(pos))) {
            this.error("Integer is expected", pos);
          }
        }
      }
      function checkTokenIsInteger(disallowSign) {
        return checkInteger.call(this, 0, disallowSign);
      }
      function expectCharCode(offset, code) {
        if (!cmpChar$2(this.scanner.source, this.scanner.tokenStart + offset, code)) {
          var msg = "";
          switch (code) {
            case N$1:
              msg = "N is expected";
              break;
            case HYPHENMINUS$1:
              msg = "HyphenMinus is expected";
              break;
          }
          this.error(msg, this.scanner.tokenStart + offset);
        }
      }
      function consumeB() {
        var offset = 0;
        var sign = 0;
        var type = this.scanner.tokenType;
        while (type === WHITESPACE$5 || type === COMMENT$4) {
          type = this.scanner.lookupType(++offset);
        }
        if (type !== NUMBER$3) {
          if (this.scanner.isDelim(PLUSSIGN$2, offset) || this.scanner.isDelim(HYPHENMINUS$1, offset)) {
            sign = this.scanner.isDelim(PLUSSIGN$2, offset) ? PLUSSIGN$2 : HYPHENMINUS$1;
            do {
              type = this.scanner.lookupType(++offset);
            } while (type === WHITESPACE$5 || type === COMMENT$4);
            if (type !== NUMBER$3) {
              this.scanner.skip(offset);
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
            }
          } else {
            return null;
          }
        }
        if (offset > 0) {
          this.scanner.skip(offset);
        }
        if (sign === 0) {
          type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          if (type !== PLUSSIGN$2 && type !== HYPHENMINUS$1) {
            this.error("Number sign is expected");
          }
        }
        checkTokenIsInteger.call(this, sign !== 0);
        return sign === HYPHENMINUS$1 ? "-" + this.consume(NUMBER$3) : this.consume(NUMBER$3);
      }
      var AnPlusB = {
        name: "AnPlusB",
        structure: {
          a: [String, null],
          b: [String, null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var a = null;
          var b2 = null;
          if (this.scanner.tokenType === NUMBER$3) {
            checkTokenIsInteger.call(this, ALLOW_SIGN);
            b2 = this.consume(NUMBER$3);
          } else if (this.scanner.tokenType === IDENT$5 && cmpChar$2(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$1)) {
            a = "-1";
            expectCharCode.call(this, 1, N$1);
            switch (this.scanner.getTokenLength()) {
              case 2:
                this.scanner.next();
                b2 = consumeB.call(this);
                break;
              case 3:
                expectCharCode.call(this, 2, HYPHENMINUS$1);
                this.scanner.next();
                this.scanner.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b2 = "-" + this.consume(NUMBER$3);
                break;
              default:
                expectCharCode.call(this, 2, HYPHENMINUS$1);
                checkInteger.call(this, 3, DISALLOW_SIGN);
                this.scanner.next();
                b2 = this.scanner.substrToCursor(start + 2);
            }
          } else if (this.scanner.tokenType === IDENT$5 || this.scanner.isDelim(PLUSSIGN$2) && this.scanner.lookupType(1) === IDENT$5) {
            var sign = 0;
            a = "1";
            if (this.scanner.isDelim(PLUSSIGN$2)) {
              sign = 1;
              this.scanner.next();
            }
            expectCharCode.call(this, 0, N$1);
            switch (this.scanner.getTokenLength()) {
              case 1:
                this.scanner.next();
                b2 = consumeB.call(this);
                break;
              case 2:
                expectCharCode.call(this, 1, HYPHENMINUS$1);
                this.scanner.next();
                this.scanner.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b2 = "-" + this.consume(NUMBER$3);
                break;
              default:
                expectCharCode.call(this, 1, HYPHENMINUS$1);
                checkInteger.call(this, 2, DISALLOW_SIGN);
                this.scanner.next();
                b2 = this.scanner.substrToCursor(start + sign + 1);
            }
          } else if (this.scanner.tokenType === DIMENSION$2) {
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            var sign = code === PLUSSIGN$2 || code === HYPHENMINUS$1;
            for (var i2 = this.scanner.tokenStart + sign; i2 < this.scanner.tokenEnd; i2++) {
              if (!isDigit$2(this.scanner.source.charCodeAt(i2))) {
                break;
              }
            }
            if (i2 === this.scanner.tokenStart + sign) {
              this.error("Integer is expected", this.scanner.tokenStart + sign);
            }
            expectCharCode.call(this, i2 - this.scanner.tokenStart, N$1);
            a = this.scanner.source.substring(start, i2);
            if (i2 + 1 === this.scanner.tokenEnd) {
              this.scanner.next();
              b2 = consumeB.call(this);
            } else {
              expectCharCode.call(this, i2 - this.scanner.tokenStart + 1, HYPHENMINUS$1);
              if (i2 + 2 === this.scanner.tokenEnd) {
                this.scanner.next();
                this.scanner.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b2 = "-" + this.consume(NUMBER$3);
              } else {
                checkInteger.call(this, i2 - this.scanner.tokenStart + 2, DISALLOW_SIGN);
                this.scanner.next();
                b2 = this.scanner.substrToCursor(i2 + 1);
              }
            }
          } else {
            this.error();
          }
          if (a !== null && a.charCodeAt(0) === PLUSSIGN$2) {
            a = a.substr(1);
          }
          if (b2 !== null && b2.charCodeAt(0) === PLUSSIGN$2) {
            b2 = b2.substr(1);
          }
          return {
            type: "AnPlusB",
            loc: this.getLocation(start, this.scanner.tokenStart),
            a,
            b: b2
          };
        },
        generate: function(node2) {
          var a = node2.a !== null && node2.a !== void 0;
          var b2 = node2.b !== null && node2.b !== void 0;
          if (a) {
            this.chunk(node2.a === "+1" ? "+n" : node2.a === "1" ? "n" : node2.a === "-1" ? "-n" : node2.a + "n");
            if (b2) {
              b2 = String(node2.b);
              if (b2.charAt(0) === "-" || b2.charAt(0) === "+") {
                this.chunk(b2.charAt(0));
                this.chunk(b2.substr(1));
              } else {
                this.chunk("+");
                this.chunk(b2);
              }
            }
          } else {
            this.chunk(String(node2.b));
          }
        }
      };
      var TYPE$c = tokenizer.TYPE;
      var rawMode$1 = Raw.mode;
      var ATKEYWORD = TYPE$c.AtKeyword;
      var SEMICOLON = TYPE$c.Semicolon;
      var LEFTCURLYBRACKET = TYPE$c.LeftCurlyBracket;
      var RIGHTCURLYBRACKET = TYPE$c.RightCurlyBracket;
      function consumeRaw$1(startToken) {
        return this.Raw(startToken, rawMode$1.leftCurlyBracketOrSemicolon, true);
      }
      function isDeclarationBlockAtrule() {
        for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
          if (type === RIGHTCURLYBRACKET) {
            return true;
          }
          if (type === LEFTCURLYBRACKET || type === ATKEYWORD) {
            return false;
          }
        }
        return false;
      }
      var Atrule = {
        name: "Atrule",
        structure: {
          name: String,
          prelude: ["AtrulePrelude", "Raw", null],
          block: ["Block", null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var name;
          var nameLowerCase;
          var prelude = null;
          var block = null;
          this.eat(ATKEYWORD);
          name = this.scanner.substrToCursor(start + 1);
          nameLowerCase = name.toLowerCase();
          this.scanner.skipSC();
          if (this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
            if (this.parseAtrulePrelude) {
              prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw$1);
              if (prelude.type === "AtrulePrelude" && prelude.children.head === null) {
                prelude = null;
              }
            } else {
              prelude = consumeRaw$1.call(this, this.scanner.tokenIndex);
            }
            this.scanner.skipSC();
          }
          switch (this.scanner.tokenType) {
            case SEMICOLON:
              this.scanner.next();
              break;
            case LEFTCURLYBRACKET:
              if (this.atrule.hasOwnProperty(nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
                block = this.atrule[nameLowerCase].block.call(this);
              } else {
                block = this.Block(isDeclarationBlockAtrule.call(this));
              }
              break;
          }
          return {
            type: "Atrule",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            prelude,
            block
          };
        },
        generate: function(node2) {
          this.chunk("@");
          this.chunk(node2.name);
          if (node2.prelude !== null) {
            this.chunk(" ");
            this.node(node2.prelude);
          }
          if (node2.block) {
            this.node(node2.block);
          } else {
            this.chunk(";");
          }
        },
        walkContext: "atrule"
      };
      var TYPE$d = tokenizer.TYPE;
      var SEMICOLON$1 = TYPE$d.Semicolon;
      var LEFTCURLYBRACKET$1 = TYPE$d.LeftCurlyBracket;
      var AtrulePrelude = {
        name: "AtrulePrelude",
        structure: {
          children: [[]]
        },
        parse: function(name) {
          var children = null;
          if (name !== null) {
            name = name.toLowerCase();
          }
          this.scanner.skipSC();
          if (this.atrule.hasOwnProperty(name) && typeof this.atrule[name].prelude === "function") {
            children = this.atrule[name].prelude.call(this);
          } else {
            children = this.readSequence(this.scope.AtrulePrelude);
          }
          this.scanner.skipSC();
          if (this.scanner.eof !== true && this.scanner.tokenType !== LEFTCURLYBRACKET$1 && this.scanner.tokenType !== SEMICOLON$1) {
            this.error("Semicolon or block is expected");
          }
          if (children === null) {
            children = this.createList();
          }
          return {
            type: "AtrulePrelude",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node2) {
          this.children(node2);
        },
        walkContext: "atrulePrelude"
      };
      var TYPE$e = tokenizer.TYPE;
      var IDENT$6 = TYPE$e.Ident;
      var STRING$2 = TYPE$e.String;
      var COLON$2 = TYPE$e.Colon;
      var LEFTSQUAREBRACKET$2 = TYPE$e.LeftSquareBracket;
      var RIGHTSQUAREBRACKET = TYPE$e.RightSquareBracket;
      var DOLLARSIGN = 36;
      var ASTERISK$2 = 42;
      var EQUALSSIGN = 61;
      var CIRCUMFLEXACCENT = 94;
      var VERTICALLINE$1 = 124;
      var TILDE$1 = 126;
      function getAttributeName() {
        if (this.scanner.eof) {
          this.error("Unexpected end of input");
        }
        var start = this.scanner.tokenStart;
        var expectIdent = false;
        var checkColon = true;
        if (this.scanner.isDelim(ASTERISK$2)) {
          expectIdent = true;
          checkColon = false;
          this.scanner.next();
        } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
          this.eat(IDENT$6);
        }
        if (this.scanner.isDelim(VERTICALLINE$1)) {
          if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
            this.scanner.next();
            this.eat(IDENT$6);
          } else if (expectIdent) {
            this.error("Identifier is expected", this.scanner.tokenEnd);
          }
        } else if (expectIdent) {
          this.error("Vertical line is expected");
        }
        if (checkColon && this.scanner.tokenType === COLON$2) {
          this.scanner.next();
          this.eat(IDENT$6);
        }
        return {
          type: "Identifier",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name: this.scanner.substrToCursor(start)
        };
      }
      function getOperator() {
        var start = this.scanner.tokenStart;
        var code = this.scanner.source.charCodeAt(start);
        if (code !== EQUALSSIGN && code !== TILDE$1 && code !== CIRCUMFLEXACCENT && code !== DOLLARSIGN && code !== ASTERISK$2 && code !== VERTICALLINE$1) {
          this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
        }
        this.scanner.next();
        if (code !== EQUALSSIGN) {
          if (!this.scanner.isDelim(EQUALSSIGN)) {
            this.error("Equal sign is expected");
          }
          this.scanner.next();
        }
        return this.scanner.substrToCursor(start);
      }
      var AttributeSelector = {
        name: "AttributeSelector",
        structure: {
          name: "Identifier",
          matcher: [String, null],
          value: ["String", "Identifier", null],
          flags: [String, null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var name;
          var matcher = null;
          var value2 = null;
          var flags = null;
          this.eat(LEFTSQUAREBRACKET$2);
          this.scanner.skipSC();
          name = getAttributeName.call(this);
          this.scanner.skipSC();
          if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
            if (this.scanner.tokenType !== IDENT$6) {
              matcher = getOperator.call(this);
              this.scanner.skipSC();
              value2 = this.scanner.tokenType === STRING$2 ? this.String() : this.Identifier();
              this.scanner.skipSC();
            }
            if (this.scanner.tokenType === IDENT$6) {
              flags = this.scanner.getTokenValue();
              this.scanner.next();
              this.scanner.skipSC();
            }
          }
          this.eat(RIGHTSQUAREBRACKET);
          return {
            type: "AttributeSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            matcher,
            value: value2,
            flags
          };
        },
        generate: function(node2) {
          var flagsPrefix = " ";
          this.chunk("[");
          this.node(node2.name);
          if (node2.matcher !== null) {
            this.chunk(node2.matcher);
            if (node2.value !== null) {
              this.node(node2.value);
              if (node2.value.type === "String") {
                flagsPrefix = "";
              }
            }
          }
          if (node2.flags !== null) {
            this.chunk(flagsPrefix);
            this.chunk(node2.flags);
          }
          this.chunk("]");
        }
      };
      var TYPE$f = tokenizer.TYPE;
      var rawMode$2 = Raw.mode;
      var WHITESPACE$6 = TYPE$f.WhiteSpace;
      var COMMENT$5 = TYPE$f.Comment;
      var SEMICOLON$2 = TYPE$f.Semicolon;
      var ATKEYWORD$1 = TYPE$f.AtKeyword;
      var LEFTCURLYBRACKET$2 = TYPE$f.LeftCurlyBracket;
      var RIGHTCURLYBRACKET$1 = TYPE$f.RightCurlyBracket;
      function consumeRaw$2(startToken) {
        return this.Raw(startToken, null, true);
      }
      function consumeRule() {
        return this.parseWithFallback(this.Rule, consumeRaw$2);
      }
      function consumeRawDeclaration(startToken) {
        return this.Raw(startToken, rawMode$2.semicolonIncluded, true);
      }
      function consumeDeclaration() {
        if (this.scanner.tokenType === SEMICOLON$2) {
          return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
        }
        var node2 = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
        if (this.scanner.tokenType === SEMICOLON$2) {
          this.scanner.next();
        }
        return node2;
      }
      var Block = {
        name: "Block",
        structure: {
          children: [[
            "Atrule",
            "Rule",
            "Declaration"
          ]]
        },
        parse: function(isDeclaration) {
          var consumer = isDeclaration ? consumeDeclaration : consumeRule;
          var start = this.scanner.tokenStart;
          var children = this.createList();
          this.eat(LEFTCURLYBRACKET$2);
          scan:
            while (!this.scanner.eof) {
              switch (this.scanner.tokenType) {
                case RIGHTCURLYBRACKET$1:
                  break scan;
                case WHITESPACE$6:
                case COMMENT$5:
                  this.scanner.next();
                  break;
                case ATKEYWORD$1:
                  children.push(this.parseWithFallback(this.Atrule, consumeRaw$2));
                  break;
                default:
                  children.push(consumer.call(this));
              }
            }
          if (!this.scanner.eof) {
            this.eat(RIGHTCURLYBRACKET$1);
          }
          return {
            type: "Block",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children
          };
        },
        generate: function(node2) {
          this.chunk("{");
          this.children(node2, function(prev) {
            if (prev.type === "Declaration") {
              this.chunk(";");
            }
          });
          this.chunk("}");
        },
        walkContext: "block"
      };
      var TYPE$g = tokenizer.TYPE;
      var LEFTSQUAREBRACKET$3 = TYPE$g.LeftSquareBracket;
      var RIGHTSQUAREBRACKET$1 = TYPE$g.RightSquareBracket;
      var Brackets = {
        name: "Brackets",
        structure: {
          children: [[]]
        },
        parse: function(readSequence2, recognizer) {
          var start = this.scanner.tokenStart;
          var children = null;
          this.eat(LEFTSQUAREBRACKET$3);
          children = readSequence2.call(this, recognizer);
          if (!this.scanner.eof) {
            this.eat(RIGHTSQUAREBRACKET$1);
          }
          return {
            type: "Brackets",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children
          };
        },
        generate: function(node2) {
          this.chunk("[");
          this.children(node2);
          this.chunk("]");
        }
      };
      var CDC = tokenizer.TYPE.CDC;
      var CDC_1 = {
        name: "CDC",
        structure: [],
        parse: function() {
          var start = this.scanner.tokenStart;
          this.eat(CDC);
          return {
            type: "CDC",
            loc: this.getLocation(start, this.scanner.tokenStart)
          };
        },
        generate: function() {
          this.chunk("-->");
        }
      };
      var CDO = tokenizer.TYPE.CDO;
      var CDO_1 = {
        name: "CDO",
        structure: [],
        parse: function() {
          var start = this.scanner.tokenStart;
          this.eat(CDO);
          return {
            type: "CDO",
            loc: this.getLocation(start, this.scanner.tokenStart)
          };
        },
        generate: function() {
          this.chunk("<!--");
        }
      };
      var TYPE$h = tokenizer.TYPE;
      var IDENT$7 = TYPE$h.Ident;
      var FULLSTOP$1 = 46;
      var ClassSelector = {
        name: "ClassSelector",
        structure: {
          name: String
        },
        parse: function() {
          if (!this.scanner.isDelim(FULLSTOP$1)) {
            this.error("Full stop is expected");
          }
          this.scanner.next();
          return {
            type: "ClassSelector",
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.consume(IDENT$7)
          };
        },
        generate: function(node2) {
          this.chunk(".");
          this.chunk(node2.name);
        }
      };
      var TYPE$i = tokenizer.TYPE;
      var IDENT$8 = TYPE$i.Ident;
      var PLUSSIGN$3 = 43;
      var SOLIDUS$2 = 47;
      var GREATERTHANSIGN$1 = 62;
      var TILDE$2 = 126;
      var Combinator = {
        name: "Combinator",
        structure: {
          name: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          switch (code) {
            case GREATERTHANSIGN$1:
            case PLUSSIGN$3:
            case TILDE$2:
              this.scanner.next();
              break;
            case SOLIDUS$2:
              this.scanner.next();
              if (this.scanner.tokenType !== IDENT$8 || this.scanner.lookupValue(0, "deep") === false) {
                this.error("Identifier `deep` is expected");
              }
              this.scanner.next();
              if (!this.scanner.isDelim(SOLIDUS$2)) {
                this.error("Solidus is expected");
              }
              this.scanner.next();
              break;
            default:
              this.error("Combinator is expected");
          }
          return {
            type: "Combinator",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
          };
        },
        generate: function(node2) {
          this.chunk(node2.name);
        }
      };
      var TYPE$j = tokenizer.TYPE;
      var COMMENT$6 = TYPE$j.Comment;
      var ASTERISK$3 = 42;
      var SOLIDUS$3 = 47;
      var Comment = {
        name: "Comment",
        structure: {
          value: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var end = this.scanner.tokenEnd;
          this.eat(COMMENT$6);
          if (end - start + 2 >= 2 && this.scanner.source.charCodeAt(end - 2) === ASTERISK$3 && this.scanner.source.charCodeAt(end - 1) === SOLIDUS$3) {
            end -= 2;
          }
          return {
            type: "Comment",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start + 2, end)
          };
        },
        generate: function(node2) {
          this.chunk("/*");
          this.chunk(node2.value);
          this.chunk("*/");
        }
      };
      var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
      var keywords$2 = Object.create(null);
      var properties = Object.create(null);
      var HYPHENMINUS$2 = 45;
      function isCustomProperty(str2, offset) {
        offset = offset || 0;
        return str2.length - offset >= 2 && str2.charCodeAt(offset) === HYPHENMINUS$2 && str2.charCodeAt(offset + 1) === HYPHENMINUS$2;
      }
      function getVendorPrefix(str2, offset) {
        offset = offset || 0;
        if (str2.length - offset >= 3) {
          if (str2.charCodeAt(offset) === HYPHENMINUS$2 && str2.charCodeAt(offset + 1) !== HYPHENMINUS$2) {
            var secondDashIndex = str2.indexOf("-", offset + 2);
            if (secondDashIndex !== -1) {
              return str2.substring(offset, secondDashIndex + 1);
            }
          }
        }
        return "";
      }
      function getKeywordDescriptor(keyword) {
        if (hasOwnProperty$1.call(keywords$2, keyword)) {
          return keywords$2[keyword];
        }
        var name = keyword.toLowerCase();
        if (hasOwnProperty$1.call(keywords$2, name)) {
          return keywords$2[keyword] = keywords$2[name];
        }
        var custom = isCustomProperty(name, 0);
        var vendor = !custom ? getVendorPrefix(name, 0) : "";
        return keywords$2[keyword] = Object.freeze({
          basename: name.substr(vendor.length),
          name,
          vendor,
          prefix: vendor,
          custom
        });
      }
      function getPropertyDescriptor(property) {
        if (hasOwnProperty$1.call(properties, property)) {
          return properties[property];
        }
        var name = property;
        var hack = property[0];
        if (hack === "/") {
          hack = property[1] === "/" ? "//" : "/";
        } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
          hack = "";
        }
        var custom = isCustomProperty(name, hack.length);
        if (!custom) {
          name = name.toLowerCase();
          if (hasOwnProperty$1.call(properties, name)) {
            return properties[property] = properties[name];
          }
        }
        var vendor = !custom ? getVendorPrefix(name, hack.length) : "";
        var prefix = name.substr(0, hack.length + vendor.length);
        return properties[property] = Object.freeze({
          basename: name.substr(prefix.length),
          name: name.substr(hack.length),
          hack,
          vendor,
          prefix,
          custom
        });
      }
      var names = {
        keyword: getKeywordDescriptor,
        property: getPropertyDescriptor,
        isCustomProperty,
        vendorPrefix: getVendorPrefix
      };
      var isCustomProperty$1 = names.isCustomProperty;
      var TYPE$k = tokenizer.TYPE;
      var rawMode$3 = Raw.mode;
      var IDENT$9 = TYPE$k.Ident;
      var HASH$3 = TYPE$k.Hash;
      var COLON$3 = TYPE$k.Colon;
      var SEMICOLON$3 = TYPE$k.Semicolon;
      var DELIM$2 = TYPE$k.Delim;
      var WHITESPACE$7 = TYPE$k.WhiteSpace;
      var EXCLAMATIONMARK$1 = 33;
      var NUMBERSIGN$3 = 35;
      var DOLLARSIGN$1 = 36;
      var AMPERSAND = 38;
      var ASTERISK$4 = 42;
      var PLUSSIGN$4 = 43;
      var SOLIDUS$4 = 47;
      function consumeValueRaw(startToken) {
        return this.Raw(startToken, rawMode$3.exclamationMarkOrSemicolon, true);
      }
      function consumeCustomPropertyRaw(startToken) {
        return this.Raw(startToken, rawMode$3.exclamationMarkOrSemicolon, false);
      }
      function consumeValue() {
        var startValueToken = this.scanner.tokenIndex;
        var value2 = this.Value();
        if (value2.type !== "Raw" && this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON$3 && this.scanner.isDelim(EXCLAMATIONMARK$1) === false && this.scanner.isBalanceEdge(startValueToken) === false) {
          this.error();
        }
        return value2;
      }
      var Declaration = {
        name: "Declaration",
        structure: {
          important: [Boolean, String],
          property: String,
          value: ["Value", "Raw"]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var startToken = this.scanner.tokenIndex;
          var property = readProperty.call(this);
          var customProperty = isCustomProperty$1(property);
          var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
          var consumeRaw2 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
          var important = false;
          var value2;
          this.scanner.skipSC();
          this.eat(COLON$3);
          const valueStart = this.scanner.tokenIndex;
          if (!customProperty) {
            this.scanner.skipSC();
          }
          if (parseValue) {
            value2 = this.parseWithFallback(consumeValue, consumeRaw2);
          } else {
            value2 = consumeRaw2.call(this, this.scanner.tokenIndex);
          }
          if (customProperty && value2.type === "Value" && value2.children.isEmpty()) {
            for (let offset = valueStart - this.scanner.tokenIndex; offset <= 0; offset++) {
              if (this.scanner.lookupType(offset) === WHITESPACE$7) {
                value2.children.appendData({
                  type: "WhiteSpace",
                  loc: null,
                  value: " "
                });
                break;
              }
            }
          }
          if (this.scanner.isDelim(EXCLAMATIONMARK$1)) {
            important = getImportant.call(this);
            this.scanner.skipSC();
          }
          if (this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON$3 && this.scanner.isBalanceEdge(startToken) === false) {
            this.error();
          }
          return {
            type: "Declaration",
            loc: this.getLocation(start, this.scanner.tokenStart),
            important,
            property,
            value: value2
          };
        },
        generate: function(node2) {
          this.chunk(node2.property);
          this.chunk(":");
          this.node(node2.value);
          if (node2.important) {
            this.chunk(node2.important === true ? "!important" : "!" + node2.important);
          }
        },
        walkContext: "declaration"
      };
      function readProperty() {
        var start = this.scanner.tokenStart;
        if (this.scanner.tokenType === DELIM$2) {
          switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
            case ASTERISK$4:
            case DOLLARSIGN$1:
            case PLUSSIGN$4:
            case NUMBERSIGN$3:
            case AMPERSAND:
              this.scanner.next();
              break;
            case SOLIDUS$4:
              this.scanner.next();
              if (this.scanner.isDelim(SOLIDUS$4)) {
                this.scanner.next();
              }
              break;
          }
        }
        if (this.scanner.tokenType === HASH$3) {
          this.eat(HASH$3);
        } else {
          this.eat(IDENT$9);
        }
        return this.scanner.substrToCursor(start);
      }
      function getImportant() {
        this.eat(DELIM$2);
        this.scanner.skipSC();
        var important = this.consume(IDENT$9);
        return important === "important" ? true : important;
      }
      var TYPE$l = tokenizer.TYPE;
      var rawMode$4 = Raw.mode;
      var WHITESPACE$8 = TYPE$l.WhiteSpace;
      var COMMENT$7 = TYPE$l.Comment;
      var SEMICOLON$4 = TYPE$l.Semicolon;
      function consumeRaw$3(startToken) {
        return this.Raw(startToken, rawMode$4.semicolonIncluded, true);
      }
      var DeclarationList = {
        name: "DeclarationList",
        structure: {
          children: [[
            "Declaration"
          ]]
        },
        parse: function() {
          var children = this.createList();
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case WHITESPACE$8:
              case COMMENT$7:
              case SEMICOLON$4:
                this.scanner.next();
                break;
              default:
                children.push(this.parseWithFallback(this.Declaration, consumeRaw$3));
            }
          }
          return {
            type: "DeclarationList",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node2) {
          this.children(node2, function(prev) {
            if (prev.type === "Declaration") {
              this.chunk(";");
            }
          });
        }
      };
      var consumeNumber$2 = utils.consumeNumber;
      var TYPE$m = tokenizer.TYPE;
      var DIMENSION$3 = TYPE$m.Dimension;
      var Dimension = {
        name: "Dimension",
        structure: {
          value: String,
          unit: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var numberEnd = consumeNumber$2(this.scanner.source, start);
          this.eat(DIMENSION$3);
          return {
            type: "Dimension",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd),
            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
          };
        },
        generate: function(node2) {
          this.chunk(node2.value);
          this.chunk(node2.unit);
        }
      };
      var TYPE$n = tokenizer.TYPE;
      var RIGHTPARENTHESIS = TYPE$n.RightParenthesis;
      var _Function = {
        name: "Function",
        structure: {
          name: String,
          children: [[]]
        },
        parse: function(readSequence2, recognizer) {
          var start = this.scanner.tokenStart;
          var name = this.consumeFunctionName();
          var nameLowerCase = name.toLowerCase();
          var children;
          children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence2.call(this, recognizer);
          if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS);
          }
          return {
            type: "Function",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            children
          };
        },
        generate: function(node2) {
          this.chunk(node2.name);
          this.chunk("(");
          this.children(node2);
          this.chunk(")");
        },
        walkContext: "function"
      };
      var TYPE$o = tokenizer.TYPE;
      var HASH$4 = TYPE$o.Hash;
      var Hash = {
        name: "Hash",
        structure: {
          value: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          this.eat(HASH$4);
          return {
            type: "Hash",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start + 1)
          };
        },
        generate: function(node2) {
          this.chunk("#");
          this.chunk(node2.value);
        }
      };
      var TYPE$p = tokenizer.TYPE;
      var IDENT$a = TYPE$p.Ident;
      var Identifier = {
        name: "Identifier",
        structure: {
          name: String
        },
        parse: function() {
          return {
            type: "Identifier",
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            name: this.consume(IDENT$a)
          };
        },
        generate: function(node2) {
          this.chunk(node2.name);
        }
      };
      var TYPE$q = tokenizer.TYPE;
      var HASH$5 = TYPE$q.Hash;
      var IdSelector = {
        name: "IdSelector",
        structure: {
          name: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          this.eat(HASH$5);
          return {
            type: "IdSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start + 1)
          };
        },
        generate: function(node2) {
          this.chunk("#");
          this.chunk(node2.name);
        }
      };
      var TYPE$r = tokenizer.TYPE;
      var IDENT$b = TYPE$r.Ident;
      var NUMBER$4 = TYPE$r.Number;
      var DIMENSION$4 = TYPE$r.Dimension;
      var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;
      var RIGHTPARENTHESIS$1 = TYPE$r.RightParenthesis;
      var COLON$4 = TYPE$r.Colon;
      var DELIM$3 = TYPE$r.Delim;
      var MediaFeature = {
        name: "MediaFeature",
        structure: {
          name: String,
          value: ["Identifier", "Number", "Dimension", "Ratio", null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var name;
          var value2 = null;
          this.eat(LEFTPARENTHESIS$3);
          this.scanner.skipSC();
          name = this.consume(IDENT$b);
          this.scanner.skipSC();
          if (this.scanner.tokenType !== RIGHTPARENTHESIS$1) {
            this.eat(COLON$4);
            this.scanner.skipSC();
            switch (this.scanner.tokenType) {
              case NUMBER$4:
                if (this.lookupNonWSType(1) === DELIM$3) {
                  value2 = this.Ratio();
                } else {
                  value2 = this.Number();
                }
                break;
              case DIMENSION$4:
                value2 = this.Dimension();
                break;
              case IDENT$b:
                value2 = this.Identifier();
                break;
              default:
                this.error("Number, dimension, ratio or identifier is expected");
            }
            this.scanner.skipSC();
          }
          this.eat(RIGHTPARENTHESIS$1);
          return {
            type: "MediaFeature",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            value: value2
          };
        },
        generate: function(node2) {
          this.chunk("(");
          this.chunk(node2.name);
          if (node2.value !== null) {
            this.chunk(":");
            this.node(node2.value);
          }
          this.chunk(")");
        }
      };
      var TYPE$s = tokenizer.TYPE;
      var WHITESPACE$9 = TYPE$s.WhiteSpace;
      var COMMENT$8 = TYPE$s.Comment;
      var IDENT$c = TYPE$s.Ident;
      var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
      var MediaQuery = {
        name: "MediaQuery",
        structure: {
          children: [[
            "Identifier",
            "MediaFeature",
            "WhiteSpace"
          ]]
        },
        parse: function() {
          this.scanner.skipSC();
          var children = this.createList();
          var child = null;
          var space = null;
          scan:
            while (!this.scanner.eof) {
              switch (this.scanner.tokenType) {
                case COMMENT$8:
                  this.scanner.next();
                  continue;
                case WHITESPACE$9:
                  space = this.WhiteSpace();
                  continue;
                case IDENT$c:
                  child = this.Identifier();
                  break;
                case LEFTPARENTHESIS$4:
                  child = this.MediaFeature();
                  break;
                default:
                  break scan;
              }
              if (space !== null) {
                children.push(space);
                space = null;
              }
              children.push(child);
            }
          if (child === null) {
            this.error("Identifier or parenthesis is expected");
          }
          return {
            type: "MediaQuery",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node2) {
          this.children(node2);
        }
      };
      var COMMA$2 = tokenizer.TYPE.Comma;
      var MediaQueryList = {
        name: "MediaQueryList",
        structure: {
          children: [[
            "MediaQuery"
          ]]
        },
        parse: function(relative) {
          var children = this.createList();
          this.scanner.skipSC();
          while (!this.scanner.eof) {
            children.push(this.MediaQuery(relative));
            if (this.scanner.tokenType !== COMMA$2) {
              break;
            }
            this.scanner.next();
          }
          return {
            type: "MediaQueryList",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node2) {
          this.children(node2, function() {
            this.chunk(",");
          });
        }
      };
      var Nth = {
        name: "Nth",
        structure: {
          nth: ["AnPlusB", "Identifier"],
          selector: ["SelectorList", null]
        },
        parse: function(allowOfClause) {
          this.scanner.skipSC();
          var start = this.scanner.tokenStart;
          var end = start;
          var selector2 = null;
          var query;
          if (this.scanner.lookupValue(0, "odd") || this.scanner.lookupValue(0, "even")) {
            query = this.Identifier();
          } else {
            query = this.AnPlusB();
          }
          this.scanner.skipSC();
          if (allowOfClause && this.scanner.lookupValue(0, "of")) {
            this.scanner.next();
            selector2 = this.SelectorList();
            if (this.needPositions) {
              end = this.getLastListNode(selector2.children).loc.end.offset;
            }
          } else {
            if (this.needPositions) {
              end = query.loc.end.offset;
            }
          }
          return {
            type: "Nth",
            loc: this.getLocation(start, end),
            nth: query,
            selector: selector2
          };
        },
        generate: function(node2) {
          this.node(node2.nth);
          if (node2.selector !== null) {
            this.chunk(" of ");
            this.node(node2.selector);
          }
        }
      };
      var NUMBER$5 = tokenizer.TYPE.Number;
      var _Number = {
        name: "Number",
        structure: {
          value: String
        },
        parse: function() {
          return {
            type: "Number",
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(NUMBER$5)
          };
        },
        generate: function(node2) {
          this.chunk(node2.value);
        }
      };
      var Operator = {
        name: "Operator",
        structure: {
          value: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          this.scanner.next();
          return {
            type: "Operator",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
          };
        },
        generate: function(node2) {
          this.chunk(node2.value);
        }
      };
      var TYPE$t = tokenizer.TYPE;
      var LEFTPARENTHESIS$5 = TYPE$t.LeftParenthesis;
      var RIGHTPARENTHESIS$2 = TYPE$t.RightParenthesis;
      var Parentheses = {
        name: "Parentheses",
        structure: {
          children: [[]]
        },
        parse: function(readSequence2, recognizer) {
          var start = this.scanner.tokenStart;
          var children = null;
          this.eat(LEFTPARENTHESIS$5);
          children = readSequence2.call(this, recognizer);
          if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS$2);
          }
          return {
            type: "Parentheses",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children
          };
        },
        generate: function(node2) {
          this.chunk("(");
          this.children(node2);
          this.chunk(")");
        }
      };
      var consumeNumber$3 = utils.consumeNumber;
      var TYPE$u = tokenizer.TYPE;
      var PERCENTAGE$3 = TYPE$u.Percentage;
      var Percentage = {
        name: "Percentage",
        structure: {
          value: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var numberEnd = consumeNumber$3(this.scanner.source, start);
          this.eat(PERCENTAGE$3);
          return {
            type: "Percentage",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd)
          };
        },
        generate: function(node2) {
          this.chunk(node2.value);
          this.chunk("%");
        }
      };
      var TYPE$v = tokenizer.TYPE;
      var IDENT$d = TYPE$v.Ident;
      var FUNCTION$4 = TYPE$v.Function;
      var COLON$5 = TYPE$v.Colon;
      var RIGHTPARENTHESIS$3 = TYPE$v.RightParenthesis;
      var PseudoClassSelector = {
        name: "PseudoClassSelector",
        structure: {
          name: String,
          children: [["Raw"], null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var children = null;
          var name;
          var nameLowerCase;
          this.eat(COLON$5);
          if (this.scanner.tokenType === FUNCTION$4) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();
            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
              this.scanner.skipSC();
              children = this.pseudo[nameLowerCase].call(this);
              this.scanner.skipSC();
            } else {
              children = this.createList();
              children.push(this.Raw(this.scanner.tokenIndex, null, false));
            }
            this.eat(RIGHTPARENTHESIS$3);
          } else {
            name = this.consume(IDENT$d);
          }
          return {
            type: "PseudoClassSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            children
          };
        },
        generate: function(node2) {
          this.chunk(":");
          this.chunk(node2.name);
          if (node2.children !== null) {
            this.chunk("(");
            this.children(node2);
            this.chunk(")");
          }
        },
        walkContext: "function"
      };
      var TYPE$w = tokenizer.TYPE;
      var IDENT$e = TYPE$w.Ident;
      var FUNCTION$5 = TYPE$w.Function;
      var COLON$6 = TYPE$w.Colon;
      var RIGHTPARENTHESIS$4 = TYPE$w.RightParenthesis;
      var PseudoElementSelector = {
        name: "PseudoElementSelector",
        structure: {
          name: String,
          children: [["Raw"], null]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var children = null;
          var name;
          var nameLowerCase;
          this.eat(COLON$6);
          this.eat(COLON$6);
          if (this.scanner.tokenType === FUNCTION$5) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();
            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
              this.scanner.skipSC();
              children = this.pseudo[nameLowerCase].call(this);
              this.scanner.skipSC();
            } else {
              children = this.createList();
              children.push(this.Raw(this.scanner.tokenIndex, null, false));
            }
            this.eat(RIGHTPARENTHESIS$4);
          } else {
            name = this.consume(IDENT$e);
          }
          return {
            type: "PseudoElementSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            children
          };
        },
        generate: function(node2) {
          this.chunk("::");
          this.chunk(node2.name);
          if (node2.children !== null) {
            this.chunk("(");
            this.children(node2);
            this.chunk(")");
          }
        },
        walkContext: "function"
      };
      var isDigit$3 = tokenizer.isDigit;
      var TYPE$x = tokenizer.TYPE;
      var NUMBER$6 = TYPE$x.Number;
      var DELIM$4 = TYPE$x.Delim;
      var SOLIDUS$5 = 47;
      var FULLSTOP$2 = 46;
      function consumeNumber$4() {
        this.scanner.skipWS();
        var value2 = this.consume(NUMBER$6);
        for (var i2 = 0; i2 < value2.length; i2++) {
          var code = value2.charCodeAt(i2);
          if (!isDigit$3(code) && code !== FULLSTOP$2) {
            this.error("Unsigned number is expected", this.scanner.tokenStart - value2.length + i2);
          }
        }
        if (Number(value2) === 0) {
          this.error("Zero number is not allowed", this.scanner.tokenStart - value2.length);
        }
        return value2;
      }
      var Ratio = {
        name: "Ratio",
        structure: {
          left: String,
          right: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var left = consumeNumber$4.call(this);
          var right;
          this.scanner.skipWS();
          if (!this.scanner.isDelim(SOLIDUS$5)) {
            this.error("Solidus is expected");
          }
          this.eat(DELIM$4);
          right = consumeNumber$4.call(this);
          return {
            type: "Ratio",
            loc: this.getLocation(start, this.scanner.tokenStart),
            left,
            right
          };
        },
        generate: function(node2) {
          this.chunk(node2.left);
          this.chunk("/");
          this.chunk(node2.right);
        }
      };
      var TYPE$y = tokenizer.TYPE;
      var rawMode$5 = Raw.mode;
      var LEFTCURLYBRACKET$3 = TYPE$y.LeftCurlyBracket;
      function consumeRaw$4(startToken) {
        return this.Raw(startToken, rawMode$5.leftCurlyBracket, true);
      }
      function consumePrelude() {
        var prelude = this.SelectorList();
        if (prelude.type !== "Raw" && this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET$3) {
          this.error();
        }
        return prelude;
      }
      var Rule = {
        name: "Rule",
        structure: {
          prelude: ["SelectorList", "Raw"],
          block: ["Block"]
        },
        parse: function() {
          var startToken = this.scanner.tokenIndex;
          var startOffset = this.scanner.tokenStart;
          var prelude;
          var block;
          if (this.parseRulePrelude) {
            prelude = this.parseWithFallback(consumePrelude, consumeRaw$4);
          } else {
            prelude = consumeRaw$4.call(this, startToken);
          }
          block = this.Block(true);
          return {
            type: "Rule",
            loc: this.getLocation(startOffset, this.scanner.tokenStart),
            prelude,
            block
          };
        },
        generate: function(node2) {
          this.node(node2.prelude);
          this.node(node2.block);
        },
        walkContext: "rule"
      };
      var Selector = {
        name: "Selector",
        structure: {
          children: [[
            "TypeSelector",
            "IdSelector",
            "ClassSelector",
            "AttributeSelector",
            "PseudoClassSelector",
            "PseudoElementSelector",
            "Combinator",
            "WhiteSpace"
          ]]
        },
        parse: function() {
          var children = this.readSequence(this.scope.Selector);
          if (this.getFirstListNode(children) === null) {
            this.error("Selector is expected");
          }
          return {
            type: "Selector",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node2) {
          this.children(node2);
        }
      };
      var TYPE$z = tokenizer.TYPE;
      var COMMA$3 = TYPE$z.Comma;
      var SelectorList = {
        name: "SelectorList",
        structure: {
          children: [[
            "Selector",
            "Raw"
          ]]
        },
        parse: function() {
          var children = this.createList();
          while (!this.scanner.eof) {
            children.push(this.Selector());
            if (this.scanner.tokenType === COMMA$3) {
              this.scanner.next();
              continue;
            }
            break;
          }
          return {
            type: "SelectorList",
            loc: this.getLocationFromList(children),
            children
          };
        },
        generate: function(node2) {
          this.children(node2, function() {
            this.chunk(",");
          });
        },
        walkContext: "selector"
      };
      var STRING$3 = tokenizer.TYPE.String;
      var _String = {
        name: "String",
        structure: {
          value: String
        },
        parse: function() {
          return {
            type: "String",
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.consume(STRING$3)
          };
        },
        generate: function(node2) {
          this.chunk(node2.value);
        }
      };
      var TYPE$A = tokenizer.TYPE;
      var WHITESPACE$a = TYPE$A.WhiteSpace;
      var COMMENT$9 = TYPE$A.Comment;
      var ATKEYWORD$2 = TYPE$A.AtKeyword;
      var CDO$1 = TYPE$A.CDO;
      var CDC$1 = TYPE$A.CDC;
      var EXCLAMATIONMARK$2 = 33;
      function consumeRaw$5(startToken) {
        return this.Raw(startToken, null, false);
      }
      var StyleSheet = {
        name: "StyleSheet",
        structure: {
          children: [[
            "Comment",
            "CDO",
            "CDC",
            "Atrule",
            "Rule",
            "Raw"
          ]]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var children = this.createList();
          var child;
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case WHITESPACE$a:
                this.scanner.next();
                continue;
              case COMMENT$9:
                if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$2) {
                  this.scanner.next();
                  continue;
                }
                child = this.Comment();
                break;
              case CDO$1:
                child = this.CDO();
                break;
              case CDC$1:
                child = this.CDC();
                break;
              case ATKEYWORD$2:
                child = this.parseWithFallback(this.Atrule, consumeRaw$5);
                break;
              default:
                child = this.parseWithFallback(this.Rule, consumeRaw$5);
            }
            children.push(child);
          }
          return {
            type: "StyleSheet",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children
          };
        },
        generate: function(node2) {
          this.children(node2);
        },
        walkContext: "stylesheet"
      };
      var TYPE$B = tokenizer.TYPE;
      var IDENT$f = TYPE$B.Ident;
      var ASTERISK$5 = 42;
      var VERTICALLINE$2 = 124;
      function eatIdentifierOrAsterisk() {
        if (this.scanner.tokenType !== IDENT$f && this.scanner.isDelim(ASTERISK$5) === false) {
          this.error("Identifier or asterisk is expected");
        }
        this.scanner.next();
      }
      var TypeSelector = {
        name: "TypeSelector",
        structure: {
          name: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          if (this.scanner.isDelim(VERTICALLINE$2)) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
          } else {
            eatIdentifierOrAsterisk.call(this);
            if (this.scanner.isDelim(VERTICALLINE$2)) {
              this.scanner.next();
              eatIdentifierOrAsterisk.call(this);
            }
          }
          return {
            type: "TypeSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
          };
        },
        generate: function(node2) {
          this.chunk(node2.name);
        }
      };
      var isHexDigit$3 = tokenizer.isHexDigit;
      var cmpChar$3 = tokenizer.cmpChar;
      var TYPE$C = tokenizer.TYPE;
      var NAME$3 = tokenizer.NAME;
      var IDENT$g = TYPE$C.Ident;
      var NUMBER$7 = TYPE$C.Number;
      var DIMENSION$5 = TYPE$C.Dimension;
      var PLUSSIGN$5 = 43;
      var HYPHENMINUS$3 = 45;
      var QUESTIONMARK = 63;
      var U$1 = 117;
      function eatHexSequence(offset, allowDash) {
        for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
          var code = this.scanner.source.charCodeAt(pos);
          if (code === HYPHENMINUS$3 && allowDash && len !== 0) {
            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
              this.error();
            }
            return -1;
          }
          if (!isHexDigit$3(code)) {
            this.error(allowDash && len !== 0 ? "HyphenMinus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input", pos);
          }
          if (++len > 6) {
            this.error("Too many hex digits", pos);
          }
        }
        this.scanner.next();
        return len;
      }
      function eatQuestionMarkSequence(max) {
        var count = 0;
        while (this.scanner.isDelim(QUESTIONMARK)) {
          if (++count > max) {
            this.error("Too many question marks");
          }
          this.scanner.next();
        }
      }
      function startsWith(code) {
        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
          this.error(NAME$3[code] + " is expected");
        }
      }
      function scanUnicodeRange() {
        var hexLength = 0;
        if (this.scanner.isDelim(PLUSSIGN$5)) {
          this.scanner.next();
          if (this.scanner.tokenType === IDENT$g) {
            hexLength = eatHexSequence.call(this, 0, true);
            if (hexLength > 0) {
              eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            return;
          }
          if (this.scanner.isDelim(QUESTIONMARK)) {
            this.scanner.next();
            eatQuestionMarkSequence.call(this, 5);
            return;
          }
          this.error("Hex digit or question mark is expected");
          return;
        }
        if (this.scanner.tokenType === NUMBER$7) {
          startsWith.call(this, PLUSSIGN$5);
          hexLength = eatHexSequence.call(this, 1, true);
          if (this.scanner.isDelim(QUESTIONMARK)) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
            return;
          }
          if (this.scanner.tokenType === DIMENSION$5 || this.scanner.tokenType === NUMBER$7) {
            startsWith.call(this, HYPHENMINUS$3);
            eatHexSequence.call(this, 1, false);
            return;
          }
          return;
        }
        if (this.scanner.tokenType === DIMENSION$5) {
          startsWith.call(this, PLUSSIGN$5);
          hexLength = eatHexSequence.call(this, 1, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          return;
        }
        this.error();
      }
      var UnicodeRange = {
        name: "UnicodeRange",
        structure: {
          value: String
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          if (!cmpChar$3(this.scanner.source, start, U$1)) {
            this.error("U is expected");
          }
          if (!cmpChar$3(this.scanner.source, start + 1, PLUSSIGN$5)) {
            this.error("Plus sign is expected");
          }
          this.scanner.next();
          scanUnicodeRange.call(this);
          return {
            type: "UnicodeRange",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
          };
        },
        generate: function(node2) {
          this.chunk(node2.value);
        }
      };
      var isWhiteSpace$2 = tokenizer.isWhiteSpace;
      var cmpStr$5 = tokenizer.cmpStr;
      var TYPE$D = tokenizer.TYPE;
      var FUNCTION$6 = TYPE$D.Function;
      var URL$4 = TYPE$D.Url;
      var RIGHTPARENTHESIS$5 = TYPE$D.RightParenthesis;
      var Url = {
        name: "Url",
        structure: {
          value: ["String", "Raw"]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var value2;
          switch (this.scanner.tokenType) {
            case URL$4:
              var rawStart = start + 4;
              var rawEnd = this.scanner.tokenEnd - 1;
              while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
                rawStart++;
              }
              while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
                rawEnd--;
              }
              value2 = {
                type: "Raw",
                loc: this.getLocation(rawStart, rawEnd),
                value: this.scanner.source.substring(rawStart, rawEnd)
              };
              this.eat(URL$4);
              break;
            case FUNCTION$6:
              if (!cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, "url(")) {
                this.error("Function name must be `url`");
              }
              this.eat(FUNCTION$6);
              this.scanner.skipSC();
              value2 = this.String();
              this.scanner.skipSC();
              this.eat(RIGHTPARENTHESIS$5);
              break;
            default:
              this.error("Url or Function is expected");
          }
          return {
            type: "Url",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: value2
          };
        },
        generate: function(node2) {
          this.chunk("url");
          this.chunk("(");
          this.node(node2.value);
          this.chunk(")");
        }
      };
      var Value = {
        name: "Value",
        structure: {
          children: [[]]
        },
        parse: function() {
          var start = this.scanner.tokenStart;
          var children = this.readSequence(this.scope.Value);
          return {
            type: "Value",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children
          };
        },
        generate: function(node2) {
          this.children(node2);
        }
      };
      var WHITESPACE$b = tokenizer.TYPE.WhiteSpace;
      var SPACE = Object.freeze({
        type: "WhiteSpace",
        loc: null,
        value: " "
      });
      var WhiteSpace$1 = {
        name: "WhiteSpace",
        structure: {
          value: String
        },
        parse: function() {
          this.eat(WHITESPACE$b);
          return SPACE;
        },
        generate: function(node2) {
          this.chunk(node2.value);
        }
      };
      var node = {
        AnPlusB,
        Atrule,
        AtrulePrelude,
        AttributeSelector,
        Block,
        Brackets,
        CDC: CDC_1,
        CDO: CDO_1,
        ClassSelector,
        Combinator,
        Comment,
        Declaration,
        DeclarationList,
        Dimension,
        Function: _Function,
        Hash,
        Identifier,
        IdSelector,
        MediaFeature,
        MediaQuery,
        MediaQueryList,
        Nth,
        Number: _Number,
        Operator,
        Parentheses,
        Percentage,
        PseudoClassSelector,
        PseudoElementSelector,
        Ratio,
        Raw,
        Rule,
        Selector,
        SelectorList,
        String: _String,
        StyleSheet,
        TypeSelector,
        UnicodeRange,
        Url,
        Value,
        WhiteSpace: WhiteSpace$1
      };
      var parser = {
        parseContext: {
          default: "StyleSheet",
          stylesheet: "StyleSheet",
          atrule: "Atrule",
          atrulePrelude: function(options3) {
            return this.AtrulePrelude(options3.atrule ? String(options3.atrule) : null);
          },
          mediaQueryList: "MediaQueryList",
          mediaQuery: "MediaQuery",
          rule: "Rule",
          selectorList: "SelectorList",
          selector: "Selector",
          block: function() {
            return this.Block(true);
          },
          declarationList: "DeclarationList",
          declaration: "Declaration",
          value: "Value"
        },
        scope,
        atrule,
        pseudo,
        node
      };
      var parser$1 = create(parser);
      function read_style(parser2, start, attributes) {
        const content_start = parser2.index;
        const styles = parser2.read_until(/<\/style\s*>/, parser_errors.unclosed_style);
        if (parser2.index >= parser2.template.length) {
          parser2.error(parser_errors.unclosed_style);
        }
        const content_end = parser2.index;
        let ast;
        try {
          ast = parser$1(styles, {
            positions: true,
            offset: content_start,
            onParseError(error4) {
              throw error4;
            }
          });
        } catch (err) {
          if (err.name === "SyntaxError") {
            parser2.error(parser_errors.css_syntax_error(err.message), err.offset);
          } else {
            throw err;
          }
        }
        ast = JSON.parse(JSON.stringify(ast));
        walk(ast, {
          enter: (node2) => {
            if (node2.type === "Selector") {
              for (let i2 = 0; i2 < node2.children.length; i2 += 1) {
                const a = node2.children[i2];
                const b2 = node2.children[i2 + 1];
                if (is_ref_selector(a, b2)) {
                  parser2.error(parser_errors.invalid_ref_selector, a.loc.start.offset);
                }
              }
            }
            if (node2.type === "Declaration" && node2.value.type === "Value" && node2.value.children.length === 0) {
              parser2.error(parser_errors.invalid_declaration, node2.start);
            }
            if (node2.type === "PseudoClassSelector" && node2.name === "global" && node2.children === null) {
              parser2.error(parser_errors.empty_global_selector, node2.loc.start.offset);
            }
            if (node2.loc) {
              node2.start = node2.loc.start.offset;
              node2.end = node2.loc.end.offset;
              delete node2.loc;
            }
          }
        });
        parser2.read(/<\/style\s*>/);
        const end = parser2.index;
        return {
          type: "Style",
          start,
          end,
          attributes,
          children: ast.children,
          content: {
            start: content_start,
            end: content_end,
            styles
          }
        };
      }
      function is_ref_selector(a, b2) {
        if (!b2)
          return false;
        return a.type === "TypeSelector" && a.name === "ref" && b2.type === "PseudoClassSelector";
      }
      var entities = {
        CounterClockwiseContourIntegral: 8755,
        ClockwiseContourIntegral: 8754,
        DoubleLongLeftRightArrow: 10234,
        DiacriticalDoubleAcute: 733,
        NotSquareSupersetEqual: 8931,
        CloseCurlyDoubleQuote: 8221,
        DoubleContourIntegral: 8751,
        FilledVerySmallSquare: 9642,
        NegativeVeryThinSpace: 8203,
        NotPrecedesSlantEqual: 8928,
        NotRightTriangleEqual: 8941,
        NotSucceedsSlantEqual: 8929,
        CapitalDifferentialD: 8517,
        DoubleLeftRightArrow: 8660,
        DoubleLongRightArrow: 10233,
        EmptyVerySmallSquare: 9643,
        NestedGreaterGreater: 8811,
        NotDoubleVerticalBar: 8742,
        NotLeftTriangleEqual: 8940,
        NotSquareSubsetEqual: 8930,
        OpenCurlyDoubleQuote: 8220,
        ReverseUpEquilibrium: 10607,
        DoubleLongLeftArrow: 10232,
        DownLeftRightVector: 10576,
        LeftArrowRightArrow: 8646,
        NegativeMediumSpace: 8203,
        RightArrowLeftArrow: 8644,
        SquareSupersetEqual: 8850,
        leftrightsquigarrow: 8621,
        DownRightTeeVector: 10591,
        DownRightVectorBar: 10583,
        LongLeftRightArrow: 10231,
        Longleftrightarrow: 10234,
        NegativeThickSpace: 8203,
        PrecedesSlantEqual: 8828,
        ReverseEquilibrium: 8651,
        RightDoubleBracket: 10215,
        RightDownTeeVector: 10589,
        RightDownVectorBar: 10581,
        RightTriangleEqual: 8885,
        SquareIntersection: 8851,
        SucceedsSlantEqual: 8829,
        blacktriangleright: 9656,
        longleftrightarrow: 10231,
        DoubleUpDownArrow: 8661,
        DoubleVerticalBar: 8741,
        DownLeftTeeVector: 10590,
        DownLeftVectorBar: 10582,
        FilledSmallSquare: 9724,
        GreaterSlantEqual: 10878,
        LeftDoubleBracket: 10214,
        LeftDownTeeVector: 10593,
        LeftDownVectorBar: 10585,
        LeftTriangleEqual: 8884,
        NegativeThinSpace: 8203,
        NotReverseElement: 8716,
        NotTildeFullEqual: 8775,
        RightAngleBracket: 10217,
        RightUpDownVector: 10575,
        SquareSubsetEqual: 8849,
        VerticalSeparator: 10072,
        blacktriangledown: 9662,
        blacktriangleleft: 9666,
        leftrightharpoons: 8651,
        rightleftharpoons: 8652,
        twoheadrightarrow: 8608,
        DiacriticalAcute: 180,
        DiacriticalGrave: 96,
        DiacriticalTilde: 732,
        DoubleRightArrow: 8658,
        DownArrowUpArrow: 8693,
        EmptySmallSquare: 9723,
        GreaterEqualLess: 8923,
        GreaterFullEqual: 8807,
        LeftAngleBracket: 10216,
        LeftUpDownVector: 10577,
        LessEqualGreater: 8922,
        NonBreakingSpace: 160,
        NotRightTriangle: 8939,
        NotSupersetEqual: 8841,
        RightTriangleBar: 10704,
        RightUpTeeVector: 10588,
        RightUpVectorBar: 10580,
        UnderParenthesis: 9181,
        UpArrowDownArrow: 8645,
        circlearrowright: 8635,
        downharpoonright: 8642,
        ntrianglerighteq: 8941,
        rightharpoondown: 8641,
        rightrightarrows: 8649,
        twoheadleftarrow: 8606,
        vartriangleright: 8883,
        CloseCurlyQuote: 8217,
        ContourIntegral: 8750,
        DoubleDownArrow: 8659,
        DoubleLeftArrow: 8656,
        DownRightVector: 8641,
        LeftRightVector: 10574,
        LeftTriangleBar: 10703,
        LeftUpTeeVector: 10592,
        LeftUpVectorBar: 10584,
        LowerRightArrow: 8600,
        NotGreaterEqual: 8817,
        NotGreaterTilde: 8821,
        NotLeftTriangle: 8938,
        OverParenthesis: 9180,
        RightDownVector: 8642,
        ShortRightArrow: 8594,
        UpperRightArrow: 8599,
        bigtriangledown: 9661,
        circlearrowleft: 8634,
        curvearrowright: 8631,
        downharpoonleft: 8643,
        leftharpoondown: 8637,
        leftrightarrows: 8646,
        nLeftrightarrow: 8654,
        nleftrightarrow: 8622,
        ntrianglelefteq: 8940,
        rightleftarrows: 8644,
        rightsquigarrow: 8605,
        rightthreetimes: 8908,
        straightepsilon: 1013,
        trianglerighteq: 8885,
        vartriangleleft: 8882,
        DiacriticalDot: 729,
        DoubleRightTee: 8872,
        DownLeftVector: 8637,
        GreaterGreater: 10914,
        HorizontalLine: 9472,
        InvisibleComma: 8291,
        InvisibleTimes: 8290,
        LeftDownVector: 8643,
        LeftRightArrow: 8596,
        Leftrightarrow: 8660,
        LessSlantEqual: 10877,
        LongRightArrow: 10230,
        Longrightarrow: 10233,
        LowerLeftArrow: 8601,
        NestedLessLess: 8810,
        NotGreaterLess: 8825,
        NotLessGreater: 8824,
        NotSubsetEqual: 8840,
        NotVerticalBar: 8740,
        OpenCurlyQuote: 8216,
        ReverseElement: 8715,
        RightTeeVector: 10587,
        RightVectorBar: 10579,
        ShortDownArrow: 8595,
        ShortLeftArrow: 8592,
        SquareSuperset: 8848,
        TildeFullEqual: 8773,
        UpperLeftArrow: 8598,
        ZeroWidthSpace: 8203,
        curvearrowleft: 8630,
        doublebarwedge: 8966,
        downdownarrows: 8650,
        hookrightarrow: 8618,
        leftleftarrows: 8647,
        leftrightarrow: 8596,
        leftthreetimes: 8907,
        longrightarrow: 10230,
        looparrowright: 8620,
        nshortparallel: 8742,
        ntriangleright: 8939,
        rightarrowtail: 8611,
        rightharpoonup: 8640,
        trianglelefteq: 8884,
        upharpoonright: 8638,
        ApplyFunction: 8289,
        DifferentialD: 8518,
        DoubleLeftTee: 10980,
        DoubleUpArrow: 8657,
        LeftTeeVector: 10586,
        LeftVectorBar: 10578,
        LessFullEqual: 8806,
        LongLeftArrow: 10229,
        Longleftarrow: 10232,
        NotTildeEqual: 8772,
        NotTildeTilde: 8777,
        Poincareplane: 8460,
        PrecedesEqual: 10927,
        PrecedesTilde: 8830,
        RightArrowBar: 8677,
        RightTeeArrow: 8614,
        RightTriangle: 8883,
        RightUpVector: 8638,
        SucceedsEqual: 10928,
        SucceedsTilde: 8831,
        SupersetEqual: 8839,
        UpEquilibrium: 10606,
        VerticalTilde: 8768,
        VeryThinSpace: 8202,
        bigtriangleup: 9651,
        blacktriangle: 9652,
        divideontimes: 8903,
        fallingdotseq: 8786,
        hookleftarrow: 8617,
        leftarrowtail: 8610,
        leftharpoonup: 8636,
        longleftarrow: 10229,
        looparrowleft: 8619,
        measuredangle: 8737,
        ntriangleleft: 8938,
        shortparallel: 8741,
        smallsetminus: 8726,
        triangleright: 9657,
        upharpoonleft: 8639,
        DownArrowBar: 10515,
        DownTeeArrow: 8615,
        ExponentialE: 8519,
        GreaterEqual: 8805,
        GreaterTilde: 8819,
        HilbertSpace: 8459,
        HumpDownHump: 8782,
        Intersection: 8898,
        LeftArrowBar: 8676,
        LeftTeeArrow: 8612,
        LeftTriangle: 8882,
        LeftUpVector: 8639,
        NotCongruent: 8802,
        NotLessEqual: 8816,
        NotLessTilde: 8820,
        Proportional: 8733,
        RightCeiling: 8969,
        RoundImplies: 10608,
        ShortUpArrow: 8593,
        SquareSubset: 8847,
        UnderBracket: 9141,
        VerticalLine: 124,
        blacklozenge: 10731,
        exponentiale: 8519,
        risingdotseq: 8787,
        triangledown: 9663,
        triangleleft: 9667,
        CircleMinus: 8854,
        CircleTimes: 8855,
        Equilibrium: 8652,
        GreaterLess: 8823,
        LeftCeiling: 8968,
        LessGreater: 8822,
        MediumSpace: 8287,
        NotPrecedes: 8832,
        NotSucceeds: 8833,
        OverBracket: 9140,
        RightVector: 8640,
        Rrightarrow: 8667,
        RuleDelayed: 10740,
        SmallCircle: 8728,
        SquareUnion: 8852,
        SubsetEqual: 8838,
        UpDownArrow: 8597,
        Updownarrow: 8661,
        VerticalBar: 8739,
        backepsilon: 1014,
        blacksquare: 9642,
        circledcirc: 8858,
        circleddash: 8861,
        curlyeqprec: 8926,
        curlyeqsucc: 8927,
        diamondsuit: 9830,
        eqslantless: 10901,
        expectation: 8496,
        nRightarrow: 8655,
        nrightarrow: 8603,
        preccurlyeq: 8828,
        precnapprox: 10937,
        quaternions: 8461,
        straightphi: 981,
        succcurlyeq: 8829,
        succnapprox: 10938,
        thickapprox: 8776,
        updownarrow: 8597,
        Bernoullis: 8492,
        CirclePlus: 8853,
        EqualTilde: 8770,
        Fouriertrf: 8497,
        ImaginaryI: 8520,
        Laplacetrf: 8466,
        LeftVector: 8636,
        Lleftarrow: 8666,
        NotElement: 8713,
        NotGreater: 8815,
        Proportion: 8759,
        RightArrow: 8594,
        RightFloor: 8971,
        Rightarrow: 8658,
        TildeEqual: 8771,
        TildeTilde: 8776,
        UnderBrace: 9183,
        UpArrowBar: 10514,
        UpTeeArrow: 8613,
        circledast: 8859,
        complement: 8705,
        curlywedge: 8911,
        eqslantgtr: 10902,
        gtreqqless: 10892,
        lessapprox: 10885,
        lesseqqgtr: 10891,
        lmoustache: 9136,
        longmapsto: 10236,
        mapstodown: 8615,
        mapstoleft: 8612,
        nLeftarrow: 8653,
        nleftarrow: 8602,
        precapprox: 10935,
        rightarrow: 8594,
        rmoustache: 9137,
        sqsubseteq: 8849,
        sqsupseteq: 8850,
        subsetneqq: 10955,
        succapprox: 10936,
        supsetneqq: 10956,
        upuparrows: 8648,
        varepsilon: 949,
        varnothing: 8709,
        Backslash: 8726,
        CenterDot: 183,
        CircleDot: 8857,
        Congruent: 8801,
        Coproduct: 8720,
        DoubleDot: 168,
        DownArrow: 8595,
        DownBreve: 785,
        Downarrow: 8659,
        HumpEqual: 8783,
        LeftArrow: 8592,
        LeftFloor: 8970,
        Leftarrow: 8656,
        LessTilde: 8818,
        Mellintrf: 8499,
        MinusPlus: 8723,
        NotCupCap: 8813,
        NotExists: 8708,
        OverBrace: 9182,
        PlusMinus: 177,
        Therefore: 8756,
        ThinSpace: 8201,
        TripleDot: 8411,
        UnionPlus: 8846,
        backprime: 8245,
        backsimeq: 8909,
        bigotimes: 10754,
        centerdot: 183,
        checkmark: 10003,
        complexes: 8450,
        dotsquare: 8865,
        downarrow: 8595,
        gtrapprox: 10886,
        gtreqless: 8923,
        heartsuit: 9829,
        leftarrow: 8592,
        lesseqgtr: 8922,
        nparallel: 8742,
        nshortmid: 8740,
        nsubseteq: 8840,
        nsupseteq: 8841,
        pitchfork: 8916,
        rationals: 8474,
        spadesuit: 9824,
        subseteqq: 10949,
        subsetneq: 8842,
        supseteqq: 10950,
        supsetneq: 8843,
        therefore: 8756,
        triangleq: 8796,
        varpropto: 8733,
        DDotrahd: 10513,
        DotEqual: 8784,
        Integral: 8747,
        LessLess: 10913,
        NotEqual: 8800,
        NotTilde: 8769,
        PartialD: 8706,
        Precedes: 8826,
        RightTee: 8866,
        Succeeds: 8827,
        SuchThat: 8715,
        Superset: 8835,
        Uarrocir: 10569,
        UnderBar: 818,
        andslope: 10840,
        angmsdaa: 10664,
        angmsdab: 10665,
        angmsdac: 10666,
        angmsdad: 10667,
        angmsdae: 10668,
        angmsdaf: 10669,
        angmsdag: 10670,
        angmsdah: 10671,
        angrtvbd: 10653,
        approxeq: 8778,
        awconint: 8755,
        backcong: 8780,
        barwedge: 8965,
        bbrktbrk: 9142,
        bigoplus: 10753,
        bigsqcup: 10758,
        biguplus: 10756,
        bigwedge: 8896,
        boxminus: 8863,
        boxtimes: 8864,
        capbrcup: 10825,
        circledR: 174,
        circledS: 9416,
        cirfnint: 10768,
        clubsuit: 9827,
        cupbrcap: 10824,
        curlyvee: 8910,
        cwconint: 8754,
        doteqdot: 8785,
        dotminus: 8760,
        drbkarow: 10512,
        dzigrarr: 10239,
        elinters: 9191,
        emptyset: 8709,
        eqvparsl: 10725,
        fpartint: 10765,
        geqslant: 10878,
        gesdotol: 10884,
        gnapprox: 10890,
        hksearow: 10533,
        hkswarow: 10534,
        imagline: 8464,
        imagpart: 8465,
        infintie: 10717,
        integers: 8484,
        intercal: 8890,
        intlarhk: 10775,
        laemptyv: 10676,
        ldrushar: 10571,
        leqslant: 10877,
        lesdotor: 10883,
        llcorner: 8990,
        lnapprox: 10889,
        lrcorner: 8991,
        lurdshar: 10570,
        mapstoup: 8613,
        multimap: 8888,
        naturals: 8469,
        otimesas: 10806,
        parallel: 8741,
        plusacir: 10787,
        pointint: 10773,
        precneqq: 10933,
        precnsim: 8936,
        profalar: 9006,
        profline: 8978,
        profsurf: 8979,
        raemptyv: 10675,
        realpart: 8476,
        rppolint: 10770,
        rtriltri: 10702,
        scpolint: 10771,
        setminus: 8726,
        shortmid: 8739,
        smeparsl: 10724,
        sqsubset: 8847,
        sqsupset: 8848,
        subseteq: 8838,
        succneqq: 10934,
        succnsim: 8937,
        supseteq: 8839,
        thetasym: 977,
        thicksim: 8764,
        timesbar: 10801,
        triangle: 9653,
        triminus: 10810,
        trpezium: 9186,
        ulcorner: 8988,
        urcorner: 8989,
        varkappa: 1008,
        varsigma: 962,
        vartheta: 977,
        Because: 8757,
        Cayleys: 8493,
        Cconint: 8752,
        Cedilla: 184,
        Diamond: 8900,
        DownTee: 8868,
        Element: 8712,
        Epsilon: 917,
        Implies: 8658,
        LeftTee: 8867,
        NewLine: 10,
        NoBreak: 8288,
        NotLess: 8814,
        Omicron: 927,
        OverBar: 175,
        Product: 8719,
        UpArrow: 8593,
        Uparrow: 8657,
        Upsilon: 933,
        alefsym: 8501,
        angrtvb: 8894,
        angzarr: 9084,
        asympeq: 8781,
        backsim: 8765,
        because: 8757,
        bemptyv: 10672,
        between: 8812,
        bigcirc: 9711,
        bigodot: 10752,
        bigstar: 9733,
        boxplus: 8862,
        ccupssm: 10832,
        cemptyv: 10674,
        cirscir: 10690,
        coloneq: 8788,
        congdot: 10861,
        cudarrl: 10552,
        cudarrr: 10549,
        cularrp: 10557,
        curarrm: 10556,
        dbkarow: 10511,
        ddagger: 8225,
        ddotseq: 10871,
        demptyv: 10673,
        diamond: 8900,
        digamma: 989,
        dotplus: 8724,
        dwangle: 10662,
        epsilon: 949,
        eqcolon: 8789,
        equivDD: 10872,
        gesdoto: 10882,
        gtquest: 10876,
        gtrless: 8823,
        harrcir: 10568,
        intprod: 10812,
        isindot: 8949,
        larrbfs: 10527,
        larrsim: 10611,
        lbrksld: 10639,
        lbrkslu: 10637,
        ldrdhar: 10599,
        lesdoto: 10881,
        lessdot: 8918,
        lessgtr: 8822,
        lesssim: 8818,
        lotimes: 10804,
        lozenge: 9674,
        ltquest: 10875,
        luruhar: 10598,
        maltese: 10016,
        minusdu: 10794,
        napprox: 8777,
        natural: 9838,
        nearrow: 8599,
        nexists: 8708,
        notinva: 8713,
        notinvb: 8951,
        notinvc: 8950,
        notniva: 8716,
        notnivb: 8958,
        notnivc: 8957,
        npolint: 10772,
        nsqsube: 8930,
        nsqsupe: 8931,
        nvinfin: 10718,
        nwarrow: 8598,
        olcross: 10683,
        omicron: 959,
        orderof: 8500,
        orslope: 10839,
        pertenk: 8241,
        planckh: 8462,
        pluscir: 10786,
        plussim: 10790,
        plustwo: 10791,
        precsim: 8830,
        quatint: 10774,
        questeq: 8799,
        rarrbfs: 10528,
        rarrsim: 10612,
        rbrksld: 10638,
        rbrkslu: 10640,
        rdldhar: 10601,
        realine: 8475,
        rotimes: 10805,
        ruluhar: 10600,
        searrow: 8600,
        simplus: 10788,
        simrarr: 10610,
        subedot: 10947,
        submult: 10945,
        subplus: 10943,
        subrarr: 10617,
        succsim: 8831,
        supdsub: 10968,
        supedot: 10948,
        suphsub: 10967,
        suplarr: 10619,
        supmult: 10946,
        supplus: 10944,
        swarrow: 8601,
        topfork: 10970,
        triplus: 10809,
        tritime: 10811,
        uparrow: 8593,
        upsilon: 965,
        uwangle: 10663,
        vzigzag: 10650,
        zigrarr: 8669,
        Aacute: 193,
        Abreve: 258,
        Agrave: 192,
        Assign: 8788,
        Atilde: 195,
        Barwed: 8966,
        Bumpeq: 8782,
        Cacute: 262,
        Ccaron: 268,
        Ccedil: 199,
        Colone: 10868,
        Conint: 8751,
        CupCap: 8781,
        Dagger: 8225,
        Dcaron: 270,
        DotDot: 8412,
        Dstrok: 272,
        Eacute: 201,
        Ecaron: 282,
        Egrave: 200,
        Exists: 8707,
        ForAll: 8704,
        Gammad: 988,
        Gbreve: 286,
        Gcedil: 290,
        HARDcy: 1066,
        Hstrok: 294,
        Iacute: 205,
        Igrave: 204,
        Itilde: 296,
        Jsercy: 1032,
        Kcedil: 310,
        Lacute: 313,
        Lambda: 923,
        Lcaron: 317,
        Lcedil: 315,
        Lmidot: 319,
        Lstrok: 321,
        Nacute: 323,
        Ncaron: 327,
        Ncedil: 325,
        Ntilde: 209,
        Oacute: 211,
        Odblac: 336,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Otimes: 10807,
        Racute: 340,
        Rarrtl: 10518,
        Rcaron: 344,
        Rcedil: 342,
        SHCHcy: 1065,
        SOFTcy: 1068,
        Sacute: 346,
        Scaron: 352,
        Scedil: 350,
        Square: 9633,
        Subset: 8912,
        Supset: 8913,
        Tcaron: 356,
        Tcedil: 354,
        Tstrok: 358,
        Uacute: 218,
        Ubreve: 364,
        Udblac: 368,
        Ugrave: 217,
        Utilde: 360,
        Vdashl: 10982,
        Verbar: 8214,
        Vvdash: 8874,
        Yacute: 221,
        Zacute: 377,
        Zcaron: 381,
        aacute: 225,
        abreve: 259,
        agrave: 224,
        andand: 10837,
        angmsd: 8737,
        angsph: 8738,
        apacir: 10863,
        approx: 8776,
        atilde: 227,
        barvee: 8893,
        barwed: 8965,
        becaus: 8757,
        bernou: 8492,
        bigcap: 8898,
        bigcup: 8899,
        bigvee: 8897,
        bkarow: 10509,
        bottom: 8869,
        bowtie: 8904,
        boxbox: 10697,
        bprime: 8245,
        brvbar: 166,
        bullet: 8226,
        bumpeq: 8783,
        cacute: 263,
        capand: 10820,
        capcap: 10827,
        capcup: 10823,
        capdot: 10816,
        ccaron: 269,
        ccedil: 231,
        circeq: 8791,
        cirmid: 10991,
        colone: 8788,
        commat: 64,
        compfn: 8728,
        conint: 8750,
        coprod: 8720,
        copysr: 8471,
        cularr: 8630,
        cupcap: 10822,
        cupcup: 10826,
        cupdot: 8845,
        curarr: 8631,
        curren: 164,
        cylcty: 9005,
        dagger: 8224,
        daleth: 8504,
        dcaron: 271,
        dfisht: 10623,
        divide: 247,
        divonx: 8903,
        dlcorn: 8990,
        dlcrop: 8973,
        dollar: 36,
        drcorn: 8991,
        drcrop: 8972,
        dstrok: 273,
        eacute: 233,
        easter: 10862,
        ecaron: 283,
        ecolon: 8789,
        egrave: 232,
        egsdot: 10904,
        elsdot: 10903,
        emptyv: 8709,
        emsp13: 8196,
        emsp14: 8197,
        eparsl: 10723,
        eqcirc: 8790,
        equals: 61,
        equest: 8799,
        female: 9792,
        ffilig: 64259,
        ffllig: 64260,
        forall: 8704,
        frac12: 189,
        frac13: 8531,
        frac14: 188,
        frac15: 8533,
        frac16: 8537,
        frac18: 8539,
        frac23: 8532,
        frac25: 8534,
        frac34: 190,
        frac35: 8535,
        frac38: 8540,
        frac45: 8536,
        frac56: 8538,
        frac58: 8541,
        frac78: 8542,
        gacute: 501,
        gammad: 989,
        gbreve: 287,
        gesdot: 10880,
        gesles: 10900,
        gtlPar: 10645,
        gtrarr: 10616,
        gtrdot: 8919,
        gtrsim: 8819,
        hairsp: 8202,
        hamilt: 8459,
        hardcy: 1098,
        hearts: 9829,
        hellip: 8230,
        hercon: 8889,
        homtht: 8763,
        horbar: 8213,
        hslash: 8463,
        hstrok: 295,
        hybull: 8259,
        hyphen: 8208,
        iacute: 237,
        igrave: 236,
        iiiint: 10764,
        iinfin: 10716,
        incare: 8453,
        inodot: 305,
        intcal: 8890,
        iquest: 191,
        isinsv: 8947,
        itilde: 297,
        jsercy: 1112,
        kappav: 1008,
        kcedil: 311,
        kgreen: 312,
        lAtail: 10523,
        lacute: 314,
        lagran: 8466,
        lambda: 955,
        langle: 10216,
        larrfs: 10525,
        larrhk: 8617,
        larrlp: 8619,
        larrpl: 10553,
        larrtl: 8610,
        latail: 10521,
        lbrace: 123,
        lbrack: 91,
        lcaron: 318,
        lcedil: 316,
        ldquor: 8222,
        lesdot: 10879,
        lesges: 10899,
        lfisht: 10620,
        lfloor: 8970,
        lharul: 10602,
        llhard: 10603,
        lmidot: 320,
        lmoust: 9136,
        loplus: 10797,
        lowast: 8727,
        lowbar: 95,
        lparlt: 10643,
        lrhard: 10605,
        lsaquo: 8249,
        lsquor: 8218,
        lstrok: 322,
        lthree: 8907,
        ltimes: 8905,
        ltlarr: 10614,
        ltrPar: 10646,
        mapsto: 8614,
        marker: 9646,
        mcomma: 10793,
        midast: 42,
        midcir: 10992,
        middot: 183,
        minusb: 8863,
        minusd: 8760,
        mnplus: 8723,
        models: 8871,
        mstpos: 8766,
        nVDash: 8879,
        nVdash: 8878,
        nacute: 324,
        ncaron: 328,
        ncedil: 326,
        nearhk: 10532,
        nequiv: 8802,
        nesear: 10536,
        nexist: 8708,
        nltrie: 8940,
        nprcue: 8928,
        nrtrie: 8941,
        nsccue: 8929,
        nsimeq: 8772,
        ntilde: 241,
        numero: 8470,
        nvDash: 8877,
        nvHarr: 10500,
        nvdash: 8876,
        nvlArr: 10498,
        nvrArr: 10499,
        nwarhk: 10531,
        nwnear: 10535,
        oacute: 243,
        odblac: 337,
        odsold: 10684,
        ograve: 242,
        ominus: 8854,
        origof: 8886,
        oslash: 248,
        otilde: 245,
        otimes: 8855,
        parsim: 10995,
        percnt: 37,
        period: 46,
        permil: 8240,
        phmmat: 8499,
        planck: 8463,
        plankv: 8463,
        plusdo: 8724,
        plusdu: 10789,
        plusmn: 177,
        preceq: 10927,
        primes: 8473,
        prnsim: 8936,
        propto: 8733,
        prurel: 8880,
        puncsp: 8200,
        qprime: 8279,
        rAtail: 10524,
        racute: 341,
        rangle: 10217,
        rarrap: 10613,
        rarrfs: 10526,
        rarrhk: 8618,
        rarrlp: 8620,
        rarrpl: 10565,
        rarrtl: 8611,
        ratail: 10522,
        rbrace: 125,
        rbrack: 93,
        rcaron: 345,
        rcedil: 343,
        rdquor: 8221,
        rfisht: 10621,
        rfloor: 8971,
        rharul: 10604,
        rmoust: 9137,
        roplus: 10798,
        rpargt: 10644,
        rsaquo: 8250,
        rsquor: 8217,
        rthree: 8908,
        rtimes: 8906,
        sacute: 347,
        scaron: 353,
        scedil: 351,
        scnsim: 8937,
        searhk: 10533,
        seswar: 10537,
        sfrown: 8994,
        shchcy: 1097,
        sigmaf: 962,
        sigmav: 962,
        simdot: 10858,
        smashp: 10803,
        softcy: 1100,
        solbar: 9023,
        spades: 9824,
        sqsube: 8849,
        sqsupe: 8850,
        square: 9633,
        squarf: 9642,
        ssetmn: 8726,
        ssmile: 8995,
        sstarf: 8902,
        subdot: 10941,
        subset: 8834,
        subsim: 10951,
        subsub: 10965,
        subsup: 10963,
        succeq: 10928,
        supdot: 10942,
        supset: 8835,
        supsim: 10952,
        supsub: 10964,
        supsup: 10966,
        swarhk: 10534,
        swnwar: 10538,
        target: 8982,
        tcaron: 357,
        tcedil: 355,
        telrec: 8981,
        there4: 8756,
        thetav: 977,
        thinsp: 8201,
        thksim: 8764,
        timesb: 8864,
        timesd: 10800,
        topbot: 9014,
        topcir: 10993,
        tprime: 8244,
        tridot: 9708,
        tstrok: 359,
        uacute: 250,
        ubreve: 365,
        udblac: 369,
        ufisht: 10622,
        ugrave: 249,
        ulcorn: 8988,
        ulcrop: 8975,
        urcorn: 8989,
        urcrop: 8974,
        utilde: 361,
        vangrt: 10652,
        varphi: 966,
        varrho: 1009,
        veebar: 8891,
        vellip: 8942,
        verbar: 124,
        wedbar: 10847,
        wedgeq: 8793,
        weierp: 8472,
        wreath: 8768,
        xoplus: 10753,
        xotime: 10754,
        xsqcup: 10758,
        xuplus: 10756,
        xwedge: 8896,
        yacute: 253,
        zacute: 378,
        zcaron: 382,
        zeetrf: 8488,
        AElig: 198,
        Acirc: 194,
        Alpha: 913,
        Amacr: 256,
        Aogon: 260,
        Aring: 197,
        Breve: 728,
        Ccirc: 264,
        Colon: 8759,
        Cross: 10799,
        Dashv: 10980,
        Delta: 916,
        Ecirc: 202,
        Emacr: 274,
        Eogon: 280,
        Equal: 10869,
        Gamma: 915,
        Gcirc: 284,
        Hacek: 711,
        Hcirc: 292,
        IJlig: 306,
        Icirc: 206,
        Imacr: 298,
        Iogon: 302,
        Iukcy: 1030,
        Jcirc: 308,
        Jukcy: 1028,
        Kappa: 922,
        OElig: 338,
        Ocirc: 212,
        Omacr: 332,
        Omega: 937,
        Prime: 8243,
        RBarr: 10512,
        Scirc: 348,
        Sigma: 931,
        THORN: 222,
        TRADE: 8482,
        TSHcy: 1035,
        Theta: 920,
        Tilde: 8764,
        Ubrcy: 1038,
        Ucirc: 219,
        Umacr: 362,
        Union: 8899,
        Uogon: 370,
        UpTee: 8869,
        Uring: 366,
        VDash: 8875,
        Vdash: 8873,
        Wcirc: 372,
        Wedge: 8896,
        Ycirc: 374,
        acirc: 226,
        acute: 180,
        aelig: 230,
        aleph: 8501,
        alpha: 945,
        amacr: 257,
        amalg: 10815,
        angle: 8736,
        angrt: 8735,
        angst: 8491,
        aogon: 261,
        aring: 229,
        asymp: 8776,
        awint: 10769,
        bcong: 8780,
        bdquo: 8222,
        bepsi: 1014,
        blank: 9251,
        blk12: 9618,
        blk14: 9617,
        blk34: 9619,
        block: 9608,
        boxDL: 9559,
        boxDR: 9556,
        boxDl: 9558,
        boxDr: 9555,
        boxHD: 9574,
        boxHU: 9577,
        boxHd: 9572,
        boxHu: 9575,
        boxUL: 9565,
        boxUR: 9562,
        boxUl: 9564,
        boxUr: 9561,
        boxVH: 9580,
        boxVL: 9571,
        boxVR: 9568,
        boxVh: 9579,
        boxVl: 9570,
        boxVr: 9567,
        boxdL: 9557,
        boxdR: 9554,
        boxdl: 9488,
        boxdr: 9484,
        boxhD: 9573,
        boxhU: 9576,
        boxhd: 9516,
        boxhu: 9524,
        boxuL: 9563,
        boxuR: 9560,
        boxul: 9496,
        boxur: 9492,
        boxvH: 9578,
        boxvL: 9569,
        boxvR: 9566,
        boxvh: 9532,
        boxvl: 9508,
        boxvr: 9500,
        breve: 728,
        bsemi: 8271,
        bsime: 8909,
        bsolb: 10693,
        bumpE: 10926,
        bumpe: 8783,
        caret: 8257,
        caron: 711,
        ccaps: 10829,
        ccirc: 265,
        ccups: 10828,
        cedil: 184,
        check: 10003,
        clubs: 9827,
        colon: 58,
        comma: 44,
        crarr: 8629,
        cross: 10007,
        csube: 10961,
        csupe: 10962,
        ctdot: 8943,
        cuepr: 8926,
        cuesc: 8927,
        cupor: 10821,
        cuvee: 8910,
        cuwed: 8911,
        cwint: 8753,
        dashv: 8867,
        dblac: 733,
        ddarr: 8650,
        delta: 948,
        dharl: 8643,
        dharr: 8642,
        diams: 9830,
        disin: 8946,
        doteq: 8784,
        dtdot: 8945,
        dtrif: 9662,
        duarr: 8693,
        duhar: 10607,
        eDDot: 10871,
        ecirc: 234,
        efDot: 8786,
        emacr: 275,
        empty: 8709,
        eogon: 281,
        eplus: 10865,
        epsiv: 949,
        eqsim: 8770,
        equiv: 8801,
        erDot: 8787,
        erarr: 10609,
        esdot: 8784,
        exist: 8707,
        fflig: 64256,
        filig: 64257,
        fllig: 64258,
        fltns: 9649,
        forkv: 10969,
        frasl: 8260,
        frown: 8994,
        gamma: 947,
        gcirc: 285,
        gescc: 10921,
        gimel: 8503,
        gneqq: 8809,
        gnsim: 8935,
        grave: 96,
        gsime: 10894,
        gsiml: 10896,
        gtcir: 10874,
        gtdot: 8919,
        harrw: 8621,
        hcirc: 293,
        hoarr: 8703,
        icirc: 238,
        iexcl: 161,
        iiint: 8749,
        iiota: 8489,
        ijlig: 307,
        imacr: 299,
        image: 8465,
        imath: 305,
        imped: 437,
        infin: 8734,
        iogon: 303,
        iprod: 10812,
        isinE: 8953,
        isins: 8948,
        isinv: 8712,
        iukcy: 1110,
        jcirc: 309,
        jmath: 567,
        jukcy: 1108,
        kappa: 954,
        lAarr: 8666,
        lBarr: 10510,
        langd: 10641,
        laquo: 171,
        larrb: 8676,
        lbarr: 10508,
        lbbrk: 10098,
        lbrke: 10635,
        lceil: 8968,
        ldquo: 8220,
        lescc: 10920,
        lhard: 8637,
        lharu: 8636,
        lhblk: 9604,
        llarr: 8647,
        lltri: 9722,
        lneqq: 8808,
        lnsim: 8934,
        loang: 10220,
        loarr: 8701,
        lobrk: 10214,
        lopar: 10629,
        lrarr: 8646,
        lrhar: 8651,
        lrtri: 8895,
        lsime: 10893,
        lsimg: 10895,
        lsquo: 8216,
        ltcir: 10873,
        ltdot: 8918,
        ltrie: 8884,
        ltrif: 9666,
        mDDot: 8762,
        mdash: 8212,
        micro: 181,
        minus: 8722,
        mumap: 8888,
        nabla: 8711,
        napos: 329,
        natur: 9838,
        ncong: 8775,
        ndash: 8211,
        neArr: 8663,
        nearr: 8599,
        ngsim: 8821,
        nhArr: 8654,
        nharr: 8622,
        nhpar: 10994,
        nlArr: 8653,
        nlarr: 8602,
        nless: 8814,
        nlsim: 8820,
        nltri: 8938,
        notin: 8713,
        notni: 8716,
        nprec: 8832,
        nrArr: 8655,
        nrarr: 8603,
        nrtri: 8939,
        nsime: 8772,
        nsmid: 8740,
        nspar: 8742,
        nsube: 8840,
        nsucc: 8833,
        nsupe: 8841,
        numsp: 8199,
        nwArr: 8662,
        nwarr: 8598,
        ocirc: 244,
        odash: 8861,
        oelig: 339,
        ofcir: 10687,
        ohbar: 10677,
        olarr: 8634,
        olcir: 10686,
        oline: 8254,
        omacr: 333,
        omega: 969,
        operp: 10681,
        oplus: 8853,
        orarr: 8635,
        order: 8500,
        ovbar: 9021,
        parsl: 11005,
        phone: 9742,
        plusb: 8862,
        pluse: 10866,
        pound: 163,
        prcue: 8828,
        prime: 8242,
        prnap: 10937,
        prsim: 8830,
        quest: 63,
        rAarr: 8667,
        rBarr: 10511,
        radic: 8730,
        rangd: 10642,
        range: 10661,
        raquo: 187,
        rarrb: 8677,
        rarrc: 10547,
        rarrw: 8605,
        ratio: 8758,
        rbarr: 10509,
        rbbrk: 10099,
        rbrke: 10636,
        rceil: 8969,
        rdquo: 8221,
        reals: 8477,
        rhard: 8641,
        rharu: 8640,
        rlarr: 8644,
        rlhar: 8652,
        rnmid: 10990,
        roang: 10221,
        roarr: 8702,
        robrk: 10215,
        ropar: 10630,
        rrarr: 8649,
        rsquo: 8217,
        rtrie: 8885,
        rtrif: 9656,
        sbquo: 8218,
        sccue: 8829,
        scirc: 349,
        scnap: 10938,
        scsim: 8831,
        sdotb: 8865,
        sdote: 10854,
        seArr: 8664,
        searr: 8600,
        setmn: 8726,
        sharp: 9839,
        sigma: 963,
        simeq: 8771,
        simgE: 10912,
        simlE: 10911,
        simne: 8774,
        slarr: 8592,
        smile: 8995,
        sqcap: 8851,
        sqcup: 8852,
        sqsub: 8847,
        sqsup: 8848,
        srarr: 8594,
        starf: 9733,
        strns: 175,
        subnE: 10955,
        subne: 8842,
        supnE: 10956,
        supne: 8843,
        swArr: 8665,
        swarr: 8601,
        szlig: 223,
        theta: 952,
        thkap: 8776,
        thorn: 254,
        tilde: 732,
        times: 215,
        trade: 8482,
        trisb: 10701,
        tshcy: 1115,
        twixt: 8812,
        ubrcy: 1118,
        ucirc: 251,
        udarr: 8645,
        udhar: 10606,
        uharl: 8639,
        uharr: 8638,
        uhblk: 9600,
        ultri: 9720,
        umacr: 363,
        uogon: 371,
        uplus: 8846,
        upsih: 978,
        uring: 367,
        urtri: 9721,
        utdot: 8944,
        utrif: 9652,
        uuarr: 8648,
        vBarv: 10985,
        vDash: 8872,
        varpi: 982,
        vdash: 8866,
        veeeq: 8794,
        vltri: 8882,
        vprop: 8733,
        vrtri: 8883,
        wcirc: 373,
        wedge: 8743,
        xcirc: 9711,
        xdtri: 9661,
        xhArr: 10234,
        xharr: 10231,
        xlArr: 10232,
        xlarr: 10229,
        xodot: 10752,
        xrArr: 10233,
        xrarr: 10230,
        xutri: 9651,
        ycirc: 375,
        Aopf: 120120,
        Ascr: 119964,
        Auml: 196,
        Barv: 10983,
        Beta: 914,
        Bopf: 120121,
        Bscr: 8492,
        CHcy: 1063,
        COPY: 169,
        Cdot: 266,
        Copf: 8450,
        Cscr: 119966,
        DJcy: 1026,
        DScy: 1029,
        DZcy: 1039,
        Darr: 8609,
        Dopf: 120123,
        Dscr: 119967,
        Edot: 278,
        Eopf: 120124,
        Escr: 8496,
        Esim: 10867,
        Euml: 203,
        Fopf: 120125,
        Fscr: 8497,
        GJcy: 1027,
        Gdot: 288,
        Gopf: 120126,
        Gscr: 119970,
        Hopf: 8461,
        Hscr: 8459,
        IEcy: 1045,
        IOcy: 1025,
        Idot: 304,
        Iopf: 120128,
        Iota: 921,
        Iscr: 8464,
        Iuml: 207,
        Jopf: 120129,
        Jscr: 119973,
        KHcy: 1061,
        KJcy: 1036,
        Kopf: 120130,
        Kscr: 119974,
        LJcy: 1033,
        Lang: 10218,
        Larr: 8606,
        Lopf: 120131,
        Lscr: 8466,
        Mopf: 120132,
        Mscr: 8499,
        NJcy: 1034,
        Nopf: 8469,
        Nscr: 119977,
        Oopf: 120134,
        Oscr: 119978,
        Ouml: 214,
        Popf: 8473,
        Pscr: 119979,
        QUOT: 34,
        Qopf: 8474,
        Qscr: 119980,
        Rang: 10219,
        Rarr: 8608,
        Ropf: 8477,
        Rscr: 8475,
        SHcy: 1064,
        Sopf: 120138,
        Sqrt: 8730,
        Sscr: 119982,
        Star: 8902,
        TScy: 1062,
        Topf: 120139,
        Tscr: 119983,
        Uarr: 8607,
        Uopf: 120140,
        Upsi: 978,
        Uscr: 119984,
        Uuml: 220,
        Vbar: 10987,
        Vert: 8214,
        Vopf: 120141,
        Vscr: 119985,
        Wopf: 120142,
        Wscr: 119986,
        Xopf: 120143,
        Xscr: 119987,
        YAcy: 1071,
        YIcy: 1031,
        YUcy: 1070,
        Yopf: 120144,
        Yscr: 119988,
        Yuml: 376,
        ZHcy: 1046,
        Zdot: 379,
        Zeta: 918,
        Zopf: 8484,
        Zscr: 119989,
        andd: 10844,
        andv: 10842,
        ange: 10660,
        aopf: 120146,
        apid: 8779,
        apos: 39,
        ascr: 119990,
        auml: 228,
        bNot: 10989,
        bbrk: 9141,
        beta: 946,
        beth: 8502,
        bnot: 8976,
        bopf: 120147,
        boxH: 9552,
        boxV: 9553,
        boxh: 9472,
        boxv: 9474,
        bscr: 119991,
        bsim: 8765,
        bsol: 92,
        bull: 8226,
        bump: 8782,
        cdot: 267,
        cent: 162,
        chcy: 1095,
        cirE: 10691,
        circ: 710,
        cire: 8791,
        comp: 8705,
        cong: 8773,
        copf: 120148,
        copy: 169,
        cscr: 119992,
        csub: 10959,
        csup: 10960,
        dArr: 8659,
        dHar: 10597,
        darr: 8595,
        dash: 8208,
        diam: 8900,
        djcy: 1106,
        dopf: 120149,
        dscr: 119993,
        dscy: 1109,
        dsol: 10742,
        dtri: 9663,
        dzcy: 1119,
        eDot: 8785,
        ecir: 8790,
        edot: 279,
        emsp: 8195,
        ensp: 8194,
        eopf: 120150,
        epar: 8917,
        epsi: 1013,
        escr: 8495,
        esim: 8770,
        euml: 235,
        euro: 8364,
        excl: 33,
        flat: 9837,
        fnof: 402,
        fopf: 120151,
        fork: 8916,
        fscr: 119995,
        gdot: 289,
        geqq: 8807,
        gjcy: 1107,
        gnap: 10890,
        gneq: 10888,
        gopf: 120152,
        gscr: 8458,
        gsim: 8819,
        gtcc: 10919,
        hArr: 8660,
        half: 189,
        harr: 8596,
        hbar: 8463,
        hopf: 120153,
        hscr: 119997,
        iecy: 1077,
        imof: 8887,
        iocy: 1105,
        iopf: 120154,
        iota: 953,
        iscr: 119998,
        isin: 8712,
        iuml: 239,
        jopf: 120155,
        jscr: 119999,
        khcy: 1093,
        kjcy: 1116,
        kopf: 120156,
        kscr: 12e4,
        lArr: 8656,
        lHar: 10594,
        lang: 10216,
        larr: 8592,
        late: 10925,
        lcub: 123,
        ldca: 10550,
        ldsh: 8626,
        leqq: 8806,
        ljcy: 1113,
        lnap: 10889,
        lneq: 10887,
        lopf: 120157,
        lozf: 10731,
        lpar: 40,
        lscr: 120001,
        lsim: 8818,
        lsqb: 91,
        ltcc: 10918,
        ltri: 9667,
        macr: 175,
        male: 9794,
        malt: 10016,
        mlcp: 10971,
        mldr: 8230,
        mopf: 120158,
        mscr: 120002,
        nbsp: 160,
        ncap: 10819,
        ncup: 10818,
        ngeq: 8817,
        ngtr: 8815,
        nisd: 8954,
        njcy: 1114,
        nldr: 8229,
        nleq: 8816,
        nmid: 8740,
        nopf: 120159,
        npar: 8742,
        nscr: 120003,
        nsim: 8769,
        nsub: 8836,
        nsup: 8837,
        ntgl: 8825,
        ntlg: 8824,
        oast: 8859,
        ocir: 8858,
        odiv: 10808,
        odot: 8857,
        ogon: 731,
        oint: 8750,
        omid: 10678,
        oopf: 120160,
        opar: 10679,
        ordf: 170,
        ordm: 186,
        oror: 10838,
        oscr: 8500,
        osol: 8856,
        ouml: 246,
        para: 182,
        part: 8706,
        perp: 8869,
        phiv: 966,
        plus: 43,
        popf: 120161,
        prap: 10935,
        prec: 8826,
        prnE: 10933,
        prod: 8719,
        prop: 8733,
        pscr: 120005,
        qint: 10764,
        qopf: 120162,
        qscr: 120006,
        quot: 34,
        rArr: 8658,
        rHar: 10596,
        race: 10714,
        rang: 10217,
        rarr: 8594,
        rcub: 125,
        rdca: 10551,
        rdsh: 8627,
        real: 8476,
        rect: 9645,
        rhov: 1009,
        ring: 730,
        ropf: 120163,
        rpar: 41,
        rscr: 120007,
        rsqb: 93,
        rtri: 9657,
        scap: 10936,
        scnE: 10934,
        sdot: 8901,
        sect: 167,
        semi: 59,
        sext: 10038,
        shcy: 1096,
        sime: 8771,
        simg: 10910,
        siml: 10909,
        smid: 8739,
        smte: 10924,
        solb: 10692,
        sopf: 120164,
        spar: 8741,
        squf: 9642,
        sscr: 120008,
        star: 9734,
        subE: 10949,
        sube: 8838,
        succ: 8827,
        sung: 9834,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        supE: 10950,
        supe: 8839,
        tbrk: 9140,
        tdot: 8411,
        tint: 8749,
        toea: 10536,
        topf: 120165,
        tosa: 10537,
        trie: 8796,
        tscr: 120009,
        tscy: 1094,
        uArr: 8657,
        uHar: 10595,
        uarr: 8593,
        uopf: 120166,
        upsi: 965,
        uscr: 120010,
        utri: 9653,
        uuml: 252,
        vArr: 8661,
        vBar: 10984,
        varr: 8597,
        vert: 124,
        vopf: 120167,
        vscr: 120011,
        wopf: 120168,
        wscr: 120012,
        xcap: 8898,
        xcup: 8899,
        xmap: 10236,
        xnis: 8955,
        xopf: 120169,
        xscr: 120013,
        xvee: 8897,
        yacy: 1103,
        yicy: 1111,
        yopf: 120170,
        yscr: 120014,
        yucy: 1102,
        yuml: 255,
        zdot: 380,
        zeta: 950,
        zhcy: 1078,
        zopf: 120171,
        zscr: 120015,
        zwnj: 8204,
        AMP: 38,
        Acy: 1040,
        Afr: 120068,
        And: 10835,
        Bcy: 1041,
        Bfr: 120069,
        Cap: 8914,
        Cfr: 8493,
        Chi: 935,
        Cup: 8915,
        Dcy: 1044,
        Del: 8711,
        Dfr: 120071,
        Dot: 168,
        ENG: 330,
        ETH: 208,
        Ecy: 1069,
        Efr: 120072,
        Eta: 919,
        Fcy: 1060,
        Ffr: 120073,
        Gcy: 1043,
        Gfr: 120074,
        Hat: 94,
        Hfr: 8460,
        Icy: 1048,
        Ifr: 8465,
        Int: 8748,
        Jcy: 1049,
        Jfr: 120077,
        Kcy: 1050,
        Kfr: 120078,
        Lcy: 1051,
        Lfr: 120079,
        Lsh: 8624,
        Map: 10501,
        Mcy: 1052,
        Mfr: 120080,
        Ncy: 1053,
        Nfr: 120081,
        Not: 10988,
        Ocy: 1054,
        Ofr: 120082,
        Pcy: 1055,
        Pfr: 120083,
        Phi: 934,
        Psi: 936,
        Qfr: 120084,
        REG: 174,
        Rcy: 1056,
        Rfr: 8476,
        Rho: 929,
        Rsh: 8625,
        Scy: 1057,
        Sfr: 120086,
        Sub: 8912,
        Sum: 8721,
        Sup: 8913,
        Tab: 9,
        Tau: 932,
        Tcy: 1058,
        Tfr: 120087,
        Ucy: 1059,
        Ufr: 120088,
        Vcy: 1042,
        Vee: 8897,
        Vfr: 120089,
        Wfr: 120090,
        Xfr: 120091,
        Ycy: 1067,
        Yfr: 120092,
        Zcy: 1047,
        Zfr: 8488,
        acd: 8767,
        acy: 1072,
        afr: 120094,
        amp: 38,
        and: 8743,
        ang: 8736,
        apE: 10864,
        ape: 8778,
        ast: 42,
        bcy: 1073,
        bfr: 120095,
        bot: 8869,
        cap: 8745,
        cfr: 120096,
        chi: 967,
        cir: 9675,
        cup: 8746,
        dcy: 1076,
        deg: 176,
        dfr: 120097,
        die: 168,
        div: 247,
        dot: 729,
        ecy: 1101,
        efr: 120098,
        egs: 10902,
        ell: 8467,
        els: 10901,
        eng: 331,
        eta: 951,
        eth: 240,
        fcy: 1092,
        ffr: 120099,
        gEl: 10892,
        gap: 10886,
        gcy: 1075,
        gel: 8923,
        geq: 8805,
        ges: 10878,
        gfr: 120100,
        ggg: 8921,
        glE: 10898,
        gla: 10917,
        glj: 10916,
        gnE: 8809,
        gne: 10888,
        hfr: 120101,
        icy: 1080,
        iff: 8660,
        ifr: 120102,
        int: 8747,
        jcy: 1081,
        jfr: 120103,
        kcy: 1082,
        kfr: 120104,
        lEg: 10891,
        lap: 10885,
        lat: 10923,
        lcy: 1083,
        leg: 8922,
        leq: 8804,
        les: 10877,
        lfr: 120105,
        lgE: 10897,
        lnE: 8808,
        lne: 10887,
        loz: 9674,
        lrm: 8206,
        lsh: 8624,
        map: 8614,
        mcy: 1084,
        mfr: 120106,
        mho: 8487,
        mid: 8739,
        nap: 8777,
        ncy: 1085,
        nfr: 120107,
        nge: 8817,
        ngt: 8815,
        nis: 8956,
        niv: 8715,
        nle: 8816,
        nlt: 8814,
        not: 172,
        npr: 8832,
        nsc: 8833,
        num: 35,
        ocy: 1086,
        ofr: 120108,
        ogt: 10689,
        ohm: 8486,
        olt: 10688,
        ord: 10845,
        orv: 10843,
        par: 8741,
        pcy: 1087,
        pfr: 120109,
        phi: 966,
        piv: 982,
        prE: 10931,
        pre: 10927,
        psi: 968,
        qfr: 120110,
        rcy: 1088,
        reg: 174,
        rfr: 120111,
        rho: 961,
        rlm: 8207,
        rsh: 8625,
        scE: 10932,
        sce: 10928,
        scy: 1089,
        sfr: 120112,
        shy: 173,
        sim: 8764,
        smt: 10922,
        sol: 47,
        squ: 9633,
        sub: 8834,
        sum: 8721,
        sup: 8835,
        tau: 964,
        tcy: 1090,
        tfr: 120113,
        top: 8868,
        ucy: 1091,
        ufr: 120114,
        uml: 168,
        vcy: 1074,
        vee: 8744,
        vfr: 120115,
        wfr: 120116,
        xfr: 120117,
        ycy: 1099,
        yen: 165,
        yfr: 120118,
        zcy: 1079,
        zfr: 120119,
        zwj: 8205,
        DD: 8517,
        GT: 62,
        Gg: 8921,
        Gt: 8811,
        Im: 8465,
        LT: 60,
        Ll: 8920,
        Lt: 8810,
        Mu: 924,
        Nu: 925,
        Or: 10836,
        Pi: 928,
        Pr: 10939,
        Re: 8476,
        Sc: 10940,
        Xi: 926,
        ac: 8766,
        af: 8289,
        ap: 8776,
        dd: 8518,
        ee: 8519,
        eg: 10906,
        el: 10905,
        gE: 8807,
        ge: 8805,
        gg: 8811,
        gl: 8823,
        gt: 62,
        ic: 8291,
        ii: 8520,
        in: 8712,
        it: 8290,
        lE: 8806,
        le: 8804,
        lg: 8822,
        ll: 8810,
        lt: 60,
        mp: 8723,
        mu: 956,
        ne: 8800,
        ni: 8715,
        nu: 957,
        oS: 9416,
        or: 8744,
        pi: 960,
        pm: 177,
        pr: 8826,
        rx: 8478,
        sc: 8827,
        wp: 8472,
        wr: 8768,
        xi: 958
      };
      const windows_1252 = [
        8364,
        129,
        8218,
        402,
        8222,
        8230,
        8224,
        8225,
        710,
        8240,
        352,
        8249,
        338,
        141,
        381,
        143,
        144,
        8216,
        8217,
        8220,
        8221,
        8226,
        8211,
        8212,
        732,
        8482,
        353,
        8250,
        339,
        157,
        382,
        376
      ];
      const entity_pattern = new RegExp(`&(#?(?:x[\\w\\d]+|\\d+|${Object.keys(entities).join("|")}))(?:;|\\b)`, "g");
      function decode_character_references(html2) {
        return html2.replace(entity_pattern, (match, entity) => {
          let code;
          if (entity[0] !== "#") {
            code = entities[entity];
          } else if (entity[1] === "x") {
            code = parseInt(entity.substring(2), 16);
          } else {
            code = parseInt(entity.substring(1), 10);
          }
          if (!code) {
            return match;
          }
          return String.fromCodePoint(validate_code(code));
        });
      }
      const NUL = 0;
      function validate_code(code) {
        if (code === 10) {
          return 32;
        }
        if (code < 128) {
          return code;
        }
        if (code <= 159) {
          return windows_1252[code - 128];
        }
        if (code < 55296) {
          return code;
        }
        if (code <= 57343) {
          return NUL;
        }
        if (code <= 65535) {
          return code;
        }
        if (code >= 65536 && code <= 131071) {
          return code;
        }
        if (code >= 131072 && code <= 196607) {
          return code;
        }
        return NUL;
      }
      const disallowed_contents = new Map([
        ["li", new Set(["li"])],
        ["dt", new Set(["dt", "dd"])],
        ["dd", new Set(["dt", "dd"])],
        [
          "p",
          new Set("address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "))
        ],
        ["rt", new Set(["rt", "rp"])],
        ["rp", new Set(["rt", "rp"])],
        ["optgroup", new Set(["optgroup"])],
        ["option", new Set(["option", "optgroup"])],
        ["thead", new Set(["tbody", "tfoot"])],
        ["tbody", new Set(["tbody", "tfoot"])],
        ["tfoot", new Set(["tbody"])],
        ["tr", new Set(["tr", "tbody"])],
        ["td", new Set(["td", "th", "tr"])],
        ["th", new Set(["td", "th", "tr"])]
      ]);
      function closing_tag_omitted(current, next) {
        if (disallowed_contents.has(current)) {
          if (!next || disallowed_contents.get(current).has(next)) {
            return true;
          }
        }
        return false;
      }
      function full_char_code_at(str2, i2) {
        const code = str2.charCodeAt(i2);
        if (code <= 55295 || code >= 57344)
          return code;
        const next = str2.charCodeAt(i2 + 1);
        return (code << 10) + next - 56613888;
      }
      const globals = new Set([
        "alert",
        "Array",
        "Boolean",
        "clearInterval",
        "clearTimeout",
        "confirm",
        "console",
        "Date",
        "decodeURI",
        "decodeURIComponent",
        "document",
        "Element",
        "encodeURI",
        "encodeURIComponent",
        "Error",
        "EvalError",
        "Event",
        "EventSource",
        "fetch",
        "global",
        "globalThis",
        "history",
        "Infinity",
        "InternalError",
        "Intl",
        "isFinite",
        "isNaN",
        "JSON",
        "localStorage",
        "location",
        "Map",
        "Math",
        "NaN",
        "navigator",
        "Number",
        "Node",
        "Object",
        "parseFloat",
        "parseInt",
        "process",
        "Promise",
        "prompt",
        "RangeError",
        "ReferenceError",
        "RegExp",
        "sessionStorage",
        "Set",
        "setInterval",
        "setTimeout",
        "String",
        "SyntaxError",
        "TypeError",
        "undefined",
        "URIError",
        "URL",
        "window"
      ]);
      const reserved2 = new Set([
        "arguments",
        "await",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "enum",
        "eval",
        "export",
        "extends",
        "false",
        "finally",
        "for",
        "function",
        "if",
        "implements",
        "import",
        "in",
        "instanceof",
        "interface",
        "let",
        "new",
        "null",
        "package",
        "private",
        "protected",
        "public",
        "return",
        "static",
        "super",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ]);
      const void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
      function is_void(name) {
        return void_element_names.test(name) || name.toLowerCase() === "!doctype";
      }
      function is_valid(str2) {
        let i2 = 0;
        while (i2 < str2.length) {
          const code = full_char_code_at(str2, i2);
          if (!(i2 === 0 ? isIdentifierStart : isIdentifierChar)(code, true))
            return false;
          i2 += code <= 65535 ? 1 : 2;
        }
        return true;
      }
      function sanitize(name) {
        return name.replace(/[^a-zA-Z0-9_]+/g, "_").replace(/^_/, "").replace(/_$/, "").replace(/^[0-9]/, "_$&");
      }
      function fuzzymatch(name, names2) {
        const set = new FuzzySet(names2);
        const matches2 = set.get(name);
        return matches2 && matches2[0] && matches2[0][0] > 0.7 ? matches2[0][1] : null;
      }
      const GRAM_SIZE_LOWER = 2;
      const GRAM_SIZE_UPPER = 3;
      function _distance(str1, str2) {
        if (str1 === null && str2 === null) {
          throw "Trying to compare two null values";
        }
        if (str1 === null || str2 === null)
          return 0;
        str1 = String(str1);
        str2 = String(str2);
        const distance = levenshtein(str1, str2);
        if (str1.length > str2.length) {
          return 1 - distance / str1.length;
        } else {
          return 1 - distance / str2.length;
        }
      }
      function levenshtein(str1, str2) {
        const current = [];
        let prev;
        let value2;
        for (let i2 = 0; i2 <= str2.length; i2++) {
          for (let j = 0; j <= str1.length; j++) {
            if (i2 && j) {
              if (str1.charAt(j - 1) === str2.charAt(i2 - 1)) {
                value2 = prev;
              } else {
                value2 = Math.min(current[j], current[j - 1], prev) + 1;
              }
            } else {
              value2 = i2 + j;
            }
            prev = current[j];
            current[j] = value2;
          }
        }
        return current.pop();
      }
      const non_word_regex = /[^\w, ]+/;
      function iterate_grams(value2, gram_size = 2) {
        const simplified = "-" + value2.toLowerCase().replace(non_word_regex, "") + "-";
        const len_diff = gram_size - simplified.length;
        const results = [];
        if (len_diff > 0) {
          for (let i2 = 0; i2 < len_diff; ++i2) {
            value2 += "-";
          }
        }
        for (let i2 = 0; i2 < simplified.length - gram_size + 1; ++i2) {
          results.push(simplified.slice(i2, i2 + gram_size));
        }
        return results;
      }
      function gram_counter(value2, gram_size = 2) {
        const result = {};
        const grams = iterate_grams(value2, gram_size);
        let i2 = 0;
        for (i2; i2 < grams.length; ++i2) {
          if (grams[i2] in result) {
            result[grams[i2]] += 1;
          } else {
            result[grams[i2]] = 1;
          }
        }
        return result;
      }
      function sort_descending(a, b2) {
        return b2[0] - a[0];
      }
      class FuzzySet {
        constructor(arr) {
          this.exact_set = {};
          this.match_dict = {};
          this.items = {};
          for (let i2 = GRAM_SIZE_LOWER; i2 < GRAM_SIZE_UPPER + 1; ++i2) {
            this.items[i2] = [];
          }
          for (let i2 = 0; i2 < arr.length; ++i2) {
            this.add(arr[i2]);
          }
        }
        add(value2) {
          const normalized_value = value2.toLowerCase();
          if (normalized_value in this.exact_set) {
            return false;
          }
          let i2 = GRAM_SIZE_LOWER;
          for (i2; i2 < GRAM_SIZE_UPPER + 1; ++i2) {
            this._add(value2, i2);
          }
        }
        _add(value2, gram_size) {
          const normalized_value = value2.toLowerCase();
          const items = this.items[gram_size] || [];
          const index2 = items.length;
          items.push(0);
          const gram_counts = gram_counter(normalized_value, gram_size);
          let sum_of_square_gram_counts = 0;
          let gram;
          let gram_count;
          for (gram in gram_counts) {
            gram_count = gram_counts[gram];
            sum_of_square_gram_counts += Math.pow(gram_count, 2);
            if (gram in this.match_dict) {
              this.match_dict[gram].push([index2, gram_count]);
            } else {
              this.match_dict[gram] = [[index2, gram_count]];
            }
          }
          const vector_normal = Math.sqrt(sum_of_square_gram_counts);
          items[index2] = [vector_normal, normalized_value];
          this.items[gram_size] = items;
          this.exact_set[normalized_value] = value2;
        }
        get(value2) {
          const normalized_value = value2.toLowerCase();
          const result = this.exact_set[normalized_value];
          if (result) {
            return [[1, result]];
          }
          let results = [];
          for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
            results = this.__get(value2, gram_size);
            if (results) {
              return results;
            }
          }
          return null;
        }
        __get(value2, gram_size) {
          const normalized_value = value2.toLowerCase();
          const matches2 = {};
          const gram_counts = gram_counter(normalized_value, gram_size);
          const items = this.items[gram_size];
          let sum_of_square_gram_counts = 0;
          let gram;
          let gram_count;
          let i2;
          let index2;
          let other_gram_count;
          for (gram in gram_counts) {
            gram_count = gram_counts[gram];
            sum_of_square_gram_counts += Math.pow(gram_count, 2);
            if (gram in this.match_dict) {
              for (i2 = 0; i2 < this.match_dict[gram].length; ++i2) {
                index2 = this.match_dict[gram][i2][0];
                other_gram_count = this.match_dict[gram][i2][1];
                if (index2 in matches2) {
                  matches2[index2] += gram_count * other_gram_count;
                } else {
                  matches2[index2] = gram_count * other_gram_count;
                }
              }
            }
          }
          const vector_normal = Math.sqrt(sum_of_square_gram_counts);
          let results = [];
          let match_score;
          for (const match_index in matches2) {
            match_score = matches2[match_index];
            results.push([
              match_score / (vector_normal * items[match_index][0]),
              items[match_index][1]
            ]);
          }
          results.sort(sort_descending);
          let new_results = [];
          const end_index = Math.min(50, results.length);
          for (let i3 = 0; i3 < end_index; ++i3) {
            new_results.push([
              _distance(results[i3][1], normalized_value),
              results[i3][1]
            ]);
          }
          results = new_results;
          results.sort(sort_descending);
          new_results = [];
          for (let i3 = 0; i3 < results.length; ++i3) {
            if (results[i3][0] == results[0][0]) {
              new_results.push([results[i3][0], this.exact_set[results[i3][1]]]);
            }
          }
          return new_results;
        }
      }
      function flatten$1(nodes, target = []) {
        for (let i2 = 0; i2 < nodes.length; i2 += 1) {
          const node2 = nodes[i2];
          if (Array.isArray(node2)) {
            flatten$1(node2, target);
          } else {
            target.push(node2);
          }
        }
        return target;
      }
      const pattern = /^\s*svelte-ignore\s+([\s\S]+)\s*$/m;
      function extract_svelte_ignore(text2) {
        const match = pattern.exec(text2);
        return match ? match[1].split(/[^\S]/).map((x2) => x2.trim()).filter(Boolean) : [];
      }
      function extract_svelte_ignore_from_comments(node2) {
        return flatten$1((node2.leadingComments || []).map((comment) => extract_svelte_ignore(comment.value)));
      }
      function extract_ignores_above_position(position, template_nodes) {
        const previous_node_idx = template_nodes.findIndex((child) => child.end === position);
        if (previous_node_idx === -1) {
          return [];
        }
        for (let i2 = previous_node_idx; i2 >= 0; i2--) {
          const node2 = template_nodes[i2];
          if (node2.type !== "Comment" && node2.type !== "Text") {
            return [];
          }
          if (node2.type === "Comment") {
            if (node2.ignores.length) {
              return node2.ignores;
            }
          }
        }
        return [];
      }
      const valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
      const meta_tags = new Map([
        ["svelte:head", "Head"],
        ["svelte:options", "Options"],
        ["svelte:window", "Window"],
        ["svelte:body", "Body"]
      ]);
      const valid_meta_tags = Array.from(meta_tags.keys()).concat("svelte:self", "svelte:component", "svelte:fragment");
      const specials = new Map([
        [
          "script",
          {
            read: read_script,
            property: "js"
          }
        ],
        [
          "style",
          {
            read: read_style,
            property: "css"
          }
        ]
      ]);
      const SELF = /^svelte:self(?=[\s/>])/;
      const COMPONENT = /^svelte:component(?=[\s/>])/;
      const SLOT = /^svelte:fragment(?=[\s/>])/;
      function parent_is_head(stack) {
        let i2 = stack.length;
        while (i2--) {
          const { type } = stack[i2];
          if (type === "Head")
            return true;
          if (type === "Element" || type === "InlineComponent")
            return false;
        }
        return false;
      }
      function tag(parser2) {
        const start = parser2.index++;
        let parent = parser2.current();
        if (parser2.eat("!--")) {
          const data2 = parser2.read_until(/-->/);
          parser2.eat("-->", true, parser_errors.unclosed_comment);
          parser2.current().children.push({
            start,
            end: parser2.index,
            type: "Comment",
            data: data2,
            ignores: extract_svelte_ignore(data2)
          });
          return;
        }
        const is_closing_tag = parser2.eat("/");
        const name = read_tag_name(parser2);
        if (meta_tags.has(name)) {
          const slug = meta_tags.get(name).toLowerCase();
          if (is_closing_tag) {
            if ((name === "svelte:window" || name === "svelte:body") && parser2.current().children.length) {
              parser2.error(parser_errors.invalid_element_content(slug, name), parser2.current().children[0].start);
            }
          } else {
            if (name in parser2.meta_tags) {
              parser2.error(parser_errors.duplicate_element(slug, name), start);
            }
            if (parser2.stack.length > 1) {
              parser2.error(parser_errors.invalid_element_placement(slug, name), start);
            }
            parser2.meta_tags[name] = true;
          }
        }
        const type = meta_tags.has(name) ? meta_tags.get(name) : /[A-Z]/.test(name[0]) || name === "svelte:self" || name === "svelte:component" ? "InlineComponent" : name === "svelte:fragment" ? "SlotTemplate" : name === "title" && parent_is_head(parser2.stack) ? "Title" : name === "slot" && !parser2.customElement ? "Slot" : "Element";
        const element = {
          start,
          end: null,
          type,
          name,
          attributes: [],
          children: []
        };
        parser2.allow_whitespace();
        if (is_closing_tag) {
          if (is_void(name)) {
            parser2.error(parser_errors.invalid_void_content(name), start);
          }
          parser2.eat(">", true);
          while (parent.name !== name) {
            if (parent.type !== "Element") {
              const error4 = parser2.last_auto_closed_tag && parser2.last_auto_closed_tag.tag === name ? parser_errors.invalid_closing_tag_autoclosed(name, parser2.last_auto_closed_tag.reason) : parser_errors.invalid_closing_tag_unopened(name);
              parser2.error(error4, start);
            }
            parent.end = start;
            parser2.stack.pop();
            parent = parser2.current();
          }
          parent.end = parser2.index;
          parser2.stack.pop();
          if (parser2.last_auto_closed_tag && parser2.stack.length < parser2.last_auto_closed_tag.depth) {
            parser2.last_auto_closed_tag = null;
          }
          return;
        } else if (closing_tag_omitted(parent.name, name)) {
          parent.end = start;
          parser2.stack.pop();
          parser2.last_auto_closed_tag = {
            tag: parent.name,
            reason: name,
            depth: parser2.stack.length
          };
        }
        const unique_names = new Set();
        let attribute;
        while (attribute = read_attribute(parser2, unique_names)) {
          element.attributes.push(attribute);
          parser2.allow_whitespace();
        }
        if (name === "svelte:component") {
          const index2 = element.attributes.findIndex((attr) => attr.type === "Attribute" && attr.name === "this");
          if (!~index2) {
            parser2.error(parser_errors.missing_component_definition, start);
          }
          const definition = element.attributes.splice(index2, 1)[0];
          if (definition.value === true || definition.value.length !== 1 || definition.value[0].type === "Text") {
            parser2.error(parser_errors.invalid_component_definition, definition.start);
          }
          element.expression = definition.value[0].expression;
        }
        if (specials.has(name) && parser2.stack.length === 1) {
          const special = specials.get(name);
          parser2.eat(">", true);
          const content = special.read(parser2, start, element.attributes);
          if (content)
            parser2[special.property].push(content);
          return;
        }
        parser2.current().children.push(element);
        const self_closing = parser2.eat("/") || is_void(name);
        parser2.eat(">", true);
        if (self_closing) {
          element.end = parser2.index;
        } else if (name === "textarea") {
          element.children = read_sequence(parser2, () => /^<\/textarea(\s[^>]*)?>/i.test(parser2.template.slice(parser2.index)));
          parser2.read(/^<\/textarea(\s[^>]*)?>/i);
          element.end = parser2.index;
        } else if (name === "script" || name === "style") {
          const start2 = parser2.index;
          const data2 = parser2.read_until(new RegExp(`</${name}>`));
          const end = parser2.index;
          element.children.push({ start: start2, end, type: "Text", data: data2 });
          parser2.eat(`</${name}>`, true);
          element.end = parser2.index;
        } else {
          parser2.stack.push(element);
        }
      }
      function read_tag_name(parser2) {
        const start = parser2.index;
        if (parser2.read(SELF)) {
          let i2 = parser2.stack.length;
          let legal = false;
          while (i2--) {
            const fragment2 = parser2.stack[i2];
            if (fragment2.type === "IfBlock" || fragment2.type === "EachBlock" || fragment2.type === "InlineComponent") {
              legal = true;
              break;
            }
          }
          if (!legal) {
            parser2.error(parser_errors.invalid_self_placement, start);
          }
          return "svelte:self";
        }
        if (parser2.read(COMPONENT))
          return "svelte:component";
        if (parser2.read(SLOT))
          return "svelte:fragment";
        const name = parser2.read_until(/(\s|\/|>)/);
        if (meta_tags.has(name))
          return name;
        if (name.startsWith("svelte:")) {
          const match = fuzzymatch(name.slice(7), valid_meta_tags);
          parser2.error(parser_errors.invalid_tag_name_svelte_element(valid_meta_tags, match), start);
        }
        if (!valid_tag_name.test(name)) {
          parser2.error(parser_errors.invalid_tag_name, start);
        }
        return name;
      }
      function read_attribute(parser2, unique_names) {
        const start = parser2.index;
        function check_unique(name2) {
          if (unique_names.has(name2)) {
            parser2.error(parser_errors.duplicate_attribute, start);
          }
          unique_names.add(name2);
        }
        if (parser2.eat("{")) {
          parser2.allow_whitespace();
          if (parser2.eat("...")) {
            const expression2 = read_expression(parser2);
            parser2.allow_whitespace();
            parser2.eat("}", true);
            return {
              start,
              end: parser2.index,
              type: "Spread",
              expression: expression2
            };
          } else {
            const value_start = parser2.index;
            const name2 = parser2.read_identifier();
            parser2.allow_whitespace();
            parser2.eat("}", true);
            if (name2 === null) {
              parser2.error(parser_errors.empty_attribute_shorthand, start);
            }
            check_unique(name2);
            return {
              start,
              end: parser2.index,
              type: "Attribute",
              name: name2,
              value: [{
                start: value_start,
                end: value_start + name2.length,
                type: "AttributeShorthand",
                expression: {
                  start: value_start,
                  end: value_start + name2.length,
                  type: "Identifier",
                  name: name2
                }
              }]
            };
          }
        }
        const name = parser2.read_until(/[\s=\/>"']/);
        if (!name)
          return null;
        let end = parser2.index;
        parser2.allow_whitespace();
        const colon_index = name.indexOf(":");
        const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));
        let value2 = true;
        if (parser2.eat("=")) {
          parser2.allow_whitespace();
          value2 = read_attribute_value(parser2);
          end = parser2.index;
        } else if (parser2.match_regex(/["']/)) {
          parser2.error(parser_errors.unexpected_token("="), parser2.index);
        }
        if (type) {
          const [directive_name, ...modifiers] = name.slice(colon_index + 1).split("|");
          if (directive_name === "") {
            parser2.error(parser_errors.empty_directive_name(type), start + colon_index + 1);
          }
          if (type === "Binding" && directive_name !== "this") {
            check_unique(directive_name);
          } else if (type !== "EventHandler" && type !== "Action") {
            check_unique(name);
          }
          if (type === "Ref") {
            parser2.error(parser_errors.invalid_ref_directive(directive_name), start);
          }
          if (value2[0]) {
            if (value2.length > 1 || value2[0].type === "Text") {
              parser2.error(parser_errors.invalid_directive_value, value2[0].start);
            }
          }
          const directive = {
            start,
            end,
            type,
            name: directive_name,
            modifiers,
            expression: value2[0] && value2[0].expression || null
          };
          if (type === "Transition") {
            const direction = name.slice(0, colon_index);
            directive.intro = direction === "in" || direction === "transition";
            directive.outro = direction === "out" || direction === "transition";
          }
          if (!directive.expression && (type === "Binding" || type === "Class")) {
            directive.expression = {
              start: directive.start + colon_index + 1,
              end: directive.end,
              type: "Identifier",
              name: directive.name
            };
          }
          return directive;
        }
        check_unique(name);
        return {
          start,
          end,
          type: "Attribute",
          name,
          value: value2
        };
      }
      function get_directive_type(name) {
        if (name === "use")
          return "Action";
        if (name === "animate")
          return "Animation";
        if (name === "bind")
          return "Binding";
        if (name === "class")
          return "Class";
        if (name === "on")
          return "EventHandler";
        if (name === "let")
          return "Let";
        if (name === "ref")
          return "Ref";
        if (name === "in" || name === "out" || name === "transition")
          return "Transition";
      }
      function read_attribute_value(parser2) {
        const quote_mark = parser2.eat("'") ? "'" : parser2.eat('"') ? '"' : null;
        if (quote_mark && parser2.eat(quote_mark)) {
          return [{
            start: parser2.index - 1,
            end: parser2.index - 1,
            type: "Text",
            raw: "",
            data: ""
          }];
        }
        const regex = quote_mark === "'" ? /'/ : quote_mark === '"' ? /"/ : /(\/>|[\s"'=<>`])/;
        let value2;
        try {
          value2 = read_sequence(parser2, () => !!parser2.match_regex(regex));
        } catch (error4) {
          if (error4.code === "parse-error") {
            if (parser2.template.slice(error4.pos - 1, error4.pos + 1) === "/>") {
              parser2.index = error4.pos;
              parser2.error(parser_errors.unclosed_attribute_value(quote_mark || "}"));
            }
          }
          throw error4;
        }
        if (value2.length === 0 && !quote_mark) {
          parser2.error(parser_errors.missing_attribute_value);
        }
        if (quote_mark)
          parser2.index += 1;
        return value2;
      }
      function read_sequence(parser2, done) {
        let current_chunk = {
          start: parser2.index,
          end: null,
          type: "Text",
          raw: "",
          data: null
        };
        function flush(end) {
          if (current_chunk.raw) {
            current_chunk.data = decode_character_references(current_chunk.raw);
            current_chunk.end = end;
            chunks.push(current_chunk);
          }
        }
        const chunks = [];
        while (parser2.index < parser2.template.length) {
          const index2 = parser2.index;
          if (done()) {
            flush(parser2.index);
            return chunks;
          } else if (parser2.eat("{")) {
            flush(parser2.index - 1);
            parser2.allow_whitespace();
            const expression2 = read_expression(parser2);
            parser2.allow_whitespace();
            parser2.eat("}", true);
            chunks.push({
              start: index2,
              end: parser2.index,
              type: "MustacheTag",
              expression: expression2
            });
            current_chunk = {
              start: parser2.index,
              end: null,
              type: "Text",
              raw: "",
              data: null
            };
          } else {
            current_chunk.raw += parser2.template[parser2.index++];
          }
        }
        parser2.error(parser_errors.unexpected_eof);
      }
      const SQUARE_BRACKET_OPEN = "[".charCodeAt(0);
      const SQUARE_BRACKET_CLOSE = "]".charCodeAt(0);
      const CURLY_BRACKET_OPEN = "{".charCodeAt(0);
      const CURLY_BRACKET_CLOSE = "}".charCodeAt(0);
      function is_bracket_open(code) {
        return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;
      }
      function is_bracket_close(code) {
        return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;
      }
      function is_bracket_pair(open, close) {
        return open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE || open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE;
      }
      function get_bracket_close(open) {
        if (open === SQUARE_BRACKET_OPEN) {
          return SQUARE_BRACKET_CLOSE;
        }
        if (open === CURLY_BRACKET_OPEN) {
          return CURLY_BRACKET_CLOSE;
        }
      }
      function read_context(parser2) {
        const start = parser2.index;
        let i2 = parser2.index;
        const code = full_char_code_at(parser2.template, i2);
        if (isIdentifierStart(code, true)) {
          return {
            type: "Identifier",
            name: parser2.read_identifier(),
            start,
            end: parser2.index
          };
        }
        if (!is_bracket_open(code)) {
          parser2.error(parser_errors.unexpected_token_destructure);
        }
        const bracket_stack = [code];
        i2 += code <= 65535 ? 1 : 2;
        while (i2 < parser2.template.length) {
          const code2 = full_char_code_at(parser2.template, i2);
          if (is_bracket_open(code2)) {
            bracket_stack.push(code2);
          } else if (is_bracket_close(code2)) {
            if (!is_bracket_pair(bracket_stack[bracket_stack.length - 1], code2)) {
              parser2.error(parser_errors.unexpected_token(String.fromCharCode(get_bracket_close(bracket_stack[bracket_stack.length - 1]))));
            }
            bracket_stack.pop();
            if (bracket_stack.length === 0) {
              i2 += code2 <= 65535 ? 1 : 2;
              break;
            }
          }
          i2 += code2 <= 65535 ? 1 : 2;
        }
        parser2.index = i2;
        const pattern_string = parser2.template.slice(start, i2);
        try {
          let space_with_newline = parser2.template.slice(0, start).replace(/[^\n]/g, " ");
          const first_space = space_with_newline.indexOf(" ");
          space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
          return parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start - 1).left;
        } catch (error4) {
          parser2.acorn_error(error4);
        }
      }
      function trim_start(str2) {
        let i2 = 0;
        while (whitespace.test(str2[i2]))
          i2 += 1;
        return str2.slice(i2);
      }
      function trim_end(str2) {
        let i2 = str2.length;
        while (whitespace.test(str2[i2 - 1]))
          i2 -= 1;
        return str2.slice(0, i2);
      }
      function to_string(node2) {
        switch (node2.type) {
          case "IfBlock":
            return "{#if} block";
          case "ThenBlock":
            return "{:then} block";
          case "ElseBlock":
            return "{:else} block";
          case "PendingBlock":
          case "AwaitBlock":
            return "{#await} block";
          case "CatchBlock":
            return "{:catch} block";
          case "EachBlock":
            return "{#each} block";
          case "RawMustacheTag":
            return "{@html} block";
          case "DebugTag":
            return "{@debug} block";
          case "Element":
          case "InlineComponent":
          case "Slot":
          case "Title":
            return `<${node2.name}> tag`;
          default:
            return node2.type;
        }
      }
      function trim_whitespace(block, trim_before, trim_after) {
        if (!block.children || block.children.length === 0)
          return;
        const first_child = block.children[0];
        const last_child = block.children[block.children.length - 1];
        if (first_child.type === "Text" && trim_before) {
          first_child.data = trim_start(first_child.data);
          if (!first_child.data)
            block.children.shift();
        }
        if (last_child.type === "Text" && trim_after) {
          last_child.data = trim_end(last_child.data);
          if (!last_child.data)
            block.children.pop();
        }
        if (block.else) {
          trim_whitespace(block.else, trim_before, trim_after);
        }
        if (first_child.elseif) {
          trim_whitespace(first_child, trim_before, trim_after);
        }
      }
      function mustache(parser2) {
        const start = parser2.index;
        parser2.index += 1;
        parser2.allow_whitespace();
        if (parser2.eat("/")) {
          let block = parser2.current();
          let expected;
          if (closing_tag_omitted(block.name)) {
            block.end = start;
            parser2.stack.pop();
            block = parser2.current();
          }
          if (block.type === "ElseBlock" || block.type === "PendingBlock" || block.type === "ThenBlock" || block.type === "CatchBlock") {
            block.end = start;
            parser2.stack.pop();
            block = parser2.current();
            expected = "await";
          }
          if (block.type === "IfBlock") {
            expected = "if";
          } else if (block.type === "EachBlock") {
            expected = "each";
          } else if (block.type === "AwaitBlock") {
            expected = "await";
          } else if (block.type === "KeyBlock") {
            expected = "key";
          } else {
            parser2.error(parser_errors.unexpected_block_close);
          }
          parser2.eat(expected, true);
          parser2.allow_whitespace();
          parser2.eat("}", true);
          while (block.elseif) {
            block.end = parser2.index;
            parser2.stack.pop();
            block = parser2.current();
            if (block.else) {
              block.else.end = start;
            }
          }
          const char_before = parser2.template[block.start - 1];
          const char_after = parser2.template[parser2.index];
          const trim_before = !char_before || whitespace.test(char_before);
          const trim_after = !char_after || whitespace.test(char_after);
          trim_whitespace(block, trim_before, trim_after);
          block.end = parser2.index;
          parser2.stack.pop();
        } else if (parser2.eat(":else")) {
          if (parser2.eat("if")) {
            parser2.error(parser_errors.invalid_elseif);
          }
          parser2.allow_whitespace();
          if (parser2.eat("if")) {
            const block = parser2.current();
            if (block.type !== "IfBlock") {
              parser2.error(parser2.stack.some((block2) => block2.type === "IfBlock") ? parser_errors.invalid_elseif_placement_unclosed_block(to_string(block)) : parser_errors.invalid_elseif_placement_outside_if);
            }
            parser2.require_whitespace();
            const expression2 = read_expression(parser2);
            parser2.allow_whitespace();
            parser2.eat("}", true);
            block.else = {
              start: parser2.index,
              end: null,
              type: "ElseBlock",
              children: [
                {
                  start: parser2.index,
                  end: null,
                  type: "IfBlock",
                  elseif: true,
                  expression: expression2,
                  children: []
                }
              ]
            };
            parser2.stack.push(block.else.children[0]);
          } else {
            const block = parser2.current();
            if (block.type !== "IfBlock" && block.type !== "EachBlock") {
              parser2.error(parser2.stack.some((block2) => block2.type === "IfBlock" || block2.type === "EachBlock") ? parser_errors.invalid_else_placement_unclosed_block(to_string(block)) : parser_errors.invalid_else_placement_outside_if);
            }
            parser2.allow_whitespace();
            parser2.eat("}", true);
            block.else = {
              start: parser2.index,
              end: null,
              type: "ElseBlock",
              children: []
            };
            parser2.stack.push(block.else);
          }
        } else if (parser2.match(":then") || parser2.match(":catch")) {
          const block = parser2.current();
          const is_then = parser2.eat(":then") || !parser2.eat(":catch");
          if (is_then) {
            if (block.type !== "PendingBlock") {
              parser2.error(parser2.stack.some((block2) => block2.type === "PendingBlock") ? parser_errors.invalid_then_placement_unclosed_block(to_string(block)) : parser_errors.invalid_then_placement_without_await);
            }
          } else {
            if (block.type !== "ThenBlock" && block.type !== "PendingBlock") {
              parser2.error(parser2.stack.some((block2) => block2.type === "ThenBlock" || block2.type === "PendingBlock") ? parser_errors.invalid_catch_placement_unclosed_block(to_string(block)) : parser_errors.invalid_catch_placement_without_await);
            }
          }
          block.end = start;
          parser2.stack.pop();
          const await_block = parser2.current();
          if (!parser2.eat("}")) {
            parser2.require_whitespace();
            await_block[is_then ? "value" : "error"] = read_context(parser2);
            parser2.allow_whitespace();
            parser2.eat("}", true);
          }
          const new_block = {
            start,
            end: null,
            type: is_then ? "ThenBlock" : "CatchBlock",
            children: [],
            skip: false
          };
          await_block[is_then ? "then" : "catch"] = new_block;
          parser2.stack.push(new_block);
        } else if (parser2.eat("#")) {
          let type;
          if (parser2.eat("if")) {
            type = "IfBlock";
          } else if (parser2.eat("each")) {
            type = "EachBlock";
          } else if (parser2.eat("await")) {
            type = "AwaitBlock";
          } else if (parser2.eat("key")) {
            type = "KeyBlock";
          } else {
            parser2.error(parser_errors.expected_block_type);
          }
          parser2.require_whitespace();
          const expression2 = read_expression(parser2);
          const block = type === "AwaitBlock" ? {
            start,
            end: null,
            type,
            expression: expression2,
            value: null,
            error: null,
            pending: {
              start: null,
              end: null,
              type: "PendingBlock",
              children: [],
              skip: true
            },
            then: {
              start: null,
              end: null,
              type: "ThenBlock",
              children: [],
              skip: true
            },
            catch: {
              start: null,
              end: null,
              type: "CatchBlock",
              children: [],
              skip: true
            }
          } : {
            start,
            end: null,
            type,
            expression: expression2,
            children: []
          };
          parser2.allow_whitespace();
          if (type === "EachBlock") {
            parser2.eat("as", true);
            parser2.require_whitespace();
            block.context = read_context(parser2);
            parser2.allow_whitespace();
            if (parser2.eat(",")) {
              parser2.allow_whitespace();
              block.index = parser2.read_identifier();
              if (!block.index)
                parser2.error(parser_errors.expected_name);
              parser2.allow_whitespace();
            }
            if (parser2.eat("(")) {
              parser2.allow_whitespace();
              block.key = read_expression(parser2);
              parser2.allow_whitespace();
              parser2.eat(")", true);
              parser2.allow_whitespace();
            }
          }
          const await_block_shorthand = type === "AwaitBlock" && parser2.eat("then");
          if (await_block_shorthand) {
            if (parser2.match_regex(/\s*}/)) {
              parser2.allow_whitespace();
            } else {
              parser2.require_whitespace();
              block.value = read_context(parser2);
              parser2.allow_whitespace();
            }
          }
          const await_block_catch_shorthand = !await_block_shorthand && type === "AwaitBlock" && parser2.eat("catch");
          if (await_block_catch_shorthand) {
            if (parser2.match_regex(/\s*}/)) {
              parser2.allow_whitespace();
            } else {
              parser2.require_whitespace();
              block.error = read_context(parser2);
              parser2.allow_whitespace();
            }
          }
          parser2.eat("}", true);
          parser2.current().children.push(block);
          parser2.stack.push(block);
          if (type === "AwaitBlock") {
            let child_block;
            if (await_block_shorthand) {
              block.then.skip = false;
              child_block = block.then;
            } else if (await_block_catch_shorthand) {
              block.catch.skip = false;
              child_block = block.catch;
            } else {
              block.pending.skip = false;
              child_block = block.pending;
            }
            child_block.start = parser2.index;
            parser2.stack.push(child_block);
          }
        } else if (parser2.eat("@html")) {
          parser2.require_whitespace();
          const expression2 = read_expression(parser2);
          parser2.allow_whitespace();
          parser2.eat("}", true);
          parser2.current().children.push({
            start,
            end: parser2.index,
            type: "RawMustacheTag",
            expression: expression2
          });
        } else if (parser2.eat("@debug")) {
          let identifiers;
          if (parser2.read(/\s*}/)) {
            identifiers = [];
          } else {
            const expression2 = read_expression(parser2);
            identifiers = expression2.type === "SequenceExpression" ? expression2.expressions : [expression2];
            identifiers.forEach((node2) => {
              if (node2.type !== "Identifier") {
                parser2.error(parser_errors.invalid_debug_args, node2.start);
              }
            });
            parser2.allow_whitespace();
            parser2.eat("}", true);
          }
          parser2.current().children.push({
            start,
            end: parser2.index,
            type: "DebugTag",
            identifiers
          });
        } else {
          const expression2 = read_expression(parser2);
          parser2.allow_whitespace();
          parser2.eat("}", true);
          parser2.current().children.push({
            start,
            end: parser2.index,
            type: "MustacheTag",
            expression: expression2
          });
        }
      }
      function text(parser2) {
        const start = parser2.index;
        let data2 = "";
        while (parser2.index < parser2.template.length && !parser2.match("<") && !parser2.match("{")) {
          data2 += parser2.template[parser2.index++];
        }
        const node2 = {
          start,
          end: parser2.index,
          type: "Text",
          raw: data2,
          data: decode_character_references(data2)
        };
        parser2.current().children.push(node2);
      }
      function fragment(parser2) {
        if (parser2.match("<")) {
          return tag;
        }
        if (parser2.match("{")) {
          return mustache;
        }
        return text;
      }
      function getLocator(source, options3) {
        if (options3 === void 0) {
          options3 = {};
        }
        var offsetLine = options3.offsetLine || 0;
        var offsetColumn = options3.offsetColumn || 0;
        var originalLines = source.split("\n");
        var start = 0;
        var lineRanges = originalLines.map(function(line, i3) {
          var end = start + line.length + 1;
          var range = { start, end, line: i3 };
          start = end;
          return range;
        });
        var i2 = 0;
        function rangeContains(range, index2) {
          return range.start <= index2 && index2 < range.end;
        }
        function getLocation(range, index2) {
          return { line: offsetLine + range.line, column: offsetColumn + index2 - range.start, character: index2 };
        }
        function locate2(search, startIndex) {
          if (typeof search === "string") {
            search = source.indexOf(search, startIndex || 0);
          }
          var range = lineRanges[i2];
          var d2 = search >= range.end ? 1 : -1;
          while (range) {
            if (rangeContains(range, search))
              return getLocation(range, search);
            i2 += d2;
            range = lineRanges[i2];
          }
        }
        return locate2;
      }
      function locate(source, search, options3) {
        if (typeof options3 === "number") {
          throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");
        }
        return getLocator(source, options3)(search, options3 && options3.startIndex);
      }
      function tabs_to_spaces(str2) {
        return str2.replace(/^\t+/, (match) => match.split("	").join("  "));
      }
      function get_code_frame(source, line, column) {
        const lines = source.split("\n");
        const frame_start = Math.max(0, line - 2);
        const frame_end = Math.min(line + 3, lines.length);
        const digits = String(frame_end + 1).length;
        return lines.slice(frame_start, frame_end).map((str2, i2) => {
          const isErrorLine = frame_start + i2 === line;
          const line_num = String(i2 + frame_start + 1).padStart(digits, " ");
          if (isErrorLine) {
            const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str2.slice(0, column)).length) + "^";
            return `${line_num}: ${tabs_to_spaces(str2)}
${indicator}`;
          }
          return `${line_num}: ${tabs_to_spaces(str2)}`;
        }).join("\n");
      }
      class CompileError extends Error {
        toString() {
          return `${this.message} (${this.start.line}:${this.start.column})
${this.frame}`;
        }
      }
      function error3(message, props) {
        const error4 = new CompileError(message);
        error4.name = props.name;
        const start = locate(props.source, props.start, { offsetLine: 1 });
        const end = locate(props.source, props.end || props.start, { offsetLine: 1 });
        error4.code = props.code;
        error4.start = start;
        error4.end = end;
        error4.pos = props.start;
        error4.filename = props.filename;
        error4.frame = get_code_frame(props.source, start.line - 1, start.column);
        throw error4;
      }
      class Parser$1 {
        constructor(template2, options3) {
          this.index = 0;
          this.stack = [];
          this.css = [];
          this.js = [];
          this.meta_tags = {};
          if (typeof template2 !== "string") {
            throw new TypeError("Template must be a string");
          }
          this.template = template2.replace(/\s+$/, "");
          this.filename = options3.filename;
          this.customElement = options3.customElement;
          this.html = {
            start: null,
            end: null,
            type: "Fragment",
            children: []
          };
          this.stack.push(this.html);
          let state = fragment;
          while (this.index < this.template.length) {
            state = state(this) || fragment;
          }
          if (this.stack.length > 1) {
            const current = this.current();
            const type = current.type === "Element" ? `<${current.name}>` : "Block";
            const slug = current.type === "Element" ? "element" : "block";
            this.error({
              code: `unclosed-${slug}`,
              message: `${type} was left open`
            }, current.start);
          }
          if (state !== fragment) {
            this.error({
              code: "unexpected-eof",
              message: "Unexpected end of input"
            });
          }
          if (this.html.children.length) {
            let start = this.html.children[0].start;
            while (whitespace.test(template2[start]))
              start += 1;
            let end = this.html.children[this.html.children.length - 1].end;
            while (whitespace.test(template2[end - 1]))
              end -= 1;
            this.html.start = start;
            this.html.end = end;
          } else {
            this.html.start = this.html.end = null;
          }
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        acorn_error(err) {
          this.error({
            code: "parse-error",
            message: err.message.replace(/ \(\d+:\d+\)$/, "")
          }, err.pos);
        }
        error({ code, message }, index2 = this.index) {
          error3(message, {
            name: "ParseError",
            code,
            source: this.template,
            start: index2,
            filename: this.filename
          });
        }
        eat(str2, required, error4) {
          if (this.match(str2)) {
            this.index += str2.length;
            return true;
          }
          if (required) {
            this.error(error4 || (this.index === this.template.length ? parser_errors.unexpected_eof_token(str2) : parser_errors.unexpected_token(str2)));
          }
          return false;
        }
        match(str2) {
          return this.template.slice(this.index, this.index + str2.length) === str2;
        }
        match_regex(pattern2) {
          const match = pattern2.exec(this.template.slice(this.index));
          if (!match || match.index !== 0)
            return null;
          return match[0];
        }
        allow_whitespace() {
          while (this.index < this.template.length && whitespace.test(this.template[this.index])) {
            this.index++;
          }
        }
        read(pattern2) {
          const result = this.match_regex(pattern2);
          if (result)
            this.index += result.length;
          return result;
        }
        read_identifier(allow_reserved = false) {
          const start = this.index;
          let i2 = this.index;
          const code = full_char_code_at(this.template, i2);
          if (!isIdentifierStart(code, true))
            return null;
          i2 += code <= 65535 ? 1 : 2;
          while (i2 < this.template.length) {
            const code2 = full_char_code_at(this.template, i2);
            if (!isIdentifierChar(code2, true))
              break;
            i2 += code2 <= 65535 ? 1 : 2;
          }
          const identifier = this.template.slice(this.index, this.index = i2);
          if (!allow_reserved && reserved2.has(identifier)) {
            this.error({
              code: "unexpected-reserved-word",
              message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`
            }, start);
          }
          return identifier;
        }
        read_until(pattern2, error_message) {
          if (this.index >= this.template.length) {
            this.error(error_message || {
              code: "unexpected-eof",
              message: "Unexpected end of input"
            });
          }
          const start = this.index;
          const match = pattern2.exec(this.template.slice(start));
          if (match) {
            this.index = start + match.index;
            return this.template.slice(start, this.index);
          }
          this.index = this.template.length;
          return this.template.slice(start);
        }
        require_whitespace() {
          if (!whitespace.test(this.template[this.index])) {
            this.error({
              code: "missing-whitespace",
              message: "Expected whitespace"
            });
          }
          this.allow_whitespace();
        }
      }
      function parse$3(template2, options3 = {}) {
        const parser2 = new Parser$1(template2, options3);
        if (parser2.css.length > 1) {
          parser2.error(parser_errors.duplicate_style, parser2.css[1].start);
        }
        const instance_scripts = parser2.js.filter((script) => script.context === "default");
        const module_scripts = parser2.js.filter((script) => script.context === "module");
        if (instance_scripts.length > 1) {
          parser2.error(parser_errors.invalid_script_instance, instance_scripts[1].start);
        }
        if (module_scripts.length > 1) {
          parser2.error(parser_errors.invalid_script_module, module_scripts[1].start);
        }
        return {
          html: parser2.html,
          css: parser2.css[0],
          instance: instance_scripts[0],
          module: module_scripts[0]
        };
      }
      function is_head(node2) {
        return node2 && node2.type === "MemberExpression" && node2.object.name === "@_document" && node2.property.name === "head";
      }
      class Block$1 {
        constructor(options3) {
          this.dependencies = new Set();
          this.binding_group_initialised = new Set();
          this.event_listeners = [];
          this.variables = new Map();
          this.has_update_method = false;
          this.parent = options3.parent;
          this.renderer = options3.renderer;
          this.name = options3.name;
          this.type = options3.type;
          this.comment = options3.comment;
          this.wrappers = [];
          this.key = options3.key;
          this.first = null;
          this.bindings = options3.bindings;
          this.chunks = {
            declarations: [],
            init: [],
            create: [],
            claim: [],
            hydrate: [],
            mount: [],
            measure: [],
            fix: [],
            animate: [],
            intro: [],
            update: [],
            outro: [],
            destroy: []
          };
          this.has_animation = false;
          this.has_intro_method = false;
          this.has_outro_method = false;
          this.outros = 0;
          this.get_unique_name = this.renderer.component.get_unique_name_maker();
          this.aliases = new Map();
          if (this.key)
            this.aliases.set("key", this.get_unique_name("key"));
        }
        assign_variable_names() {
          const seen = new Set();
          const dupes = new Set();
          let i2 = this.wrappers.length;
          while (i2--) {
            const wrapper = this.wrappers[i2];
            if (!wrapper.var)
              continue;
            if (seen.has(wrapper.var.name)) {
              dupes.add(wrapper.var.name);
            }
            seen.add(wrapper.var.name);
          }
          const counts = new Map();
          i2 = this.wrappers.length;
          while (i2--) {
            const wrapper = this.wrappers[i2];
            if (!wrapper.var)
              continue;
            let suffix = "";
            if (dupes.has(wrapper.var.name)) {
              const i3 = counts.get(wrapper.var.name) || 0;
              counts.set(wrapper.var.name, i3 + 1);
              suffix = i3;
            }
            wrapper.var.name = this.get_unique_name(wrapper.var.name + suffix).name;
          }
        }
        add_dependencies(dependencies) {
          dependencies.forEach((dependency) => {
            this.dependencies.add(dependency);
          });
          this.has_update_method = true;
          if (this.parent) {
            this.parent.add_dependencies(dependencies);
          }
        }
        add_element(id2, render_statement, claim_statement, parent_node, no_detach) {
          this.add_variable(id2);
          this.chunks.create.push(b`${id2} = ${render_statement};`);
          if (this.renderer.options.hydratable) {
            this.chunks.claim.push(b`${id2} = ${claim_statement || render_statement};`);
          }
          if (parent_node) {
            this.chunks.mount.push(b`@append(${parent_node}, ${id2});`);
            if (is_head(parent_node) && !no_detach)
              this.chunks.destroy.push(b`@detach(${id2});`);
          } else {
            this.chunks.mount.push(b`@insert(#target, ${id2}, #anchor);`);
            if (!no_detach)
              this.chunks.destroy.push(b`if (detaching) @detach(${id2});`);
          }
        }
        add_intro(local) {
          this.has_intros = this.has_intro_method = true;
          if (!local && this.parent)
            this.parent.add_intro();
        }
        add_outro(local) {
          this.has_outros = this.has_outro_method = true;
          this.outros += 1;
          if (!local && this.parent)
            this.parent.add_outro();
        }
        add_animation() {
          this.has_animation = true;
        }
        add_variable(id2, init2) {
          if (this.variables.has(id2.name)) {
            throw new Error(`Variable '${id2.name}' already initialised with a different value`);
          }
          this.variables.set(id2.name, { id: id2, init: init2 });
        }
        alias(name) {
          if (!this.aliases.has(name)) {
            this.aliases.set(name, this.get_unique_name(name));
          }
          return this.aliases.get(name);
        }
        child(options3) {
          return new Block$1(Object.assign({}, this, { key: null }, options3, { parent: this }));
        }
        get_contents(key) {
          const { dev } = this.renderer.options;
          if (this.has_outros) {
            this.add_variable({ type: "Identifier", name: "#current" });
            if (this.chunks.intro.length > 0) {
              this.chunks.intro.push(b`#current = true;`);
              this.chunks.mount.push(b`#current = true;`);
            }
            if (this.chunks.outro.length > 0) {
              this.chunks.outro.push(b`#current = false;`);
            }
          }
          if (this.autofocus) {
            if (this.autofocus.condition_expression) {
              this.chunks.mount.push(b`if (${this.autofocus.condition_expression}) ${this.autofocus.element_var}.focus();`);
            } else {
              this.chunks.mount.push(b`${this.autofocus.element_var}.focus();`);
            }
          }
          this.render_listeners();
          const properties2 = {};
          const noop3 = x`@noop`;
          properties2.key = key;
          if (this.first) {
            properties2.first = x`null`;
            this.chunks.hydrate.push(b`this.first = ${this.first};`);
          }
          if (this.chunks.create.length === 0 && this.chunks.hydrate.length === 0) {
            properties2.create = noop3;
          } else {
            const hydrate = this.chunks.hydrate.length > 0 && (this.renderer.options.hydratable ? b`this.h();` : this.chunks.hydrate);
            properties2.create = x`function #create() {
				${this.chunks.create}
				${hydrate}
			}`;
          }
          if (this.renderer.options.hydratable || this.chunks.claim.length > 0) {
            if (this.chunks.claim.length === 0 && this.chunks.hydrate.length === 0) {
              properties2.claim = noop3;
            } else {
              properties2.claim = x`function #claim(#nodes) {
					${this.chunks.claim}
					${this.renderer.options.hydratable && this.chunks.hydrate.length > 0 && b`this.h();`}
				}`;
            }
          }
          if (this.renderer.options.hydratable && this.chunks.hydrate.length > 0) {
            properties2.hydrate = x`function #hydrate() {
				${this.chunks.hydrate}
			}`;
          }
          if (this.chunks.mount.length === 0) {
            properties2.mount = noop3;
          } else if (this.event_listeners.length === 0) {
            properties2.mount = x`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
          } else {
            properties2.mount = x`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
          }
          if (this.has_update_method || this.maintain_context) {
            if (this.chunks.update.length === 0 && !this.maintain_context) {
              properties2.update = noop3;
            } else {
              const ctx = this.maintain_context ? x`#new_ctx` : x`#ctx`;
              let dirty = { type: "Identifier", name: "#dirty" };
              if (!this.renderer.context_overflow && !this.parent) {
                dirty = { type: "ArrayPattern", elements: [dirty] };
              }
              properties2.update = x`function #update(${ctx}, ${dirty}) {
					${this.maintain_context && b`#ctx = ${ctx};`}
					${this.chunks.update}
				}`;
            }
          }
          if (this.has_animation) {
            properties2.measure = x`function #measure() {
				${this.chunks.measure}
			}`;
            properties2.fix = x`function #fix() {
				${this.chunks.fix}
			}`;
            properties2.animate = x`function #animate() {
				${this.chunks.animate}
			}`;
          }
          if (this.has_intro_method || this.has_outro_method) {
            if (this.chunks.intro.length === 0) {
              properties2.intro = noop3;
            } else {
              properties2.intro = x`function #intro(#local) {
					${this.has_outros && b`if (#current) return;`}
					${this.chunks.intro}
				}`;
            }
            if (this.chunks.outro.length === 0) {
              properties2.outro = noop3;
            } else {
              properties2.outro = x`function #outro(#local) {
					${this.chunks.outro}
				}`;
            }
          }
          if (this.chunks.destroy.length === 0) {
            properties2.destroy = noop3;
          } else {
            properties2.destroy = x`function #destroy(detaching) {
				${this.chunks.destroy}
			}`;
          }
          if (!this.renderer.component.compile_options.dev) {
            for (const name in properties2) {
              const property = properties2[name];
              if (property)
                property.id = null;
            }
          }
          const return_value = x`{
			key: ${properties2.key},
			first: ${properties2.first},
			c: ${properties2.create},
			l: ${properties2.claim},
			h: ${properties2.hydrate},
			m: ${properties2.mount},
			p: ${properties2.update},
			r: ${properties2.measure},
			f: ${properties2.fix},
			a: ${properties2.animate},
			i: ${properties2.intro},
			o: ${properties2.outro},
			d: ${properties2.destroy}
		}`;
          const block = dev && this.get_unique_name("block");
          const body = b`
			${this.chunks.declarations}

			${Array.from(this.variables.values()).map(({ id: id2, init: init2 }) => {
            return init2 ? b`let ${id2} = ${init2}` : b`let ${id2}`;
          })}

			${this.chunks.init}

			${dev ? b`
					const ${block} = ${return_value};
					@dispatch_dev("SvelteRegisterBlock", {
						block: ${block},
						id: ${this.name || "create_fragment"}.name,
						type: "${this.type}",
						source: "${this.comment ? this.comment.replace(/"/g, '\\"') : ""}",
						ctx: #ctx
					});
					return ${block};` : b`
					return ${return_value};`}
		`;
          return body;
        }
        has_content() {
          return !!this.first || this.event_listeners.length > 0 || this.chunks.intro.length > 0 || this.chunks.outro.length > 0 || this.chunks.create.length > 0 || this.chunks.hydrate.length > 0 || this.chunks.claim.length > 0 || this.chunks.mount.length > 0 || this.chunks.update.length > 0 || this.chunks.destroy.length > 0 || this.has_animation;
        }
        render() {
          const key = this.key && this.get_unique_name("key");
          const args = [x`#ctx`];
          if (key)
            args.unshift(key);
          const fn = b`function ${this.name}(${args}) {
			${this.get_contents(key)}
		}`;
          return this.comment ? b`
				// ${this.comment}
				${fn}` : fn;
        }
        render_listeners(chunk = "") {
          if (this.event_listeners.length > 0) {
            this.add_variable({ type: "Identifier", name: "#mounted" });
            this.chunks.destroy.push(b`#mounted = false`);
            const dispose = {
              type: "Identifier",
              name: `#dispose${chunk}`
            };
            this.add_variable(dispose);
            if (this.event_listeners.length === 1) {
              this.chunks.mount.push(b`
						if (!#mounted) {
							${dispose} = ${this.event_listeners[0]};
							#mounted = true;
						}
					`);
              this.chunks.destroy.push(b`${dispose}();`);
            } else {
              this.chunks.mount.push(b`
					if (!#mounted) {
						${dispose} = [
							${this.event_listeners}
						];
						#mounted = true;
					}
				`);
              this.chunks.destroy.push(b`@run_all(${dispose});`);
            }
          }
        }
      }
      class Wrapper {
        constructor(renderer, block, parent, node2) {
          this.node = node2;
          Object.defineProperties(this, {
            renderer: {
              value: renderer
            },
            parent: {
              value: parent
            }
          });
          this.can_use_innerhtml = !renderer.options.hydratable;
          this.is_static_content = !renderer.options.hydratable;
          block.wrappers.push(this);
        }
        cannot_use_innerhtml() {
          this.can_use_innerhtml = false;
          if (this.parent)
            this.parent.cannot_use_innerhtml();
        }
        not_static_content() {
          this.is_static_content = false;
          if (this.parent)
            this.parent.not_static_content();
        }
        get_or_create_anchor(block, parent_node, parent_nodes) {
          const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
          const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || { type: "Identifier", name: "null" };
          if (needs_anchor) {
            block.add_element(anchor, x`@empty()`, parent_nodes && x`@empty()`, parent_node);
          }
          return anchor;
        }
        get_update_mount_node(anchor) {
          return this.parent && this.parent.is_dom_node() ? this.parent.var : x`${anchor}.parentNode`;
        }
        is_dom_node() {
          return this.node.type === "Element" || this.node.type === "Text" || this.node.type === "MustacheTag";
        }
        render(_block, _parent_node, _parent_nodes) {
          throw Error("Wrapper class is not renderable");
        }
      }
      function create_debugging_comment(node2, component) {
        const { locate: locate2, source } = component;
        let c2 = node2.start;
        if (node2.type === "ElseBlock") {
          while (source[c2 - 1] !== "{")
            c2 -= 1;
          while (source[c2 - 1] === "{")
            c2 -= 1;
        }
        let d2;
        if (node2.type === "InlineComponent" || node2.type === "Element" || node2.type === "SlotTemplate") {
          if (node2.children.length) {
            d2 = node2.children[0].start;
            while (source[d2 - 1] !== ">")
              d2 -= 1;
          } else {
            d2 = node2.start;
            while (source[d2] !== ">")
              d2 += 1;
            d2 += 1;
          }
        } else if (node2.type === "Text" || node2.type === "Comment") {
          d2 = node2.end;
        } else {
          d2 = node2.expression ? node2.expression.node.end : c2;
          while (source[d2] !== "}" && d2 <= source.length)
            d2 += 1;
          while (source[d2] === "}")
            d2 += 1;
        }
        const start = locate2(c2);
        const loc = `(${start.line}:${start.column})`;
        return `${loc} ${source.slice(c2, d2)}`.replace(/\s/g, " ");
      }
      class AwaitBlockBranch extends Wrapper {
        constructor(status, renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          this.var = null;
          this.status = status;
          this.block = block.child({
            comment: create_debugging_comment(node2, this.renderer.component),
            name: this.renderer.component.get_unique_name(`create_${status}_block`),
            type: status
          });
          this.add_context(parent.node[status + "_node"], parent.node[status + "_contexts"]);
          this.fragment = new FragmentWrapper(renderer, this.block, this.node.children, parent, strip_whitespace, next_sibling);
          this.is_dynamic = this.block.dependencies.size > 0;
        }
        add_context(node2, contexts) {
          if (!node2)
            return;
          if (node2.type === "Identifier") {
            this.value = node2.name;
            this.renderer.add_to_context(this.value, true);
          } else {
            contexts.forEach((context) => {
              this.renderer.add_to_context(context.key.name, true);
            });
            this.value = this.block.parent.get_unique_name("value").name;
            this.value_contexts = contexts;
            this.renderer.add_to_context(this.value, true);
            this.is_destructured = true;
          }
          this.value_index = this.renderer.context_lookup.get(this.value).index;
        }
        render(block, parent_node, parent_nodes) {
          this.fragment.render(block, parent_node, parent_nodes);
          if (this.is_destructured) {
            this.render_destructure();
          }
        }
        render_destructure() {
          const props = this.value_contexts.map((prop) => b`#ctx[${this.block.renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x`#ctx[${this.value_index}]`), (name) => this.renderer.reference(name))};`);
          const get_context2 = this.block.renderer.component.get_unique_name(`get_${this.status}_context`);
          this.block.renderer.blocks.push(b`
			function ${get_context2}(#ctx) {
				${props}
			}
		`);
          this.block.chunks.declarations.push(b`${get_context2}(#ctx)`);
          if (this.block.has_update_method) {
            this.block.chunks.update.unshift(b`${get_context2}(#ctx)`);
          }
        }
      }
      class AwaitBlockWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          this.var = { type: "Identifier", name: "await_block" };
          this.cannot_use_innerhtml();
          this.not_static_content();
          block.add_dependencies(this.node.expression.dependencies);
          let is_dynamic2 = false;
          let has_intros = false;
          let has_outros = false;
          ["pending", "then", "catch"].forEach((status) => {
            const child = this.node[status];
            const branch = new AwaitBlockBranch(status, renderer, block, this, child, strip_whitespace, next_sibling);
            renderer.blocks.push(branch.block);
            if (branch.is_dynamic) {
              is_dynamic2 = true;
              block.add_dependencies(branch.block.dependencies);
            }
            if (branch.block.has_intros)
              has_intros = true;
            if (branch.block.has_outros)
              has_outros = true;
            this[status] = branch;
          });
          ["pending", "then", "catch"].forEach((status) => {
            this[status].block.has_update_method = is_dynamic2;
            this[status].block.has_intro_method = has_intros;
            this[status].block.has_outro_method = has_outros;
          });
          if (has_outros) {
            block.add_outro();
          }
        }
        render(block, parent_node, parent_nodes) {
          const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
          const update_mount_node = this.get_update_mount_node(anchor);
          const snippet = this.node.expression.manipulate(block);
          const info = block.get_unique_name("info");
          const promise = block.get_unique_name("promise");
          block.add_variable(promise);
          block.maintain_context = true;
          const info_props = x`{
			ctx: #ctx,
			current: null,
			token: null,
			hasCatch: ${this.catch.node.start !== null ? "true" : "false"},
			pending: ${this.pending.block.name},
			then: ${this.then.block.name},
			catch: ${this.catch.block.name},
			value: ${this.then.value_index},
			error: ${this.catch.value_index},
			blocks: ${this.pending.block.has_outro_method && x`[,,,]`}
		}`;
          block.chunks.init.push(b`
			let ${info} = ${info_props};
		`);
          block.chunks.init.push(b`
			@handle_promise(${promise} = ${snippet}, ${info});
		`);
          block.chunks.create.push(b`
			${info}.block.c();
		`);
          if (parent_nodes && this.renderer.options.hydratable) {
            block.chunks.claim.push(b`
				${info}.block.l(${parent_nodes});
			`);
          }
          const initial_mount_node = parent_node || "#target";
          const anchor_node = parent_node ? "null" : "#anchor";
          const has_transitions = this.pending.block.has_intro_method || this.pending.block.has_outro_method;
          block.chunks.mount.push(b`
			${info}.block.m(${initial_mount_node}, ${info}.anchor = ${anchor_node});
			${info}.mount = () => ${update_mount_node};
			${info}.anchor = ${anchor};
		`);
          if (has_transitions) {
            block.chunks.intro.push(b`@transition_in(${info}.block);`);
          }
          const dependencies = this.node.expression.dynamic_dependencies();
          const update_await_block_branch = b`@update_await_block_branch(${info}, #ctx, #dirty)`;
          if (dependencies.length > 0) {
            const condition = x`
				${block.renderer.dirty(dependencies)} &&
				${promise} !== (${promise} = ${snippet}) &&
				@handle_promise(${promise}, ${info})`;
            block.chunks.update.push(b`${info}.ctx = #ctx;`);
            if (this.pending.block.has_update_method) {
              block.chunks.update.push(b`
					if (${condition}) {

					} else {
						${update_await_block_branch}
					}
				`);
            } else {
              block.chunks.update.push(b`
					${condition}
				`);
            }
          } else {
            if (this.pending.block.has_update_method) {
              block.chunks.update.push(b`
					${update_await_block_branch}
				`);
            }
          }
          if (this.pending.block.has_outro_method) {
            block.chunks.outro.push(b`
				for (let #i = 0; #i < 3; #i += 1) {
					const block = ${info}.blocks[#i];
					@transition_out(block);
				}
			`);
          }
          block.chunks.destroy.push(b`
			${info}.block.d(${parent_node ? null : "detaching"});
			${info}.token = null;
			${info} = null;
		`);
          [this.pending, this.then, this.catch].forEach((branch) => {
            branch.render(branch.block, null, x`#nodes`);
          });
        }
      }
      const TRUE = x`true`;
      const FALSE = x`false`;
      class EventHandlerWrapper {
        constructor(node2, parent) {
          this.node = node2;
          this.parent = parent;
          if (!node2.expression) {
            this.parent.renderer.add_to_context(node2.handler_name.name);
            this.parent.renderer.component.partly_hoisted.push(b`
				function ${node2.handler_name.name}(event) {
					@bubble.call(this, $$self, event);
				}
			`);
          }
        }
        get_snippet(block) {
          const snippet = this.node.expression ? this.node.expression.manipulate(block) : block.renderer.reference(this.node.handler_name);
          if (this.node.reassigned) {
            block.maintain_context = true;
            return x`function () { if (@is_function(${snippet})) ${snippet}.apply(this, arguments); }`;
          }
          return snippet;
        }
        render(block, target) {
          let snippet = this.get_snippet(block);
          if (this.node.modifiers.has("preventDefault"))
            snippet = x`@prevent_default(${snippet})`;
          if (this.node.modifiers.has("stopPropagation"))
            snippet = x`@stop_propagation(${snippet})`;
          if (this.node.modifiers.has("self"))
            snippet = x`@self(${snippet})`;
          if (this.node.modifiers.has("trusted"))
            snippet = x`@trusted(${snippet})`;
          const args = [];
          const opts = ["nonpassive", "passive", "once", "capture"].filter((mod) => this.node.modifiers.has(mod));
          if (opts.length) {
            if (opts.length === 1 && opts[0] === "capture") {
              args.push(TRUE);
            } else {
              args.push(x`{ ${opts.map((opt) => opt === "nonpassive" ? p`passive: false` : p`${opt}: true`)} }`);
            }
          } else if (block.renderer.options.dev) {
            args.push(FALSE);
          }
          if (block.renderer.options.dev) {
            args.push(this.node.modifiers.has("preventDefault") ? TRUE : FALSE);
            args.push(this.node.modifiers.has("stopPropagation") ? TRUE : FALSE);
          }
          block.event_listeners.push(x`@listen(${target}, "${this.node.name}", ${snippet}, ${args})`);
        }
      }
      function add_event_handlers(block, target, handlers2) {
        handlers2.forEach((handler2) => add_event_handler(block, target, handler2));
      }
      function add_event_handler(block, target, handler2) {
        handler2.render(block, target);
      }
      const reserved_keywords = new Set(["$$props", "$$restProps", "$$slots"]);
      function is_reserved_keyword(name) {
        return reserved_keywords.has(name);
      }
      function is_contextual(component, scope2, name) {
        if (is_reserved_keyword(name))
          return true;
        if (!scope2.is_top_level(name))
          return true;
        const variable = component.var_lookup.get(name);
        if (!variable || variable.hoistable)
          return false;
        return true;
      }
      function add_actions(block, target, actions) {
        actions.forEach((action) => add_action(block, target, action));
      }
      function add_action(block, target, action) {
        const { expression: expression2, template_scope } = action;
        let snippet;
        let dependencies;
        if (expression2) {
          snippet = expression2.manipulate(block);
          dependencies = expression2.dynamic_dependencies();
        }
        const id2 = block.get_unique_name(`${action.name.replace(/[^a-zA-Z0-9_$]/g, "_")}_action`);
        block.add_variable(id2);
        const [obj, ...properties2] = action.name.split(".");
        const fn = is_contextual(action.component, template_scope, obj) ? block.renderer.reference(obj) : obj;
        if (properties2.length) {
          const member_expression = properties2.reduce((lhs, rhs) => x`${lhs}.${rhs}`, fn);
          block.event_listeners.push(x`@action_destroyer(${id2} = ${member_expression}(${target}, ${snippet}))`);
        } else {
          block.event_listeners.push(x`@action_destroyer(${id2} = ${fn}.call(null, ${target}, ${snippet}))`);
        }
        if (dependencies && dependencies.length > 0) {
          let condition = x`${id2} && @is_function(${id2}.update)`;
          if (dependencies.length > 0) {
            condition = x`${condition} && ${block.renderer.dirty(dependencies)}`;
          }
          block.chunks.update.push(b`if (${condition}) ${id2}.update.call(null, ${snippet});`);
        }
      }
      class BodyWrapper extends Wrapper {
        constructor(renderer, block, parent, node2) {
          super(renderer, block, parent, node2);
          this.handlers = this.node.handlers.map((handler2) => new EventHandlerWrapper(handler2, this));
        }
        render(block, _parent_node, _parent_nodes) {
          add_event_handlers(block, x`@_document.body`, this.handlers);
          add_actions(block, x`@_document.body`, this.node.actions);
        }
      }
      function add_to_set(a, b2) {
        b2.forEach((item) => {
          a.add(item);
        });
      }
      class DebugTagWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, _strip_whitespace, _next_sibling) {
          super(renderer, block, parent, node2);
        }
        render(block, _parent_node, _parent_nodes) {
          const { renderer } = this;
          const { component } = renderer;
          if (!renderer.options.dev)
            return;
          const { var_lookup } = component;
          const start = component.locate(this.node.start + 1);
          const end = { line: start.line, column: start.column + 6 };
          const loc = { start, end };
          const debug = {
            type: "DebuggerStatement",
            loc
          };
          if (this.node.expressions.length === 0) {
            block.chunks.create.push(debug);
            block.chunks.update.push(debug);
          } else {
            const log = {
              type: "Identifier",
              name: "log",
              loc
            };
            const dependencies = new Set();
            this.node.expressions.forEach((expression2) => {
              add_to_set(dependencies, expression2.dependencies);
            });
            const contextual_identifiers = this.node.expressions.filter((e) => {
              const variable = var_lookup.get(e.node.name);
              return !(variable && variable.hoistable);
            }).map((e) => e.node.name);
            const logged_identifiers = this.node.expressions.map((e) => p`${e.node.name}`);
            const debug_statements = b`
				${contextual_identifiers.map((name) => b`const ${name} = ${renderer.reference(name)};`)}
				@_console.${log}({ ${logged_identifiers} });
				debugger;`;
            if (dependencies.size) {
              const condition = renderer.dirty(Array.from(dependencies));
              block.chunks.update.push(b`
					if (${condition}) {
						${debug_statements}
					}
				`);
            }
            block.chunks.create.push(b`{
				${debug_statements}
			}`);
          }
        }
      }
      function get_object(node2) {
        while (node2.type === "MemberExpression")
          node2 = node2.object;
        return node2;
      }
      class ElseBlockWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          this.var = null;
          this.block = block.child({
            comment: create_debugging_comment(node2, this.renderer.component),
            name: this.renderer.component.get_unique_name("create_else_block"),
            type: "else"
          });
          this.fragment = new FragmentWrapper(renderer, this.block, this.node.children, parent, strip_whitespace, next_sibling);
          this.is_dynamic = this.block.dependencies.size > 0;
        }
      }
      class EachBlockWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          this.updates = [];
          this.var = { type: "Identifier", name: "each" };
          this.cannot_use_innerhtml();
          this.not_static_content();
          const { dependencies } = node2.expression;
          block.add_dependencies(dependencies);
          this.node.contexts.forEach((context) => {
            renderer.add_to_context(context.key.name, true);
          });
          this.block = block.child({
            comment: create_debugging_comment(this.node, this.renderer.component),
            name: renderer.component.get_unique_name("create_each_block"),
            type: "each",
            key: node2.key,
            bindings: new Map(block.bindings)
          });
          this.block.has_animation = this.node.has_animation;
          this.index_name = this.node.index ? { type: "Identifier", name: this.node.index } : renderer.component.get_unique_name(`${this.node.context}_index`);
          const fixed_length = node2.expression.node.type === "ArrayExpression" && node2.expression.node.elements.every((element) => element.type !== "SpreadElement") ? node2.expression.node.elements.length : null;
          let c2 = this.node.start + 2;
          while (renderer.component.source[c2] !== "e")
            c2 += 1;
          const start = renderer.component.locate(c2);
          const end = { line: start.line, column: start.column + 4 };
          const length = {
            type: "Identifier",
            name: "length",
            loc: { start, end }
          };
          const each_block_value = renderer.component.get_unique_name(`${this.var.name}_value`);
          const iterations = block.get_unique_name(`${this.var.name}_blocks`);
          renderer.add_to_context(each_block_value.name, true);
          renderer.add_to_context(this.index_name.name, true);
          this.vars = {
            create_each_block: this.block.name,
            each_block_value,
            get_each_context: renderer.component.get_unique_name(`get_${this.var.name}_context`),
            iterations,
            fixed_length,
            data_length: fixed_length === null ? x`${each_block_value}.${length}` : fixed_length,
            view_length: fixed_length === null ? x`${iterations}.length` : fixed_length
          };
          const object = get_object(node2.expression.node);
          const store = object.type === "Identifier" && object.name[0] === "$" ? object.name.slice(1) : null;
          node2.contexts.forEach((prop) => {
            this.block.bindings.set(prop.key.name, {
              object: this.vars.each_block_value,
              property: this.index_name,
              modifier: prop.modifier,
              snippet: prop.modifier(x`${this.vars.each_block_value}[${this.index_name}]`),
              store
            });
          });
          if (this.node.index) {
            this.block.get_unique_name(this.node.index);
          }
          renderer.blocks.push(this.block);
          this.fragment = new FragmentWrapper(renderer, this.block, node2.children, this, strip_whitespace, next_sibling);
          if (this.node.else) {
            this.else = new ElseBlockWrapper(renderer, block, this, this.node.else, strip_whitespace, next_sibling);
            renderer.blocks.push(this.else.block);
            if (this.else.is_dynamic) {
              this.block.add_dependencies(this.else.block.dependencies);
            }
          }
          block.add_dependencies(this.block.dependencies);
          if (this.block.has_outros || this.else && this.else.block.has_outros) {
            block.add_outro();
          }
        }
        render(block, parent_node, parent_nodes) {
          if (this.fragment.nodes.length === 0)
            return;
          const { renderer } = this;
          const { component } = renderer;
          const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
          const snippet = this.node.expression.manipulate(block);
          block.chunks.init.push(b`let ${this.vars.each_block_value} = ${snippet};`);
          if (this.renderer.options.dev) {
            block.chunks.init.push(b`@validate_each_argument(${this.vars.each_block_value});`);
          }
          const initial_anchor_node = { type: "Identifier", name: parent_node ? "null" : "#anchor" };
          const initial_mount_node = parent_node || { type: "Identifier", name: "#target" };
          const update_anchor_node = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || { type: "Identifier", name: "null" };
          const update_mount_node = this.get_update_mount_node(update_anchor_node);
          const args = {
            block,
            parent_node,
            parent_nodes,
            snippet,
            initial_anchor_node,
            initial_mount_node,
            update_anchor_node,
            update_mount_node
          };
          const all_dependencies = new Set(this.block.dependencies);
          this.node.expression.dynamic_dependencies().forEach((dependency) => {
            all_dependencies.add(dependency);
          });
          if (this.node.key) {
            this.node.key.dynamic_dependencies().forEach((dependency) => {
              all_dependencies.add(dependency);
            });
          }
          this.dependencies = all_dependencies;
          if (this.node.key) {
            this.render_keyed(args);
          } else {
            this.render_unkeyed(args);
          }
          if (this.block.has_intro_method || this.block.has_outro_method) {
            block.chunks.intro.push(b`
				for (let #i = 0; #i < ${this.vars.data_length}; #i += 1) {
					@transition_in(${this.vars.iterations}[#i]);
				}
			`);
          }
          if (needs_anchor) {
            block.add_element(update_anchor_node, x`@empty()`, parent_nodes && x`@empty()`, parent_node);
          }
          if (this.else) {
            const each_block_else = component.get_unique_name(`${this.var.name}_else`);
            block.chunks.init.push(b`let ${each_block_else} = null;`);
            block.chunks.init.push(b`
				if (!${this.vars.data_length}) {
					${each_block_else} = ${this.else.block.name}(#ctx);
				}
			`);
            block.chunks.create.push(b`
				if (${each_block_else}) {
					${each_block_else}.c();
				}
			`);
            if (this.renderer.options.hydratable) {
              block.chunks.claim.push(b`
					if (${each_block_else}) {
						${each_block_else}.l(${parent_nodes});
					}
				`);
            }
            block.chunks.mount.push(b`
				if (${each_block_else}) {
					${each_block_else}.m(${initial_mount_node}, ${initial_anchor_node});
				}
			`);
            const has_transitions = !!(this.else.block.has_intro_method || this.else.block.has_outro_method);
            const destroy_block_else = this.else.block.has_outro_method ? b`
					@group_outros();
					@transition_out(${each_block_else}, 1, 1, () => {
						${each_block_else} = null;
					});
					@check_outros();` : b`
					${each_block_else}.d(1);
					${each_block_else} = null;`;
            if (this.else.block.has_update_method) {
              this.updates.push(b`
					if (!${this.vars.data_length} && ${each_block_else}) {
						${each_block_else}.p(#ctx, #dirty);
					} else if (!${this.vars.data_length}) {
						${each_block_else} = ${this.else.block.name}(#ctx);
						${each_block_else}.c();
						${has_transitions && b`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					} else if (${each_block_else}) {
						${destroy_block_else};
					}
				`);
            } else {
              this.updates.push(b`
					if (${this.vars.data_length}) {
						if (${each_block_else}) {
							${destroy_block_else};
						}
					} else if (!${each_block_else}) {
						${each_block_else} = ${this.else.block.name}(#ctx);
						${each_block_else}.c();
						${has_transitions && b`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					}
				`);
            }
            block.chunks.destroy.push(b`
				if (${each_block_else}) ${each_block_else}.d(${parent_node ? "" : "detaching"});
			`);
          }
          if (this.updates.length) {
            block.chunks.update.push(b`
				if (${block.renderer.dirty(Array.from(all_dependencies))}) {
					${this.updates}
				}
			`);
          }
          this.fragment.render(this.block, null, x`#nodes`);
          if (this.else) {
            this.else.fragment.render(this.else.block, null, x`#nodes`);
          }
          this.context_props = this.node.contexts.map((prop) => b`child_ctx[${renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x`list[i]`), (name) => renderer.context_lookup.has(name) ? x`child_ctx[${renderer.context_lookup.get(name).index}]` : { type: "Identifier", name })};`);
          if (this.node.has_binding)
            this.context_props.push(b`child_ctx[${renderer.context_lookup.get(this.vars.each_block_value.name).index}] = list;`);
          if (this.node.has_binding || this.node.has_index_binding || this.node.index)
            this.context_props.push(b`child_ctx[${renderer.context_lookup.get(this.index_name.name).index}] = i;`);
          renderer.blocks.push(b`
			function ${this.vars.get_each_context}(#ctx, list, i) {
				const child_ctx = #ctx.slice();
				${this.context_props}
				return child_ctx;
			}
		`);
        }
        render_keyed({ block, parent_node, parent_nodes, snippet, initial_anchor_node, initial_mount_node, update_anchor_node, update_mount_node }) {
          const { create_each_block, iterations, data_length, view_length } = this.vars;
          const get_key = block.get_unique_name("get_key");
          const lookup = block.get_unique_name(`${this.var.name}_lookup`);
          block.add_variable(iterations, x`[]`);
          block.add_variable(lookup, x`new @_Map()`);
          if (this.fragment.nodes[0].is_dom_node()) {
            this.block.first = this.fragment.nodes[0].var;
          } else {
            this.block.first = this.block.get_unique_name("first");
            this.block.add_element(this.block.first, x`@empty()`, parent_nodes && x`@empty()`, null);
          }
          block.chunks.init.push(b`
			const ${get_key} = #ctx => ${this.node.key.manipulate(block)};

			${this.renderer.options.dev && b`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
			for (let #i = 0; #i < ${data_length}; #i += 1) {
				let child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);
				let key = ${get_key}(child_ctx);
				${lookup}.set(key, ${iterations}[#i] = ${create_each_block}(key, child_ctx));
			}
		`);
          block.chunks.create.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
          if (parent_nodes && this.renderer.options.hydratable) {
            block.chunks.claim.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
          }
          block.chunks.mount.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
			}
		`);
          const dynamic = this.block.has_update_method;
          const destroy = this.node.has_animation ? this.block.has_outros ? "@fix_and_outro_and_destroy_block" : "@fix_and_destroy_block" : this.block.has_outros ? "@outro_and_destroy_block" : "@destroy_block";
          if (this.dependencies.size) {
            this.block.maintain_context = true;
            this.updates.push(b`
				${this.vars.each_block_value} = ${snippet};
				${this.renderer.options.dev && b`@validate_each_argument(${this.vars.each_block_value});`}

				${this.block.has_outros && b`@group_outros();`}
				${this.node.has_animation && b`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].r();`}
				${this.renderer.options.dev && b`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
				${iterations} = @update_keyed_each(${iterations}, #dirty, ${get_key}, ${dynamic ? 1 : 0}, #ctx, ${this.vars.each_block_value}, ${lookup}, ${update_mount_node}, ${destroy}, ${create_each_block}, ${update_anchor_node}, ${this.vars.get_each_context});
				${this.node.has_animation && b`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].a();`}
				${this.block.has_outros && b`@check_outros();`}
			`);
          }
          if (this.block.has_outros) {
            block.chunks.outro.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
          }
          block.chunks.destroy.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].d(${parent_node ? null : "detaching"});
			}
		`);
        }
        render_unkeyed({ block, parent_nodes, snippet, initial_anchor_node, initial_mount_node, update_anchor_node, update_mount_node }) {
          const { create_each_block, iterations, fixed_length, data_length, view_length } = this.vars;
          block.chunks.init.push(b`
			let ${iterations} = [];

			for (let #i = 0; #i < ${data_length}; #i += 1) {
				${iterations}[#i] = ${create_each_block}(${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i));
			}
		`);
          block.chunks.create.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
          if (parent_nodes && this.renderer.options.hydratable) {
            block.chunks.claim.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
          }
          block.chunks.mount.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
			}
		`);
          if (this.dependencies.size) {
            const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
            const for_loop_body = this.block.has_update_method ? b`
					if (${iterations}[#i]) {
						${iterations}[#i].p(child_ctx, #dirty);
						${has_transitions && b`@transition_in(${this.vars.iterations}[#i], 1);`}
					} else {
						${iterations}[#i] = ${create_each_block}(child_ctx);
						${iterations}[#i].c();
						${has_transitions && b`@transition_in(${this.vars.iterations}[#i], 1);`}
						${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
					}
				` : has_transitions ? b`
						if (${iterations}[#i]) {
							@transition_in(${this.vars.iterations}[#i], 1);
						} else {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							@transition_in(${this.vars.iterations}[#i], 1);
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					` : b`
						if (!${iterations}[#i]) {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					`;
            const start = this.block.has_update_method ? 0 : "#old_length";
            let remove_old_blocks;
            if (this.block.has_outros) {
              const out = block.get_unique_name("out");
              block.chunks.init.push(b`
					const ${out} = i => @transition_out(${iterations}[i], 1, 1, () => {
						${iterations}[i] = null;
					});
				`);
              remove_old_blocks = b`
					@group_outros();
					for (#i = ${data_length}; #i < ${view_length}; #i += 1) {
						${out}(#i);
					}
					@check_outros();
				`;
            } else {
              remove_old_blocks = b`
					for (${this.block.has_update_method ? null : x`#i = ${data_length}`}; #i < ${this.block.has_update_method ? view_length : "#old_length"}; #i += 1) {
						${iterations}[#i].d(1);
					}
					${!fixed_length && b`${view_length} = ${data_length};`}
				`;
            }
            const update = b`
				${!this.block.has_update_method && b`const #old_length = ${this.vars.each_block_value}.length;`}
				${this.vars.each_block_value} = ${snippet};
				${this.renderer.options.dev && b`@validate_each_argument(${this.vars.each_block_value});`}

				let #i;
				for (#i = ${start}; #i < ${data_length}; #i += 1) {
					const child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);

					${for_loop_body}
				}

				${remove_old_blocks}
			`;
            this.updates.push(update);
          }
          if (this.block.has_outros) {
            block.chunks.outro.push(b`
				${iterations} = ${iterations}.filter(@_Boolean);
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
          }
          block.chunks.destroy.push(b`@destroy_each(${iterations}, detaching);`);
        }
      }
      function string_literal(data2) {
        return {
          type: "Literal",
          value: data2
        };
      }
      const escaped3 = {
        '"': "&quot;",
        "'": "&#39;",
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;"
      };
      function escape_html(html2) {
        return String(html2).replace(/["'&<>]/g, (match) => escaped3[match]);
      }
      function escape_template(str2) {
        return str2.replace(/(\${|`|\\)/g, "\\$1");
      }
      class TextWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, data2) {
          super(renderer, block, parent, node2);
          this.skip = this.node.should_skip();
          this.data = data2;
          this.var = this.skip ? null : x`t`;
        }
        use_space() {
          if (this.renderer.component.component_options.preserveWhitespace)
            return false;
          if (/[\S\u00A0]/.test(this.data))
            return false;
          let node2 = this.parent && this.parent.node;
          while (node2) {
            if (node2.type === "Element" && node2.name === "pre") {
              return false;
            }
            node2 = node2.parent;
          }
          return true;
        }
        render(block, parent_node, parent_nodes) {
          if (this.skip)
            return;
          const use_space = this.use_space();
          const string_literal2 = {
            type: "Literal",
            value: this.data,
            loc: {
              start: this.renderer.locate(this.node.start),
              end: this.renderer.locate(this.node.end)
            }
          };
          block.add_element(this.var, use_space ? x`@space()` : x`@text(${string_literal2})`, parent_nodes && (use_space ? x`@claim_space(${parent_nodes})` : x`@claim_text(${parent_nodes}, ${string_literal2})`), parent_node);
        }
      }
      const svg_attributes = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(" ");
      const svg_attribute_lookup = new Map();
      svg_attributes.forEach((name) => {
        svg_attribute_lookup.set(name.toLowerCase(), name);
      });
      function fix_attribute_casing(name) {
        name = name.toLowerCase();
        return svg_attribute_lookup.get(name) || name;
      }
      const foreign = "https://svelte.dev/docs#svelte_options";
      const html = "http://www.w3.org/1999/xhtml";
      const mathml = "http://www.w3.org/1998/Math/MathML";
      const svg = "http://www.w3.org/2000/svg";
      const xlink = "http://www.w3.org/1999/xlink";
      const xml = "http://www.w3.org/XML/1998/namespace";
      const xmlns = "http://www.w3.org/2000/xmlns";
      const valid_namespaces = [
        "foreign",
        "html",
        "mathml",
        "svg",
        "xlink",
        "xml",
        "xmlns",
        foreign,
        html,
        mathml,
        svg,
        xlink,
        xml,
        xmlns
      ];
      const namespaces = { foreign, html, mathml, svg, xlink, xml, xmlns };
      function handle_select_value_binding(attr, dependencies) {
        const { parent } = attr;
        if (parent.node.name === "select") {
          parent.select_binding_dependencies = dependencies;
          dependencies.forEach((prop) => {
            parent.renderer.component.indirect_dependencies.set(prop, new Set());
          });
        }
      }
      class BaseAttributeWrapper {
        constructor(parent, block, node2) {
          this.node = node2;
          this.parent = parent;
          if (node2.dependencies.size > 0) {
            parent.cannot_use_innerhtml();
            parent.not_static_content();
            block.add_dependencies(node2.dependencies);
          }
        }
        render(_block) {
        }
      }
      class AttributeWrapper extends BaseAttributeWrapper {
        constructor(parent, block, node2) {
          super(parent, block, node2);
          if (node2.dependencies.size > 0) {
            if (this.parent.node.name === "option" && node2.name === "value") {
              let select = this.parent;
              while (select && (select.node.type !== "Element" || select.node.name !== "select")) {
                select = select.parent;
              }
              if (select && select.select_binding_dependencies) {
                select.select_binding_dependencies.forEach((prop) => {
                  this.node.dependencies.forEach((dependency) => {
                    this.parent.renderer.component.indirect_dependencies.get(prop).add(dependency);
                  });
                });
              }
            }
            if (node2.name === "value") {
              handle_select_value_binding(this, node2.dependencies);
            }
          }
          if (this.parent.node.namespace == namespaces.foreign) {
            this.name = this.node.name;
            this.metadata = this.get_metadata();
            this.is_indirectly_bound_value = false;
            this.property_name = null;
            this.is_select_value_attribute = false;
            this.is_input_value = false;
          } else {
            this.name = fix_attribute_casing(this.node.name);
            this.metadata = this.get_metadata();
            this.is_indirectly_bound_value = is_indirectly_bound_value(this);
            this.property_name = this.is_indirectly_bound_value ? "__value" : this.metadata && this.metadata.property_name;
            this.is_select_value_attribute = this.name === "value" && this.parent.node.name === "select";
            this.is_input_value = this.name === "value" && this.parent.node.name === "input";
          }
          this.is_src = this.name === "src";
          this.should_cache = should_cache(this);
        }
        render(block) {
          const element = this.parent;
          const { name, property_name, should_cache: should_cache2, is_indirectly_bound_value: is_indirectly_bound_value2 } = this;
          const method = /-/.test(element.node.name) ? "@set_custom_element_data" : name.slice(0, 6) === "xlink:" ? "@xlink_attr" : "@attr";
          const is_legacy_input_type = element.renderer.component.compile_options.legacy && name === "type" && this.parent.node.name === "input";
          const dependencies = this.get_dependencies();
          const value2 = this.get_value(block);
          let updater;
          const init2 = this.get_init(block, value2);
          if (is_legacy_input_type) {
            block.chunks.hydrate.push(b`@set_input_type(${element.var}, ${init2});`);
            updater = b`@set_input_type(${element.var}, ${should_cache2 ? this.last : value2});`;
          } else if (this.is_select_value_attribute) {
            const is_multiple_select = element.node.get_static_attribute_value("multiple");
            if (is_multiple_select) {
              updater = b`@select_options(${element.var}, ${value2});`;
            } else {
              updater = b`@select_option(${element.var}, ${value2});`;
            }
            block.chunks.mount.push(b`
				${updater}
			`);
          } else if (this.is_src) {
            block.chunks.hydrate.push(b`if (!@src_url_equal(${element.var}.src, ${init2})) ${method}(${element.var}, "${name}", ${this.last});`);
            updater = b`${method}(${element.var}, "${name}", ${should_cache2 ? this.last : value2});`;
          } else if (property_name) {
            block.chunks.hydrate.push(b`${element.var}.${property_name} = ${init2};`);
            updater = block.renderer.options.dev ? b`@prop_dev(${element.var}, "${property_name}", ${should_cache2 ? this.last : value2});` : b`${element.var}.${property_name} = ${should_cache2 ? this.last : value2};`;
          } else {
            block.chunks.hydrate.push(b`${method}(${element.var}, "${name}", ${init2});`);
            updater = b`${method}(${element.var}, "${name}", ${should_cache2 ? this.last : value2});`;
          }
          if (is_indirectly_bound_value2) {
            const update_value = b`${element.var}.value = ${element.var}.__value;`;
            block.chunks.hydrate.push(update_value);
            updater = b`
				${updater}
				${update_value};
			`;
          }
          if (dependencies.length > 0) {
            const condition = this.get_dom_update_conditions(block, block.renderer.dirty(dependencies));
            block.chunks.update.push(b`
				if (${condition}) {
					${updater}
				}`);
          }
          if (name === "autofocus") {
            block.autofocus = {
              element_var: element.var,
              condition_expression: this.node.is_true ? void 0 : value2
            };
          }
        }
        get_init(block, value2) {
          this.last = this.should_cache && block.get_unique_name(`${this.parent.var.name}_${this.name.replace(/[^a-zA-Z_$]/g, "_")}_value`);
          if (this.should_cache)
            block.add_variable(this.last);
          return this.should_cache ? x`${this.last} = ${value2}` : value2;
        }
        get_dom_update_conditions(block, dependency_condition) {
          const { property_name, should_cache: should_cache2, last } = this;
          const element = this.parent;
          const value2 = this.get_value(block);
          let condition = dependency_condition;
          if (should_cache2) {
            condition = this.is_src ? x`${condition} && (!@src_url_equal(${element.var}.src, (${last} = ${value2})))` : x`${condition} && (${last} !== (${last} = ${value2}))`;
          }
          if (this.is_input_value) {
            const type = element.node.get_static_attribute_value("type");
            if (type === null || type === "" || type === "text" || type === "email" || type === "password") {
              condition = x`${condition} && ${element.var}.${property_name} !== ${should_cache2 ? last : value2}`;
            }
          }
          if (block.has_outros) {
            condition = x`!#current || ${condition}`;
          }
          return condition;
        }
        get_dependencies() {
          const node_dependencies = this.node.get_dependencies();
          const dependencies = new Set(node_dependencies);
          node_dependencies.forEach((prop) => {
            const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
            if (indirect_dependencies) {
              indirect_dependencies.forEach((indirect_dependency) => {
                dependencies.add(indirect_dependency);
              });
            }
          });
          return Array.from(dependencies);
        }
        get_metadata() {
          if (this.parent.node.namespace)
            return null;
          const metadata2 = attribute_lookup[this.name];
          if (metadata2 && metadata2.applies_to && !metadata2.applies_to.includes(this.parent.node.name))
            return null;
          return metadata2;
        }
        get_value(block) {
          if (this.node.is_true) {
            if (this.metadata && boolean_attribute.has(this.metadata.property_name.toLowerCase())) {
              return x`true`;
            }
            return x`""`;
          }
          if (this.node.chunks.length === 0)
            return x`""`;
          if (this.node.chunks.length === 1) {
            return this.node.chunks[0].type === "Text" ? string_literal(this.node.chunks[0].data) : this.node.chunks[0].manipulate(block);
          }
          let value2 = this.node.name === "class" ? this.get_class_name_text(block) : this.render_chunks(block).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
          if (this.node.chunks[0].type !== "Text") {
            value2 = x`"" + ${value2}`;
          }
          return value2;
        }
        get_class_name_text(block) {
          const scoped_css = this.node.chunks.some((chunk) => chunk.synthetic);
          const rendered = this.render_chunks(block);
          if (scoped_css && rendered.length === 2) {
            rendered[0] = x`@null_to_empty(${rendered[0]})`;
          }
          return rendered.reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
        }
        render_chunks(block) {
          return this.node.chunks.map((chunk) => {
            if (chunk.type === "Text") {
              return string_literal(chunk.data);
            }
            return chunk.manipulate(block);
          });
        }
        stringify() {
          if (this.node.is_true)
            return "";
          const value2 = this.node.chunks;
          if (value2.length === 0)
            return '=""';
          return `="${value2.map((chunk) => {
            return chunk.type === "Text" ? chunk.data.replace(/"/g, '\\"') : `\${${chunk.manipulate()}}`;
          }).join("")}"`;
        }
      }
      const attribute_lookup = {
        allowfullscreen: { property_name: "allowFullscreen", applies_to: ["iframe"] },
        allowpaymentrequest: { property_name: "allowPaymentRequest", applies_to: ["iframe"] },
        async: { applies_to: ["script"] },
        autofocus: { applies_to: ["button", "input", "keygen", "select", "textarea"] },
        autoplay: { applies_to: ["audio", "video"] },
        checked: { applies_to: ["input"] },
        controls: { applies_to: ["audio", "video"] },
        default: { applies_to: ["track"] },
        defer: { applies_to: ["script"] },
        disabled: {
          applies_to: [
            "button",
            "fieldset",
            "input",
            "keygen",
            "optgroup",
            "option",
            "select",
            "textarea"
          ]
        },
        formnovalidate: { property_name: "formNoValidate", applies_to: ["button", "input"] },
        hidden: {},
        indeterminate: { applies_to: ["input"] },
        ismap: { property_name: "isMap", applies_to: ["img"] },
        loop: { applies_to: ["audio", "bgsound", "video"] },
        multiple: { applies_to: ["input", "select"] },
        muted: { applies_to: ["audio", "video"] },
        nomodule: { property_name: "noModule", applies_to: ["script"] },
        novalidate: { property_name: "noValidate", applies_to: ["form"] },
        open: { applies_to: ["details", "dialog"] },
        playsinline: { property_name: "playsInline", applies_to: ["video"] },
        readonly: { property_name: "readOnly", applies_to: ["input", "textarea"] },
        required: { applies_to: ["input", "select", "textarea"] },
        reversed: { applies_to: ["ol"] },
        selected: { applies_to: ["option"] },
        value: {
          applies_to: [
            "button",
            "option",
            "input",
            "li",
            "meter",
            "progress",
            "param",
            "select",
            "textarea"
          ]
        }
      };
      Object.keys(attribute_lookup).forEach((name) => {
        const metadata2 = attribute_lookup[name];
        if (!metadata2.property_name)
          metadata2.property_name = name;
      });
      const boolean_attribute = new Set([
        "allowfullscreen",
        "allowpaymentrequest",
        "async",
        "autofocus",
        "autoplay",
        "checked",
        "controls",
        "default",
        "defer",
        "disabled",
        "formnovalidate",
        "hidden",
        "ismap",
        "itemscope",
        "loop",
        "multiple",
        "muted",
        "nomodule",
        "novalidate",
        "open",
        "playsinline",
        "readonly",
        "required",
        "reversed",
        "selected"
      ]);
      function should_cache(attribute) {
        return attribute.is_src || attribute.node.should_cache();
      }
      function is_indirectly_bound_value(attribute) {
        const element = attribute.parent;
        return attribute.name === "value" && (element.node.name === "option" || element.node.name === "input" && element.node.bindings.some((binding) => /checked|group/.test(binding.name)));
      }
      class StyleAttributeWrapper extends AttributeWrapper {
        render(block) {
          const style_props = optimize_style(this.node.chunks);
          if (!style_props)
            return super.render(block);
          style_props.forEach((prop) => {
            let value2;
            if (is_dynamic(prop.value)) {
              const prop_dependencies = new Set();
              value2 = prop.value.map((chunk) => {
                if (chunk.type === "Text") {
                  return string_literal(chunk.data);
                } else {
                  add_to_set(prop_dependencies, chunk.dynamic_dependencies());
                  return chunk.manipulate(block);
                }
              }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
              if (prop_dependencies.size) {
                let condition = block.renderer.dirty(Array.from(prop_dependencies));
                if (block.has_outros) {
                  condition = x`!#current || ${condition}`;
                }
                const update = b`
						if (${condition}) {
							@set_style(${this.parent.var}, "${prop.key}", ${value2}, ${prop.important ? 1 : null});
						}`;
                block.chunks.update.push(update);
              }
            } else {
              value2 = string_literal(prop.value[0].data);
            }
            block.chunks.hydrate.push(b`@set_style(${this.parent.var}, "${prop.key}", ${value2}, ${prop.important ? 1 : null});`);
          });
        }
      }
      function optimize_style(value2) {
        const props = [];
        let chunks = value2.slice();
        while (chunks.length) {
          const chunk = chunks[0];
          if (chunk.type !== "Text")
            return null;
          const key_match = /^\s*([\w-]+):\s*/.exec(chunk.data);
          if (!key_match)
            return null;
          const key = key_match[1];
          const offset = key_match.index + key_match[0].length;
          const remaining_data = chunk.data.slice(offset);
          if (remaining_data) {
            chunks[0] = {
              start: chunk.start + offset,
              end: chunk.end,
              type: "Text",
              data: remaining_data
            };
          } else {
            chunks.shift();
          }
          const result = get_style_value(chunks);
          props.push({ key, value: result.value, important: result.important });
          chunks = result.chunks;
        }
        return props;
      }
      function get_style_value(chunks) {
        const value2 = [];
        let in_url = false;
        let quote_mark = null;
        let escaped4 = false;
        let closed = false;
        while (chunks.length && !closed) {
          const chunk = chunks.shift();
          if (chunk.type === "Text") {
            let c2 = 0;
            while (c2 < chunk.data.length) {
              const char = chunk.data[c2];
              if (escaped4) {
                escaped4 = false;
              } else if (char === "\\") {
                escaped4 = true;
              } else if (char === quote_mark) {
                quote_mark = null;
              } else if (char === '"' || char === "'") {
                quote_mark = char;
              } else if (char === ")" && in_url) {
                in_url = false;
              } else if (char === "u" && chunk.data.slice(c2, c2 + 4) === "url(") {
                in_url = true;
              } else if (char === ";" && !in_url && !quote_mark) {
                closed = true;
                break;
              }
              c2 += 1;
            }
            if (c2 > 0) {
              value2.push({
                type: "Text",
                start: chunk.start,
                end: chunk.start + c2,
                data: chunk.data.slice(0, c2)
              });
            }
            while (/[;\s]/.test(chunk.data[c2]))
              c2 += 1;
            const remaining_data = chunk.data.slice(c2);
            if (remaining_data) {
              chunks.unshift({
                start: chunk.start + c2,
                end: chunk.end,
                type: "Text",
                data: remaining_data
              });
              break;
            }
          } else {
            value2.push(chunk);
          }
        }
        let important = false;
        const last_chunk = value2[value2.length - 1];
        if (last_chunk && last_chunk.type === "Text" && /\s*!important\s*$/.test(last_chunk.data)) {
          important = true;
          last_chunk.data = last_chunk.data.replace(/\s*!important\s*$/, "");
          if (!last_chunk.data)
            value2.pop();
        }
        return {
          chunks,
          value: value2,
          important
        };
      }
      function is_dynamic(value2) {
        return value2.length > 1 || value2[0].type !== "Text";
      }
      class SpreadAttributeWrapper extends BaseAttributeWrapper {
      }
      function replace_object(node2, replacement) {
        if (node2.type === "Identifier")
          return replacement;
        const ancestor = node2;
        let parent;
        while (node2.type === "MemberExpression") {
          parent = node2;
          node2 = node2.object;
        }
        parent.object = replacement;
        return ancestor;
      }
      function flatten_reference(node2) {
        const nodes = [];
        const parts = [];
        while (node2.type === "MemberExpression") {
          nodes.unshift(node2.property);
          if (!node2.computed) {
            parts.unshift(node2.property.name);
          } else {
            const computed_property = to_string$1(node2.property);
            if (computed_property) {
              parts.unshift(`[${computed_property}]`);
            }
          }
          node2 = node2.object;
        }
        const name = node2.type === "Identifier" ? node2.name : node2.type === "ThisExpression" ? "this" : null;
        nodes.unshift(node2);
        parts.unshift(name);
        return { name, nodes, parts };
      }
      function to_string$1(node2) {
        switch (node2.type) {
          case "Literal":
            return String(node2.value);
          case "Identifier":
            return node2.name;
        }
      }
      function mark_each_block_bindings(parent, binding) {
        binding.expression.references.forEach((name) => {
          const each_block = parent.node.scope.get_owner(name);
          if (each_block) {
            each_block.has_binding = true;
          }
        });
        if (binding.name === "group") {
          const add_index_binding = (name) => {
            const each_block = parent.node.scope.get_owner(name);
            if (each_block.type === "EachBlock") {
              each_block.has_index_binding = true;
              for (const dep of each_block.expression.contextual_dependencies) {
                add_index_binding(dep);
              }
            }
          };
          for (const name of binding.expression.contextual_dependencies) {
            add_index_binding(name);
          }
        }
      }
      class BindingWrapper {
        constructor(block, node2, parent) {
          this.node = node2;
          this.parent = parent;
          const { dependencies } = this.node.expression;
          block.add_dependencies(dependencies);
          handle_select_value_binding(this, dependencies);
          if (node2.is_contextual) {
            mark_each_block_bindings(this.parent, this.node);
          }
          this.object = get_object(this.node.expression.node).name;
          this.handler = get_event_handler(this, parent.renderer, block, this.object, this.node.raw_expression);
          this.snippet = this.node.expression.manipulate(block);
          this.is_readonly = this.node.is_readonly;
          this.needs_lock = this.node.name === "currentTime";
        }
        get_dependencies() {
          const dependencies = new Set(this.node.expression.dependencies);
          this.node.expression.dependencies.forEach((prop) => {
            const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
            if (indirect_dependencies) {
              indirect_dependencies.forEach((indirect_dependency) => {
                dependencies.add(indirect_dependency);
              });
            }
          });
          return dependencies;
        }
        is_readonly_media_attribute() {
          return this.node.is_readonly_media_attribute();
        }
        render(block, lock) {
          if (this.is_readonly)
            return;
          const { parent } = this;
          const update_conditions = this.needs_lock ? [x`!${lock}`] : [];
          const mount_conditions = [];
          const dependency_array = Array.from(this.get_dependencies());
          if (dependency_array.length > 0) {
            update_conditions.push(block.renderer.dirty(dependency_array));
          }
          if (parent.node.name === "input") {
            const type = parent.node.get_static_attribute_value("type");
            if (type === null || type === "" || type === "text" || type === "email" || type === "password") {
              update_conditions.push(x`${parent.var}.${this.node.name} !== ${this.snippet}`);
            } else if (type === "number") {
              update_conditions.push(x`@to_number(${parent.var}.${this.node.name}) !== ${this.snippet}`);
            }
          }
          let update_dom = get_dom_updater(parent, this);
          let mount_dom = update_dom;
          switch (this.node.name) {
            case "group": {
              const { binding_group, is_context, contexts, index: index2, keypath } = get_binding_group(parent.renderer, this.node, block);
              block.renderer.add_to_context("$$binding_groups");
              if (is_context && !block.binding_group_initialised.has(keypath)) {
                if (contexts.length > 1) {
                  let binding_group2 = x`${block.renderer.reference("$$binding_groups")}[${index2}]`;
                  for (const name of contexts.slice(0, -1)) {
                    binding_group2 = x`${binding_group2}[${block.renderer.reference(name)}]`;
                    block.chunks.init.push(b`${binding_group2} = ${binding_group2} || [];`);
                  }
                }
                block.chunks.init.push(b`${binding_group(true)} = [];`);
                block.binding_group_initialised.add(keypath);
              }
              block.chunks.hydrate.push(b`${binding_group(true)}.push(${parent.var});`);
              block.chunks.destroy.push(b`${binding_group(true)}.splice(${binding_group(true)}.indexOf(${parent.var}), 1);`);
              break;
            }
            case "textContent":
              update_conditions.push(x`${this.snippet} !== ${parent.var}.textContent`);
              mount_conditions.push(x`${this.snippet} !== void 0`);
              break;
            case "innerHTML":
              update_conditions.push(x`${this.snippet} !== ${parent.var}.innerHTML`);
              mount_conditions.push(x`${this.snippet} !== void 0`);
              break;
            case "currentTime":
              update_conditions.push(x`!@_isNaN(${this.snippet})`);
              mount_dom = null;
              break;
            case "playbackRate":
            case "volume":
              update_conditions.push(x`!@_isNaN(${this.snippet})`);
              mount_conditions.push(x`!@_isNaN(${this.snippet})`);
              break;
            case "paused": {
              const last = block.get_unique_name(`${parent.var.name}_is_paused`);
              block.add_variable(last, x`true`);
              update_conditions.push(x`${last} !== (${last} = ${this.snippet})`);
              update_dom = b`${parent.var}[${last} ? "pause" : "play"]();`;
              mount_dom = null;
              break;
            }
            case "value":
              if (parent.node.get_static_attribute_value("type") === "file") {
                update_dom = null;
                mount_dom = null;
              }
          }
          if (update_dom) {
            if (update_conditions.length > 0) {
              const condition = update_conditions.reduce((lhs, rhs) => x`${lhs} && ${rhs}`);
              block.chunks.update.push(b`
					if (${condition}) {
						${update_dom}
					}
				`);
            } else {
              block.chunks.update.push(update_dom);
            }
          }
          if (mount_dom) {
            if (mount_conditions.length > 0) {
              const condition = mount_conditions.reduce((lhs, rhs) => x`${lhs} && ${rhs}`);
              block.chunks.mount.push(b`
					if (${condition}) {
						${mount_dom}
					}
				`);
            } else {
              block.chunks.mount.push(mount_dom);
            }
          }
        }
      }
      function get_dom_updater(element, binding) {
        const { node: node2 } = element;
        if (binding.is_readonly_media_attribute()) {
          return null;
        }
        if (binding.node.name === "this") {
          return null;
        }
        if (node2.name === "select") {
          return node2.get_static_attribute_value("multiple") === true ? b`@select_options(${element.var}, ${binding.snippet})` : b`@select_option(${element.var}, ${binding.snippet})`;
        }
        if (binding.node.name === "group") {
          const type = node2.get_static_attribute_value("type");
          const condition = type === "checkbox" ? x`~${binding.snippet}.indexOf(${element.var}.__value)` : x`${element.var}.__value === ${binding.snippet}`;
          return b`${element.var}.checked = ${condition};`;
        }
        if (binding.node.name === "value") {
          return b`@set_input_value(${element.var}, ${binding.snippet});`;
        }
        return b`${element.var}.${binding.node.name} = ${binding.snippet};`;
      }
      function get_binding_group(renderer, value2, block) {
        const { parts } = flatten_reference(value2.raw_expression);
        let keypath = parts.join(".");
        const contexts = [];
        const contextual_dependencies = new Set();
        const { template_scope } = value2.expression;
        const add_contextual_dependency = (dep) => {
          contextual_dependencies.add(dep);
          const owner = template_scope.get_owner(dep);
          if (owner.type === "EachBlock") {
            for (const dep2 of owner.expression.contextual_dependencies) {
              add_contextual_dependency(dep2);
            }
          }
        };
        for (const dep of value2.expression.contextual_dependencies) {
          add_contextual_dependency(dep);
        }
        for (const dep of contextual_dependencies) {
          const context = block.bindings.get(dep);
          let key;
          let name;
          if (context) {
            key = context.object.name;
            name = context.property.name;
          } else {
            key = dep;
            name = dep;
          }
          keypath = `${key}@${keypath}`;
          contexts.push(name);
        }
        if (!renderer.binding_groups.has(keypath)) {
          const index2 = renderer.binding_groups.size;
          contexts.forEach((context) => {
            renderer.add_to_context(context, true);
          });
          renderer.binding_groups.set(keypath, {
            binding_group: (to_reference = false) => {
              let binding_group = "$$binding_groups";
              let _secondary_indexes = contexts;
              if (to_reference) {
                binding_group = block.renderer.reference(binding_group);
                _secondary_indexes = _secondary_indexes.map((name) => block.renderer.reference(name));
              }
              if (_secondary_indexes.length > 0) {
                let obj = x`${binding_group}[${index2}]`;
                _secondary_indexes.forEach((secondary_index) => {
                  obj = x`${obj}[${secondary_index}]`;
                });
                return obj;
              } else {
                return x`${binding_group}[${index2}]`;
              }
            },
            is_context: contexts.length > 0,
            contexts,
            index: index2,
            keypath
          });
        }
        return renderer.binding_groups.get(keypath);
      }
      function get_event_handler(binding, renderer, block, name, lhs) {
        const contextual_dependencies = new Set(binding.node.expression.contextual_dependencies);
        const context = block.bindings.get(name);
        let set_store;
        if (context) {
          const { object, property, store, snippet } = context;
          lhs = replace_object(lhs, snippet);
          contextual_dependencies.add(object.name);
          contextual_dependencies.add(property.name);
          contextual_dependencies.delete(name);
          if (store) {
            set_store = b`${store}.set(${`$${store}`});`;
          }
        } else {
          const object = get_object(lhs);
          if (object.name[0] === "$") {
            const store = object.name.slice(1);
            set_store = b`${store}.set(${object.name});`;
          }
        }
        const value2 = get_value_from_dom(renderer, binding.parent, binding, block, contextual_dependencies);
        const mutation = b`
		${lhs} = ${value2};
		${set_store}
	`;
        return {
          uses_context: binding.node.is_contextual || binding.node.expression.uses_context,
          mutation,
          contextual_dependencies,
          lhs
        };
      }
      function get_value_from_dom(renderer, element, binding, block, contextual_dependencies) {
        const { node: node2 } = element;
        const { name } = binding.node;
        if (name === "this") {
          return x`$$value`;
        }
        if (node2.name === "select") {
          return node2.get_static_attribute_value("multiple") === true ? x`@select_multiple_value(this)` : x`@select_value(this)`;
        }
        const type = node2.get_static_attribute_value("type");
        if (name === "group") {
          if (type === "checkbox") {
            const { binding_group, contexts } = get_binding_group(renderer, binding.node, block);
            add_to_set(contextual_dependencies, contexts);
            return x`@get_binding_group_value(${binding_group()}, this.__value, this.checked)`;
          }
          return x`this.__value`;
        }
        if (type === "range" || type === "number") {
          return x`@to_number(this.${name})`;
        }
        if (name === "buffered" || name === "seekable" || name === "played") {
          return x`@time_ranges_to_array(this.${name})`;
        }
        return x`this.${name}`;
      }
      function compare_node(a, b2) {
        if (a === b2)
          return true;
        if (!a || !b2)
          return false;
        if (a.type !== b2.type)
          return false;
        switch (a.type) {
          case "Identifier":
            return a.name === b2.name;
          case "MemberExpression":
            return compare_node(a.object, b2.object) && compare_node(a.property, b2.property) && a.computed === b2.computed;
          case "Literal":
            return a.value === b2.value;
        }
      }
      function bind_this(component, block, binding, variable) {
        const fn = component.get_unique_name(`${variable.name}_binding`);
        block.renderer.add_to_context(fn.name);
        const callee = block.renderer.reference(fn.name);
        const { contextual_dependencies, mutation } = binding.handler;
        const dependencies = binding.get_dependencies();
        const body = b`
		${mutation}
		${Array.from(dependencies).filter((dep) => dep[0] !== "$").filter((dep) => !contextual_dependencies.has(dep)).map((dep) => b`${block.renderer.invalidate(dep)};`)}
	`;
        if (contextual_dependencies.size) {
          const params = Array.from(contextual_dependencies).map((name) => ({
            type: "Identifier",
            name
          }));
          component.partly_hoisted.push(b`
			function ${fn}($$value, ${params}) {
				@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
					${body}
				});
			}
		`);
          const alias_map = new Map();
          const args = [];
          for (let id2 of params) {
            const value2 = block.renderer.reference(id2.name);
            let found = false;
            if (block.variables.has(id2.name)) {
              let alias = id2.name;
              for (let i2 = 1; block.variables.has(alias) && !compare_node(block.variables.get(alias).init, value2); alias = `${id2.name}_${i2++}`)
                ;
              alias_map.set(alias, id2.name);
              id2 = { type: "Identifier", name: alias };
              found = block.variables.has(alias);
            }
            args.push(id2);
            if (!found) {
              block.add_variable(id2, value2);
            }
          }
          const assign = block.get_unique_name(`assign_${variable.name}`);
          const unassign = block.get_unique_name(`unassign_${variable.name}`);
          block.chunks.init.push(b`
			const ${assign} = () => ${callee}(${variable}, ${args});
			const ${unassign} = () => ${callee}(null, ${args});
		`);
          const condition = Array.from(args).map((name) => x`${name} !== ${block.renderer.reference(alias_map.get(name.name) || name.name)}`).reduce((lhs, rhs) => x`${lhs} || ${rhs}`);
          block.chunks.update.push(b`
			if (${condition}) {
				${unassign}();
				${args.map((a) => b`${a} = ${block.renderer.reference(alias_map.get(a.name) || a.name)}`)};
				${assign}();
			}`);
          block.chunks.destroy.push(b`${unassign}();`);
          return b`${assign}();`;
        }
        component.partly_hoisted.push(b`
		function ${fn}($$value) {
			@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				${body}
			});
		}
	`);
        block.chunks.destroy.push(b`${callee}(null);`);
        return b`${callee}(${variable});`;
      }
      class Node$1 {
        constructor(component, parent, _scope, info) {
          this.start = info.start;
          this.end = info.end;
          this.type = info.type;
          Object.defineProperties(this, {
            component: {
              value: component
            },
            parent: {
              value: parent
            }
          });
        }
        cannot_use_innerhtml() {
          if (this.can_use_innerhtml !== false) {
            this.can_use_innerhtml = false;
            if (this.parent)
              this.parent.cannot_use_innerhtml();
          }
        }
        find_nearest(selector2) {
          if (selector2.test(this.type))
            return this;
          if (this.parent)
            return this.parent.find_nearest(selector2);
        }
        get_static_attribute_value(name) {
          const attribute = this.attributes && this.attributes.find((attr) => attr.type === "Attribute" && attr.name.toLowerCase() === name);
          if (!attribute)
            return null;
          if (attribute.is_true)
            return true;
          if (attribute.chunks.length === 0)
            return "";
          if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Text") {
            return attribute.chunks[0].data;
          }
          return null;
        }
        has_ancestor(type) {
          return this.parent ? this.parent.type === type || this.parent.has_ancestor(type) : false;
        }
      }
      function create_scopes(expression2) {
        return analyze(expression2);
      }
      function is_dynamic$1(variable) {
        if (variable) {
          if (variable.mutated || variable.reassigned)
            return true;
          if (!variable.module && variable.writable && variable.export_name)
            return true;
          if (is_reserved_keyword(variable.name))
            return true;
        }
        return false;
      }
      function nodes_match(a, b2) {
        if (!!a !== !!b2)
          return false;
        if (Array.isArray(a) !== Array.isArray(b2))
          return false;
        if (a && typeof a === "object") {
          if (Array.isArray(a)) {
            if (a.length !== b2.length)
              return false;
            return a.every((child, i3) => nodes_match(child, b2[i3]));
          }
          const a_keys = Object.keys(a).sort();
          const b_keys = Object.keys(b2).sort();
          if (a_keys.length !== b_keys.length)
            return false;
          let i2 = a_keys.length;
          while (i2--) {
            const key = a_keys[i2];
            if (b_keys[i2] !== key)
              return false;
            if (key === "start" || key === "end")
              continue;
            if (!nodes_match(a[key], b2[key])) {
              return false;
            }
          }
          return true;
        }
        return a === b2;
      }
      function invalidate(renderer, scope2, node2, names2, main_execution_context = false) {
        const { component } = renderer;
        const [head, ...tail] = Array.from(names2).filter((name) => {
          const owner = scope2.find_owner(name);
          return !owner || owner === component.instance_scope;
        }).map((name) => component.var_lookup.get(name)).filter((variable) => {
          return variable && (!variable.hoistable && !variable.global && !variable.module && (variable.referenced || variable.subscribable || variable.is_reactive_dependency || variable.export_name || variable.name[0] === "$"));
        });
        function get_invalidated(variable, node3) {
          if (main_execution_context && !variable.subscribable && variable.name[0] !== "$") {
            return node3;
          }
          return renderer_invalidate(renderer, variable.name, void 0, main_execution_context);
        }
        if (!head) {
          return node2;
        }
        component.has_reactive_assignments = true;
        if (node2.type === "AssignmentExpression" && node2.operator === "=" && nodes_match(node2.left, node2.right) && tail.length === 0) {
          return get_invalidated(head, node2);
        }
        const is_store_value = head.name[0] === "$" && head.name[1] !== "$";
        const extra_args = tail.map((variable) => get_invalidated(variable)).filter(Boolean);
        if (is_store_value) {
          return x`@set_store_value(${head.name.slice(1)}, ${node2}, ${head.name}, ${extra_args})`;
        }
        let invalidate2;
        if (!main_execution_context) {
          const pass_value = extra_args.length > 0 || node2.type === "AssignmentExpression" && node2.left.type !== "Identifier" || node2.type === "UpdateExpression" && (!node2.prefix || node2.argument.type !== "Identifier");
          if (pass_value) {
            extra_args.unshift({
              type: "Identifier",
              name: head.name
            });
          }
          invalidate2 = x`$$invalidate(${renderer.context_lookup.get(head.name).index}, ${node2}, ${extra_args})`;
        } else {
          invalidate2 = extra_args.length ? [node2, ...extra_args] : node2;
        }
        if (head.subscribable && head.reassigned) {
          const subscribe = `$$subscribe_${head.name}`;
          invalidate2 = x`${subscribe}(${invalidate2})`;
        }
        return invalidate2;
      }
      function renderer_invalidate(renderer, name, value2, main_execution_context = false) {
        const variable = renderer.component.var_lookup.get(name);
        if (variable && (variable.subscribable && (variable.reassigned || variable.export_name))) {
          if (main_execution_context) {
            return x`${`$$subscribe_${name}`}(${value2 || name})`;
          } else {
            const member = renderer.context_lookup.get(name);
            return x`${`$$subscribe_${name}`}($$invalidate(${member.index}, ${value2 || name}))`;
          }
        }
        if (name[0] === "$" && name[1] !== "$") {
          return x`${name.slice(1)}.set(${value2 || name})`;
        }
        if (variable && (variable.module || !variable.referenced && !variable.is_reactive_dependency && !variable.export_name && !name.startsWith("$$"))) {
          return value2 || name;
        }
        if (value2) {
          if (main_execution_context) {
            return x`${value2}`;
          } else {
            const member = renderer.context_lookup.get(name);
            return x`$$invalidate(${member.index}, ${value2})`;
          }
        }
        if (main_execution_context)
          return;
        const deps = new Set([name]);
        deps.forEach((name2) => {
          const reactive_declarations = renderer.component.reactive_declarations.filter((x2) => x2.assignees.has(name2));
          reactive_declarations.forEach((declaration) => {
            declaration.dependencies.forEach((name3) => {
              deps.add(name3);
            });
          });
        });
        const filtered = Array.from(deps).filter((n2) => renderer.context_lookup.has(n2));
        if (!filtered.length)
          return null;
        return filtered.map((n2) => x`$$invalidate(${renderer.context_lookup.get(n2).index}, ${n2})`).reduce((lhs, rhs) => x`${lhs}, ${rhs}`);
      }
      function clone2(val) {
        let k, out, tmp;
        if (Array.isArray(val)) {
          out = Array(k = val.length);
          while (k--)
            out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone2(tmp) : tmp;
          return out;
        }
        if (Object.prototype.toString.call(val) === "[object Object]") {
          out = {};
          for (k in val) {
            if (k === "__proto__") {
              Object.defineProperty(out, k, {
                value: clone2(val[k]),
                configurable: true,
                enumerable: true,
                writable: true
              });
            } else if (typeof val[k] !== "function") {
              out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone2(tmp) : tmp;
            }
          }
          return out;
        }
        return val;
      }
      var compiler_errors = {
        invalid_binding_elements: (element, binding) => ({
          code: "invalid-binding",
          message: `'${binding}' is not a valid binding on <${element}> elements`
        }),
        invalid_binding_element_with: (elements, binding) => ({
          code: "invalid-binding",
          message: `'${binding}' binding can only be used with ${elements}`
        }),
        invalid_binding_on: (binding, element, post) => ({
          code: "invalid-binding",
          message: `'${binding}' is not a valid binding on ${element}` + (post || "")
        }),
        invalid_binding_foreign: (binding) => ({
          code: "invalid-binding",
          message: `'${binding}' is not a valid binding. Foreign elements only support bind:this`
        }),
        invalid_binding_no_checkbox: (binding, is_radio) => ({
          code: "invalid-binding",
          message: `'${binding}' binding can only be used with <input type="checkbox">` + (is_radio ? ` \u2014 for <input type="radio">, use 'group' binding` : "")
        }),
        invalid_binding: (binding) => ({
          code: "invalid-binding",
          message: `'${binding}' is not a valid binding`
        }),
        invalid_binding_window: (parts) => ({
          code: "invalid-binding",
          message: `Bindings on <svelte:window> must be to top-level properties, e.g. '${parts[parts.length - 1]}' rather than '${parts.join(".")}'`
        }),
        invalid_binding_let: {
          code: "invalid-binding",
          message: "Cannot bind to a variable declared with the let: directive"
        },
        invalid_binding_await: {
          code: "invalid-binding",
          message: "Cannot bind to a variable declared with {#await ... then} or {:catch} blocks"
        },
        invalid_binding_writibale: {
          code: "invalid-binding",
          message: "Cannot bind to a variable which is not writable"
        },
        binding_undeclared: (name) => ({
          code: "binding-undeclared",
          message: `${name} is not declared`
        }),
        invalid_type: {
          code: "invalid-type",
          message: "'type' attribute cannot be dynamic if input uses two-way binding"
        },
        missing_type: {
          code: "missing-type",
          message: "'type' attribute must be specified"
        },
        dynamic_multiple_attribute: {
          code: "dynamic-multiple-attribute",
          message: "'multiple' attribute cannot be dynamic if select uses two-way binding"
        },
        missing_contenteditable_attribute: {
          code: "missing-contenteditable-attribute",
          message: "'contenteditable' attribute is required for textContent and innerHTML two-way bindings"
        },
        dynamic_contenteditable_attribute: {
          code: "dynamic-contenteditable-attribute",
          message: "'contenteditable' attribute cannot be dynamic if element uses two-way binding"
        },
        invalid_event_modifier_combination: (modifier1, modifier2) => ({
          code: "invalid-event-modifier",
          message: `The '${modifier1}' and '${modifier2}' modifiers cannot be used together`
        }),
        invalid_event_modifier_legacy: (modifier) => ({
          code: "invalid-event-modifier",
          message: `The '${modifier}' modifier cannot be used in legacy mode`
        }),
        invalid_event_modifier: (valid) => ({
          code: "invalid-event-modifier",
          message: `Valid event modifiers are ${valid}`
        }),
        invalid_event_modifier_component: {
          code: "invalid-event-modifier",
          message: "Event modifiers other than 'once' can only be used on DOM elements"
        },
        textarea_duplicate_value: {
          code: "textarea-duplicate-value",
          message: "A <textarea> can have either a value attribute or (equivalently) child content, but not both"
        },
        illegal_attribute: (name) => ({
          code: "illegal-attribute",
          message: `'${name}' is not a valid attribute name`
        }),
        invalid_slot_attribute: {
          code: "invalid-slot-attribute",
          message: "slot attribute cannot have a dynamic value"
        },
        duplicate_slot_attribute: (name) => ({
          code: "duplicate-slot-attribute",
          message: `Duplicate '${name}' slot`
        }),
        invalid_slotted_content: {
          code: "invalid-slotted-content",
          message: "Element with a slot='...' attribute must be a child of a component or a descendant of a custom element"
        },
        invalid_attribute_head: {
          code: "invalid-attribute",
          message: "<svelte:head> should not have any attributes or directives"
        },
        invalid_action: {
          code: "invalid-action",
          message: "Actions can only be applied to DOM elements, not components"
        },
        invalid_class: {
          code: "invalid-class",
          message: "Classes can only be applied to DOM elements, not components"
        },
        invalid_transition: {
          code: "invalid-transition",
          message: "Transitions can only be applied to DOM elements, not components"
        },
        invalid_let: {
          code: "invalid-let",
          message: "let directive value must be an identifier or an object/array pattern"
        },
        invalid_slot_directive: {
          code: "invalid-slot-directive",
          message: "<slot> cannot have directives"
        },
        dynamic_slot_name: {
          code: "dynamic-slot-name",
          message: "<slot> name cannot be dynamic"
        },
        invalid_slot_name: {
          code: "invalid-slot-name",
          message: "default is a reserved word \u2014 it cannot be used as a slot name"
        },
        invalid_slot_attribute_value_missing: {
          code: "invalid-slot-attribute",
          message: "slot attribute value is missing"
        },
        invalid_slotted_content_fragment: {
          code: "invalid-slotted-content",
          message: "<svelte:fragment> must be a child of a component"
        },
        illegal_attribute_title: {
          code: "illegal-attribute",
          message: "<title> cannot have attributes"
        },
        illegal_structure_title: {
          code: "illegal-structure",
          message: "<title> can only contain text and {tags}"
        },
        duplicate_transition: (directive, parent_directive) => {
          function describe(_directive) {
            return _directive === "transition" ? "a 'transition'" : `an '${_directive}'`;
          }
          const message = directive === parent_directive ? `An element can only have one '${directive}' directive` : `An element cannot have both ${describe(parent_directive)} directive and ${describe(directive)} directive`;
          return {
            code: "duplicate-transition",
            message
          };
        },
        contextual_store: {
          code: "contextual-store",
          message: "Stores must be declared at the top level of the component (this may change in a future version of Svelte)"
        },
        default_export: {
          code: "default-export",
          message: "A component cannot have a default export"
        },
        illegal_declaration: {
          code: "illegal-declaration",
          message: "The $ prefix is reserved, and cannot be used for variable and import names"
        },
        illegal_subscription: {
          code: "illegal-subscription",
          message: 'Cannot reference store value inside <script context="module">'
        },
        illegal_global: (name) => ({
          code: "illegal-global",
          message: `${name} is an illegal variable name`
        }),
        cyclical_reactive_declaration: (cycle) => ({
          code: "cyclical-reactive-declaration",
          message: `Cyclical dependency detected: ${cycle.join(" \u2192 ")}`
        }),
        invalid_tag_property: {
          code: "invalid-tag-property",
          message: "tag name must be two or more words joined by the '-' character"
        },
        invalid_tag_attribute: {
          code: "invalid-tag-attribute",
          message: "'tag' must be a string literal"
        },
        invalid_namespace_property: (namespace, suggestion) => ({
          code: "invalid-namespace-property",
          message: `Invalid namespace '${namespace}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
        }),
        invalid_namespace_attribute: {
          code: "invalid-namespace-attribute",
          message: "The 'namespace' attribute must be a string literal representing a valid namespace"
        },
        invalid_attribute_value: (name) => ({
          code: `invalid-${name}-value`,
          message: `${name} attribute must be true or false`
        }),
        invalid_options_attribute_unknown: {
          code: "invalid-options-attribute",
          message: "<svelte:options> unknown attribute"
        },
        invalid_options_attribute: {
          code: "invalid-options-attribute",
          message: "<svelte:options> can only have static 'tag', 'namespace', 'accessors', 'immutable' and 'preserveWhitespace' attributes"
        },
        css_invalid_global: {
          code: "css-invalid-global",
          message: ":global(...) can be at the start or end of a selector sequence, but not in the middle"
        },
        css_invalid_global_selector: {
          code: "css-invalid-global-selector",
          message: ":global(...) must contain a single selector"
        },
        duplicate_animation: {
          code: "duplicate-animation",
          message: "An element can only have one 'animate' directive"
        },
        invalid_animation_immediate: {
          code: "invalid-animation",
          message: "An element that uses the animate directive must be the immediate child of a keyed each block"
        },
        invalid_animation_sole: {
          code: "invalid-animation",
          message: "An element that uses the animate directive must be the sole child of a keyed each block"
        },
        invalid_directive_value: {
          code: "invalid-directive-value",
          message: "Can only bind to an identifier (e.g. `foo`) or a member expression (e.g. `foo.bar` or `foo[baz]`)"
        }
      };
      class Expression {
        constructor(component, owner, template_scope, info, lazy) {
          this.type = "Expression";
          this.references = new Set();
          this.dependencies = new Set();
          this.contextual_dependencies = new Set();
          this.declarations = [];
          this.uses_context = false;
          Object.defineProperties(this, {
            component: {
              value: component
            }
          });
          this.node = info;
          this.template_scope = template_scope;
          this.owner = owner;
          const { dependencies, contextual_dependencies, references } = this;
          let { map, scope: scope2 } = create_scopes(info);
          this.scope = scope2;
          this.scope_map = map;
          const expression2 = this;
          let function_expression;
          walk(info, {
            enter(node2, parent, key) {
              if (key === "key" && parent.shorthand)
                return;
              if (node2.type === "MetaProperty")
                return this.skip();
              if (map.has(node2)) {
                scope2 = map.get(node2);
              }
              if (!function_expression && /FunctionExpression/.test(node2.type)) {
                function_expression = node2;
              }
              if (is_reference(node2, parent)) {
                const { name, nodes } = flatten_reference(node2);
                references.add(name);
                if (scope2.has(name))
                  return;
                if (name[0] === "$") {
                  const store_name = name.slice(1);
                  if (template_scope.names.has(store_name) || scope2.has(store_name)) {
                    return component.error(node2, compiler_errors.contextual_store);
                  }
                }
                if (template_scope.is_let(name)) {
                  if (!function_expression) {
                    contextual_dependencies.add(name);
                    dependencies.add(name);
                  }
                } else if (template_scope.names.has(name)) {
                  expression2.uses_context = true;
                  contextual_dependencies.add(name);
                  const owner2 = template_scope.get_owner(name);
                  const is_index = owner2.type === "EachBlock" && owner2.key && name === owner2.index;
                  if (!lazy || is_index) {
                    template_scope.dependencies_for_name.get(name).forEach((name2) => dependencies.add(name2));
                  }
                } else {
                  if (!lazy) {
                    dependencies.add(name);
                  }
                  component.add_reference(name);
                  component.warn_if_undefined(name, nodes[0], template_scope);
                }
                this.skip();
              }
              let names2;
              let deep = false;
              if (function_expression) {
                if (node2.type === "AssignmentExpression") {
                  deep = node2.left.type === "MemberExpression";
                  names2 = extract_names(deep ? get_object(node2.left) : node2.left);
                } else if (node2.type === "UpdateExpression") {
                  names2 = extract_names(get_object(node2.argument));
                }
              }
              if (names2) {
                names2.forEach((name) => {
                  if (template_scope.names.has(name)) {
                    template_scope.dependencies_for_name.get(name).forEach((name2) => {
                      const variable = component.var_lookup.get(name2);
                      if (variable)
                        variable[deep ? "mutated" : "reassigned"] = true;
                    });
                    const each_block = template_scope.get_owner(name);
                    each_block.has_binding = true;
                  } else {
                    component.add_reference(name);
                    const variable = component.var_lookup.get(name);
                    if (variable)
                      variable[deep ? "mutated" : "reassigned"] = true;
                  }
                });
              }
            },
            leave(node2) {
              if (map.has(node2)) {
                scope2 = scope2.parent;
              }
              if (node2 === function_expression) {
                function_expression = null;
              }
            }
          });
        }
        dynamic_dependencies() {
          return Array.from(this.dependencies).filter((name) => {
            if (this.template_scope.is_let(name))
              return true;
            if (is_reserved_keyword(name))
              return true;
            const variable = this.component.var_lookup.get(name);
            return is_dynamic$1(variable);
          });
        }
        manipulate(block) {
          if (this.manipulated)
            return this.manipulated;
          const { component, declarations, scope_map: map, template_scope, owner } = this;
          let scope2 = this.scope;
          let function_expression;
          let dependencies;
          let contextual_dependencies;
          const node2 = walk(this.node, {
            enter(node3, parent) {
              if (node3.type === "Property" && node3.shorthand) {
                node3.value = clone2(node3.value);
                node3.shorthand = false;
              }
              if (map.has(node3)) {
                scope2 = map.get(node3);
              }
              if (node3.type === "Identifier" && is_reference(node3, parent)) {
                const { name } = flatten_reference(node3);
                if (scope2.has(name))
                  return;
                if (function_expression) {
                  if (template_scope.names.has(name)) {
                    contextual_dependencies.add(name);
                    template_scope.dependencies_for_name.get(name).forEach((dependency) => {
                      dependencies.add(dependency);
                    });
                  } else {
                    dependencies.add(name);
                    component.add_reference(name);
                  }
                } else if (is_contextual(component, template_scope, name)) {
                  const reference = block.renderer.reference(node3);
                  this.replace(reference);
                }
                this.skip();
              }
              if (!function_expression) {
                if (node3.type === "AssignmentExpression")
                  ;
                if (node3.type === "FunctionExpression" || node3.type === "ArrowFunctionExpression") {
                  function_expression = node3;
                  dependencies = new Set();
                  contextual_dependencies = new Set();
                }
              }
            },
            leave(node3, parent) {
              if (map.has(node3))
                scope2 = scope2.parent;
              if (node3 === function_expression) {
                const id2 = component.get_unique_name(sanitize(get_function_name(node3, owner)));
                const declaration = b`const ${id2} = ${node3}`;
                if (dependencies.size === 0 && contextual_dependencies.size === 0) {
                  component.fully_hoisted.push(declaration);
                  this.replace(id2);
                  component.add_var({
                    name: id2.name,
                    internal: true,
                    hoistable: true,
                    referenced: true
                  });
                } else if (contextual_dependencies.size === 0) {
                  component.partly_hoisted.push(declaration);
                  block.renderer.add_to_context(id2.name);
                  this.replace(block.renderer.reference(id2));
                } else {
                  const deps = Array.from(contextual_dependencies);
                  const function_expression2 = node3;
                  const has_args = function_expression2.params.length > 0;
                  function_expression2.params = [
                    ...deps.map((name) => ({ type: "Identifier", name })),
                    ...function_expression2.params
                  ];
                  const context_args = deps.map((name) => block.renderer.reference(name));
                  component.partly_hoisted.push(declaration);
                  block.renderer.add_to_context(id2.name);
                  const callee = block.renderer.reference(id2);
                  this.replace(id2);
                  const func_declaration = has_args ? b`function ${id2}(...args) {
								return ${callee}(${context_args}, ...args);
							}` : b`function ${id2}() {
								return ${callee}(${context_args});
							}`;
                  if (owner.type === "Attribute" && owner.parent.name === "slot") {
                    const dep_scopes = new Set(deps.map((name) => template_scope.get_owner(name)));
                    let node4 = owner.parent;
                    while (node4 && !dep_scopes.has(node4)) {
                      node4 = node4.parent;
                    }
                    const func_expression = func_declaration[0];
                    if (node4.type === "InlineComponent") {
                      this.replace(func_expression);
                    } else {
                      const func_id = component.get_unique_name(id2.name + "_func");
                      block.renderer.add_to_context(func_id.name, true);
                      walk(func_expression, {
                        enter(node5) {
                          if (node5.type === "Identifier" && node5.name === "#ctx") {
                            node5.name = "child_ctx";
                          }
                        }
                      });
                      template_scope.get_owner(deps[0]).contexts.push({
                        key: func_id,
                        modifier: () => func_expression,
                        default_modifier: (node5) => node5
                      });
                      this.replace(block.renderer.reference(func_id));
                    }
                  } else {
                    declarations.push(func_declaration);
                  }
                }
                function_expression = null;
                dependencies = null;
                contextual_dependencies = null;
                if (parent && parent.type === "Property") {
                  parent.method = false;
                }
              }
              if (node3.type === "AssignmentExpression" || node3.type === "UpdateExpression") {
                const assignee = node3.type === "AssignmentExpression" ? node3.left : node3.argument;
                const object_name = get_object(assignee).name;
                if (scope2.has(object_name))
                  return;
                const names2 = new Set(extract_names(assignee));
                const traced = new Set();
                names2.forEach((name) => {
                  const dependencies2 = template_scope.dependencies_for_name.get(name);
                  if (dependencies2) {
                    dependencies2.forEach((name2) => traced.add(name2));
                  } else {
                    traced.add(name);
                  }
                });
                const context = block.bindings.get(object_name);
                if (context) {
                  const { snippet, object, property } = context;
                  const replaced = replace_object(assignee, snippet);
                  if (node3.type === "AssignmentExpression") {
                    node3.left = replaced;
                  } else {
                    node3.argument = replaced;
                  }
                  contextual_dependencies.add(object.name);
                  contextual_dependencies.add(property.name);
                }
                this.replace(invalidate(block.renderer, scope2, node3, traced));
              }
            }
          });
          if (declarations.length > 0) {
            block.maintain_context = true;
            declarations.forEach((declaration) => {
              block.chunks.init.push(declaration);
            });
          }
          return this.manipulated = node2;
        }
      }
      function get_function_name(_node, parent) {
        if (parent.type === "EventHandler") {
          return `${parent.name}_handler`;
        }
        if (parent.type === "Action") {
          return `${parent.name}_function`;
        }
        return "func";
      }
      class Action extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          const object = info.name.split(".")[0];
          component.warn_if_undefined(object, info, scope2);
          this.name = info.name;
          component.add_reference(object);
          this.expression = info.expression ? new Expression(component, this, scope2, info.expression) : null;
          this.template_scope = scope2;
          this.uses_context = this.expression && this.expression.uses_context;
        }
      }
      class Tag extends Wrapper {
        constructor(renderer, block, parent, node2) {
          super(renderer, block, parent, node2);
          this.cannot_use_innerhtml();
          if (!this.is_dependencies_static()) {
            this.not_static_content();
          }
          block.add_dependencies(node2.expression.dependencies);
        }
        is_dependencies_static() {
          return this.node.expression.contextual_dependencies.size === 0 && this.node.expression.dynamic_dependencies().length === 0;
        }
        rename_this_method(block, update) {
          const dependencies = this.node.expression.dynamic_dependencies();
          let snippet = this.node.expression.manipulate(block);
          const value2 = this.node.should_cache && block.get_unique_name(`${this.var.name}_value`);
          const content = this.node.should_cache ? value2 : snippet;
          snippet = x`${snippet} + ""`;
          if (this.node.should_cache)
            block.add_variable(value2, snippet);
          if (dependencies.length > 0) {
            let condition = block.renderer.dirty(dependencies);
            if (block.has_outros) {
              condition = x`!#current || ${condition}`;
            }
            const update_cached_value = x`${value2} !== (${value2} = ${snippet})`;
            if (this.node.should_cache) {
              condition = x`${condition} && ${update_cached_value}`;
            }
            block.chunks.update.push(b`if (${condition}) ${update(content)}`);
          }
          return { init: content };
        }
      }
      class MustacheTagWrapper extends Tag {
        constructor(renderer, block, parent, node2) {
          super(renderer, block, parent, node2);
          this.var = { type: "Identifier", name: "t" };
        }
        render(block, parent_node, parent_nodes) {
          const { init: init2 } = this.rename_this_method(block, (value2) => x`@set_data(${this.var}, ${value2})`);
          block.add_element(this.var, x`@text(${init2})`, parent_nodes && x`@claim_text(${parent_nodes}, ${init2})`, parent_node);
        }
      }
      class RawMustacheTagWrapper extends Tag {
        constructor(renderer, block, parent, node2) {
          super(renderer, block, parent, node2);
          this.var = { type: "Identifier", name: "raw" };
          this.cannot_use_innerhtml();
          this.not_static_content();
        }
        render(block, parent_node, _parent_nodes) {
          const in_head = is_head(parent_node);
          const can_use_innerhtml = !in_head && parent_node && !this.prev && !this.next;
          if (can_use_innerhtml) {
            const insert = (content) => b`${parent_node}.innerHTML = ${content};`[0];
            const { init: init2 } = this.rename_this_method(block, (content) => insert(content));
            block.chunks.mount.push(insert(init2));
          } else {
            const needs_anchor = in_head || (this.next ? !this.next.is_dom_node() : !this.parent || !this.parent.is_dom_node());
            const html_tag = block.get_unique_name("html_tag");
            const html_anchor = needs_anchor && block.get_unique_name("html_anchor");
            block.add_variable(html_tag);
            const { init: init2 } = this.rename_this_method(block, (content) => x`${html_tag}.p(${content})`);
            const update_anchor = needs_anchor ? html_anchor : this.next ? this.next.var : "null";
            block.chunks.create.push(b`${html_tag} = new @HtmlTag();`);
            if (this.renderer.options.hydratable) {
              block.chunks.claim.push(b`${html_tag} = @claim_html_tag(${_parent_nodes});`);
            }
            block.chunks.hydrate.push(b`${html_tag}.a = ${update_anchor};`);
            block.chunks.mount.push(b`${html_tag}.m(${init2}, ${parent_node || "#target"}, ${parent_node ? null : "#anchor"});`);
            if (needs_anchor) {
              block.add_element(html_anchor, x`@empty()`, x`@empty()`, parent_node);
            }
            if (!parent_node || in_head) {
              block.chunks.destroy.push(b`if (detaching) ${html_tag}.d();`);
            }
          }
        }
      }
      const events = [
        {
          event_names: ["input"],
          filter: (node2, _name) => node2.name === "textarea" || node2.name === "input" && !/radio|checkbox|range|file/.test(node2.get_static_attribute_value("type"))
        },
        {
          event_names: ["input"],
          filter: (node2, name) => (name === "textContent" || name === "innerHTML") && node2.attributes.some((attribute) => attribute.name === "contenteditable")
        },
        {
          event_names: ["change"],
          filter: (node2, _name) => node2.name === "select" || node2.name === "input" && /radio|checkbox|file/.test(node2.get_static_attribute_value("type"))
        },
        {
          event_names: ["change", "input"],
          filter: (node2, _name) => node2.name === "input" && node2.get_static_attribute_value("type") === "range"
        },
        {
          event_names: ["elementresize"],
          filter: (_node, name) => dimensions.test(name)
        },
        {
          event_names: ["timeupdate"],
          filter: (node2, name) => node2.is_media_node() && (name === "currentTime" || name === "played" || name === "ended")
        },
        {
          event_names: ["durationchange"],
          filter: (node2, name) => node2.is_media_node() && name === "duration"
        },
        {
          event_names: ["play", "pause"],
          filter: (node2, name) => node2.is_media_node() && name === "paused"
        },
        {
          event_names: ["progress"],
          filter: (node2, name) => node2.is_media_node() && name === "buffered"
        },
        {
          event_names: ["loadedmetadata"],
          filter: (node2, name) => node2.is_media_node() && (name === "buffered" || name === "seekable")
        },
        {
          event_names: ["volumechange"],
          filter: (node2, name) => node2.is_media_node() && (name === "volume" || name === "muted")
        },
        {
          event_names: ["ratechange"],
          filter: (node2, name) => node2.is_media_node() && name === "playbackRate"
        },
        {
          event_names: ["seeking", "seeked"],
          filter: (node2, name) => node2.is_media_node() && name === "seeking"
        },
        {
          event_names: ["ended"],
          filter: (node2, name) => node2.is_media_node() && name === "ended"
        },
        {
          event_names: ["resize"],
          filter: (node2, name) => node2.is_media_node() && (name === "videoHeight" || name === "videoWidth")
        },
        {
          event_names: ["toggle"],
          filter: (node2, _name) => node2.name === "details"
        }
      ];
      class ElementWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          this.var = {
            type: "Identifier",
            name: node2.name.replace(/[^a-zA-Z0-9_$]/g, "_")
          };
          this.void = is_void(node2.name);
          this.class_dependencies = [];
          if (this.node.children.length) {
            this.node.lets.forEach((l) => {
              extract_names(l.value || l.name).forEach((name) => {
                renderer.add_to_context(name, true);
              });
            });
          }
          this.attributes = this.node.attributes.map((attribute) => {
            if (attribute.name === "style") {
              return new StyleAttributeWrapper(this, block, attribute);
            }
            if (attribute.type === "Spread") {
              return new SpreadAttributeWrapper(this, block, attribute);
            }
            return new AttributeWrapper(this, block, attribute);
          });
          this.bindings = this.node.bindings.map((binding) => new BindingWrapper(block, binding, this));
          this.event_handlers = this.node.handlers.map((event_handler) => new EventHandlerWrapper(event_handler, this));
          if (node2.intro || node2.outro) {
            if (node2.intro)
              block.add_intro(node2.intro.is_local);
            if (node2.outro)
              block.add_outro(node2.outro.is_local);
          }
          if (node2.animation) {
            block.add_animation();
          }
          [node2.animation, node2.outro, ...node2.actions, ...node2.classes].forEach((directive) => {
            if (directive && directive.expression) {
              block.add_dependencies(directive.expression.dependencies);
            }
          });
          node2.handlers.forEach((handler2) => {
            if (handler2.expression) {
              block.add_dependencies(handler2.expression.dependencies);
            }
          });
          if (this.parent) {
            if (node2.actions.length > 0 || node2.animation || node2.bindings.length > 0 || node2.classes.length > 0 || node2.intro || node2.outro || node2.handlers.length > 0 || this.node.name === "option" || renderer.options.dev) {
              this.parent.cannot_use_innerhtml();
              this.parent.not_static_content();
            }
          }
          this.fragment = new FragmentWrapper(renderer, block, node2.children, this, strip_whitespace, next_sibling);
        }
        render(block, parent_node, parent_nodes) {
          const { renderer } = this;
          if (this.node.name === "noscript")
            return;
          const node2 = this.var;
          const nodes = parent_nodes && block.get_unique_name(`${this.var.name}_nodes`);
          const children = x`@children(${this.node.name === "template" ? x`${node2}.content` : node2})`;
          block.add_variable(node2);
          const render_statement = this.get_render_statement(block);
          block.chunks.create.push(b`${node2} = ${render_statement};`);
          if (renderer.options.hydratable) {
            if (parent_nodes) {
              block.chunks.claim.push(b`
					${node2} = ${this.get_claim_statement(parent_nodes)};
				`);
              if (!this.void && this.node.children.length > 0) {
                block.chunks.claim.push(b`
						var ${nodes} = ${children};
					`);
              }
            } else {
              block.chunks.claim.push(b`${node2} = ${render_statement};`);
            }
          }
          if (parent_node) {
            const append = b`@append(${parent_node}, ${node2});`;
            append[0].expression.callee.loc = {
              start: this.renderer.locate(this.node.start),
              end: this.renderer.locate(this.node.end)
            };
            block.chunks.mount.push(append);
            if (is_head(parent_node)) {
              block.chunks.destroy.push(b`@detach(${node2});`);
            }
          } else {
            const insert = b`@insert(#target, ${node2}, #anchor);`;
            insert[0].expression.callee.loc = {
              start: this.renderer.locate(this.node.start),
              end: this.renderer.locate(this.node.end)
            };
            block.chunks.mount.push(insert);
            block.chunks.destroy.push(b`if (detaching) @detach(${node2});`);
          }
          const can_use_textcontent = this.can_use_textcontent();
          if (!this.node.namespace && (this.can_use_innerhtml || can_use_textcontent) && this.fragment.nodes.length > 0) {
            if (this.fragment.nodes.length === 1 && this.fragment.nodes[0].node.type === "Text") {
              block.chunks.create.push(b`${node2}.textContent = ${string_literal(this.fragment.nodes[0].data)};`);
            } else {
              const state = {
                quasi: {
                  type: "TemplateElement",
                  value: { raw: "" }
                }
              };
              const literal2 = {
                type: "TemplateLiteral",
                expressions: [],
                quasis: []
              };
              const can_use_raw_text = !this.can_use_innerhtml && can_use_textcontent;
              to_html(this.fragment.nodes, block, literal2, state, can_use_raw_text);
              literal2.quasis.push(state.quasi);
              block.chunks.create.push(b`${node2}.${this.can_use_innerhtml ? "innerHTML" : "textContent"} = ${literal2};`);
            }
          } else {
            this.fragment.nodes.forEach((child) => {
              child.render(block, this.node.name === "template" ? x`${node2}.content` : node2, nodes);
            });
          }
          const event_handler_or_binding_uses_context = this.bindings.some((binding) => binding.handler.uses_context) || this.node.handlers.some((handler2) => handler2.uses_context) || this.node.actions.some((action) => action.uses_context);
          if (event_handler_or_binding_uses_context) {
            block.maintain_context = true;
          }
          this.add_attributes(block);
          this.add_directives_in_order(block);
          this.add_transitions(block);
          this.add_animation(block);
          this.add_classes(block);
          this.add_manual_style_scoping(block);
          if (nodes && this.renderer.options.hydratable && !this.void) {
            block.chunks.claim.push(b`${this.node.children.length > 0 ? nodes : children}.forEach(@detach);`);
          }
          if (renderer.options.dev) {
            const loc = renderer.locate(this.node.start);
            block.chunks.hydrate.push(b`@add_location(${this.var}, ${renderer.file_var}, ${loc.line - 1}, ${loc.column}, ${this.node.start});`);
          }
        }
        can_use_textcontent() {
          return this.is_static_content && this.fragment.nodes.every((node2) => node2.node.type === "Text" || node2.node.type === "MustacheTag");
        }
        get_render_statement(block) {
          const { name, namespace } = this.node;
          if (namespace === namespaces.svg) {
            return x`@svg_element("${name}")`;
          }
          if (namespace) {
            return x`@_document.createElementNS("${namespace}", "${name}")`;
          }
          const is = this.attributes.find((attr) => attr.node.name === "is");
          if (is) {
            return x`@element_is("${name}", ${is.render_chunks(block).reduce((lhs, rhs) => x`${lhs} + ${rhs}`)})`;
          }
          return x`@element("${name}")`;
        }
        get_claim_statement(nodes) {
          const attributes = this.attributes.filter((attr) => !(attr instanceof SpreadAttributeWrapper) && !attr.property_name).map((attr) => p`${attr.name}: true`);
          const name = this.node.namespace ? this.node.name : this.node.name.toUpperCase();
          const svg2 = this.node.namespace === namespaces.svg ? 1 : null;
          return x`@claim_element(${nodes}, "${name}", { ${attributes} }, ${svg2})`;
        }
        add_directives_in_order(block) {
          const binding_groups = events.map((event) => ({
            events: event.event_names,
            bindings: this.bindings.filter((binding) => binding.node.name !== "this").filter((binding) => event.filter(this.node, binding.node.name))
          })).filter((group) => group.bindings.length);
          const this_binding = this.bindings.find((b2) => b2.node.name === "this");
          function getOrder(item) {
            if (item instanceof EventHandlerWrapper) {
              return item.node.start;
            } else if (item instanceof BindingWrapper) {
              return item.node.start;
            } else if (item instanceof Action) {
              return item.start;
            } else {
              return item.bindings[0].node.start;
            }
          }
          [
            ...binding_groups,
            ...this.event_handlers,
            this_binding,
            ...this.node.actions
          ].filter(Boolean).sort((a, b2) => getOrder(a) - getOrder(b2)).forEach((item) => {
            if (item instanceof EventHandlerWrapper) {
              add_event_handler(block, this.var, item);
            } else if (item instanceof BindingWrapper) {
              this.add_this_binding(block, item);
            } else if (item instanceof Action) {
              add_action(block, this.var, item);
            } else {
              this.add_bindings(block, item);
            }
          });
        }
        add_bindings(block, binding_group) {
          const { renderer } = this;
          if (binding_group.bindings.length === 0)
            return;
          renderer.component.has_reactive_assignments = true;
          const lock = binding_group.bindings.some((binding) => binding.needs_lock) ? block.get_unique_name(`${this.var.name}_updating`) : null;
          if (lock)
            block.add_variable(lock, x`false`);
          const handler2 = renderer.component.get_unique_name(`${this.var.name}_${binding_group.events.join("_")}_handler`);
          renderer.add_to_context(handler2.name);
          const needs_lock = binding_group.bindings.some((binding) => binding.needs_lock);
          const dependencies = new Set();
          const contextual_dependencies = new Set();
          binding_group.bindings.forEach((binding) => {
            add_to_set(dependencies, binding.get_dependencies());
            add_to_set(contextual_dependencies, binding.handler.contextual_dependencies);
            binding.render(block, lock);
          });
          let animation_frame;
          if (binding_group.events[0] === "timeupdate") {
            animation_frame = block.get_unique_name(`${this.var.name}_animationframe`);
            block.add_variable(animation_frame);
          }
          const has_local_function = contextual_dependencies.size > 0 || needs_lock || animation_frame;
          let callee = renderer.reference(handler2);
          if (has_local_function) {
            const args = Array.from(contextual_dependencies).map((name) => renderer.reference(name));
            if (animation_frame) {
              block.chunks.init.push(b`
					function ${handler2}() {
						@_cancelAnimationFrame(${animation_frame});
						if (!${this.var}.paused) {
							${animation_frame} = @raf(${handler2});
							${needs_lock && b`${lock} = true;`}
						}
						${callee}.call(${this.var}, ${args});
					}
				`);
            } else {
              block.chunks.init.push(b`
					function ${handler2}() {
						${needs_lock && b`${lock} = true;`}
						${callee}.call(${this.var}, ${args});
					}
				`);
            }
            callee = handler2;
          }
          const params = Array.from(contextual_dependencies).map((name) => ({
            type: "Identifier",
            name
          }));
          this.renderer.component.partly_hoisted.push(b`
			function ${handler2}(${params}) {
				${binding_group.bindings.map((b2) => b2.handler.mutation)}
				${Array.from(dependencies).filter((dep) => dep[0] !== "$").filter((dep) => !contextual_dependencies.has(dep)).map((dep) => b`${this.renderer.invalidate(dep)};`)}
			}
		`);
          binding_group.events.forEach((name) => {
            if (name === "elementresize") {
              const resize_listener = block.get_unique_name(`${this.var.name}_resize_listener`);
              block.add_variable(resize_listener);
              block.chunks.mount.push(b`${resize_listener} = @add_resize_listener(${this.var}, ${callee}.bind(${this.var}));`);
              block.chunks.destroy.push(b`${resize_listener}();`);
            } else {
              block.event_listeners.push(x`@listen(${this.var}, "${name}", ${callee})`);
            }
          });
          const some_initial_state_is_undefined = binding_group.bindings.map((binding) => x`${binding.snippet} === void 0`).reduce((lhs, rhs) => x`${lhs} || ${rhs}`);
          const should_initialise = this.node.name === "select" || binding_group.bindings.find((binding) => {
            return binding.node.name === "indeterminate" || binding.node.name === "textContent" || binding.node.name === "innerHTML" || binding.is_readonly_media_attribute();
          });
          if (should_initialise) {
            const callback = has_local_function ? handler2 : x`() => ${callee}.call(${this.var})`;
            block.chunks.hydrate.push(b`if (${some_initial_state_is_undefined}) @add_render_callback(${callback});`);
          }
          if (binding_group.events[0] === "elementresize") {
            block.chunks.hydrate.push(b`@add_render_callback(() => ${callee}.call(${this.var}));`);
          }
          if (lock) {
            block.chunks.update.push(b`${lock} = false;`);
          }
        }
        add_this_binding(block, this_binding) {
          const { renderer } = this;
          renderer.component.has_reactive_assignments = true;
          const binding_callback = bind_this(renderer.component, block, this_binding, this.var);
          block.chunks.mount.push(binding_callback);
        }
        add_attributes(block) {
          this.attributes.forEach((attribute) => {
            if (attribute.node.name === "class") {
              const dependencies = attribute.node.get_dependencies();
              this.class_dependencies.push(...dependencies);
            }
          });
          if (this.node.attributes.some((attr) => attr.is_spread)) {
            this.add_spread_attributes(block);
            return;
          }
          this.attributes.forEach((attribute) => {
            attribute.render(block);
          });
        }
        add_spread_attributes(block) {
          const levels = block.get_unique_name(`${this.var.name}_levels`);
          const data2 = block.get_unique_name(`${this.var.name}_data`);
          const initial_props = [];
          const updates = [];
          this.attributes.forEach((attr) => {
            const dependencies = attr.node.get_dependencies();
            const condition = dependencies.length > 0 ? block.renderer.dirty(dependencies) : null;
            if (attr instanceof SpreadAttributeWrapper) {
              const snippet = attr.node.expression.manipulate(block);
              initial_props.push(snippet);
              updates.push(condition ? x`${condition} && ${snippet}` : snippet);
            } else {
              const name = attr.property_name || attr.name;
              initial_props.push(x`{ ${name}: ${attr.get_init(block, attr.get_value(block))} }`);
              const snippet = x`{ ${name}: ${attr.should_cache ? attr.last : attr.get_value(block)} }`;
              updates.push(condition ? x`${attr.get_dom_update_conditions(block, condition)} && ${snippet}` : snippet);
            }
          });
          block.chunks.init.push(b`
			let ${levels} = [${initial_props}];

			let ${data2} = {};
			for (let #i = 0; #i < ${levels}.length; #i += 1) {
				${data2} = @assign(${data2}, ${levels}[#i]);
			}
		`);
          const fn = this.node.namespace === namespaces.svg ? x`@set_svg_attributes` : x`@set_attributes`;
          block.chunks.hydrate.push(b`${fn}(${this.var}, ${data2});`);
          block.chunks.update.push(b`
			${fn}(${this.var}, ${data2} = @get_spread_update(${levels}, [
				${updates}
			]));
		`);
          if (this.node.name === "select") {
            const dependencies = new Set();
            for (const attr of this.attributes) {
              for (const dep of attr.node.dependencies) {
                dependencies.add(dep);
              }
            }
            block.chunks.mount.push(b`
				(${data2}.multiple ? @select_options : @select_option)(${this.var}, ${data2}.value);
			`);
            block.chunks.update.push(b`
				if (${block.renderer.dirty(Array.from(dependencies))}) (${data2}.multiple ? @select_options : @select_option)(${this.var}, ${data2}.value);;
			`);
          } else if (this.node.name === "input" && this.attributes.find((attr) => attr.node.name === "value")) {
            const type = this.node.get_static_attribute_value("type");
            if (type === null || type === "" || type === "text" || type === "email" || type === "password") {
              block.chunks.mount.push(b`
					${this.var}.value = ${data2}.value;
				`);
              block.chunks.update.push(b`
					if ('value' in ${data2}) {
						${this.var}.value = ${data2}.value;
					}
				`);
            }
          }
          if (["button", "input", "keygen", "select", "textarea"].includes(this.node.name)) {
            block.chunks.mount.push(b`
				if (${this.var}.autofocus) ${this.var}.focus();
			`);
          }
        }
        add_transitions(block) {
          const { intro, outro } = this.node;
          if (!intro && !outro)
            return;
          if (intro === outro) {
            const name = block.get_unique_name(`${this.var.name}_transition`);
            const snippet = intro.expression ? intro.expression.manipulate(block) : x`{}`;
            block.add_variable(name);
            const fn = this.renderer.reference(intro.name);
            const intro_block = b`
				@add_render_callback(() => {
					if (!${name}) ${name} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, true);
					${name}.run(1);
				});
			`;
            const outro_block = b`
				if (!${name}) ${name} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, false);
				${name}.run(0);
			`;
            if (intro.is_local) {
              block.chunks.intro.push(b`
					if (#local) {
						${intro_block}
					}
				`);
              block.chunks.outro.push(b`
					if (#local) {
						${outro_block}
					}
				`);
            } else {
              block.chunks.intro.push(intro_block);
              block.chunks.outro.push(outro_block);
            }
            block.chunks.destroy.push(b`if (detaching && ${name}) ${name}.end();`);
          } else {
            const intro_name = intro && block.get_unique_name(`${this.var.name}_intro`);
            const outro_name = outro && block.get_unique_name(`${this.var.name}_outro`);
            if (intro) {
              block.add_variable(intro_name);
              const snippet = intro.expression ? intro.expression.manipulate(block) : x`{}`;
              const fn = this.renderer.reference(intro.name);
              let intro_block;
              if (outro) {
                intro_block = b`
						@add_render_callback(() => {
							if (${outro_name}) ${outro_name}.end(1);
							${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
							${intro_name}.start();
						});
					`;
                block.chunks.outro.push(b`if (${intro_name}) ${intro_name}.invalidate();`);
              } else {
                intro_block = b`
						if (!${intro_name}) {
							@add_render_callback(() => {
								${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
								${intro_name}.start();
							});
						}
					`;
              }
              if (intro.is_local) {
                intro_block = b`
						if (#local) {
							${intro_block}
						}
					`;
              }
              block.chunks.intro.push(intro_block);
            }
            if (outro) {
              block.add_variable(outro_name);
              const snippet = outro.expression ? outro.expression.manipulate(block) : x`{}`;
              const fn = this.renderer.reference(outro.name);
              if (!intro) {
                block.chunks.intro.push(b`
						if (${outro_name}) ${outro_name}.end(1);
					`);
              }
              let outro_block = b`
					${outro_name} = @create_out_transition(${this.var}, ${fn}, ${snippet});
				`;
              if (outro.is_local) {
                outro_block = b`
						if (#local) {
							${outro_block}
						}
					`;
              }
              block.chunks.outro.push(outro_block);
              block.chunks.destroy.push(b`if (detaching && ${outro_name}) ${outro_name}.end();`);
            }
          }
          if (intro && intro.expression && intro.expression.dependencies.size || outro && outro.expression && outro.expression.dependencies.size) {
            block.maintain_context = true;
          }
        }
        add_animation(block) {
          if (!this.node.animation)
            return;
          const { outro } = this.node;
          const rect = block.get_unique_name("rect");
          const stop_animation = block.get_unique_name("stop_animation");
          block.add_variable(rect);
          block.add_variable(stop_animation, x`@noop`);
          block.chunks.measure.push(b`
			${rect} = ${this.var}.getBoundingClientRect();
		`);
          block.chunks.fix.push(b`
			@fix_position(${this.var});
			${stop_animation}();
			${outro && b`@add_transform(${this.var}, ${rect});`}
		`);
          let params;
          if (this.node.animation.expression) {
            params = this.node.animation.expression.manipulate(block);
            if (this.node.animation.expression.dynamic_dependencies().length) {
              const params_var = block.get_unique_name("params");
              block.add_variable(params_var);
              block.chunks.measure.push(b`${params_var} = ${params};`);
              params = params_var;
            }
          } else {
            params = x`{}`;
          }
          const name = this.renderer.reference(this.node.animation.name);
          block.chunks.animate.push(b`
			${stop_animation}();
			${stop_animation} = @create_animation(${this.var}, ${rect}, ${name}, ${params});
		`);
        }
        add_classes(block) {
          const has_spread = this.node.attributes.some((attr) => attr.is_spread);
          this.node.classes.forEach((class_directive) => {
            const { expression: expression2, name } = class_directive;
            let snippet;
            let dependencies;
            if (expression2) {
              snippet = expression2.manipulate(block);
              dependencies = expression2.dependencies;
            } else {
              snippet = name;
              dependencies = new Set([name]);
            }
            const updater = b`@toggle_class(${this.var}, "${name}", ${snippet});`;
            block.chunks.hydrate.push(updater);
            if (has_spread) {
              block.chunks.update.push(updater);
            } else if (dependencies && dependencies.size > 0 || this.class_dependencies.length) {
              const all_dependencies = this.class_dependencies.concat(...dependencies);
              const condition = block.renderer.dirty(all_dependencies);
              const any_dynamic_dependencies = all_dependencies.some((dep) => {
                const variable = this.renderer.component.var_lookup.get(dep);
                return !variable || is_dynamic$1(variable);
              });
              if (any_dynamic_dependencies) {
                block.chunks.update.push(b`
						if (${condition}) {
							${updater}
						}
					`);
              }
            }
          });
        }
        add_manual_style_scoping(block) {
          if (this.node.needs_manual_style_scoping) {
            const updater = b`@toggle_class(${this.var}, "${this.node.component.stylesheet.id}", true);`;
            block.chunks.hydrate.push(updater);
            block.chunks.update.push(updater);
          }
        }
      }
      function to_html(wrappers2, block, literal2, state, can_use_raw_text) {
        wrappers2.forEach((wrapper) => {
          if (wrapper instanceof TextWrapper) {
            if (wrapper.use_space())
              state.quasi.value.raw += " ";
            const parent = wrapper.node.parent;
            const raw = parent && (parent.name === "script" || parent.name === "style" || can_use_raw_text);
            state.quasi.value.raw += (raw ? wrapper.data : escape_html(wrapper.data)).replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
          } else if (wrapper instanceof MustacheTagWrapper || wrapper instanceof RawMustacheTagWrapper) {
            literal2.quasis.push(state.quasi);
            literal2.expressions.push(wrapper.node.expression.manipulate(block));
            state.quasi = {
              type: "TemplateElement",
              value: { raw: "" }
            };
          } else if (wrapper.node.name === "noscript")
            ;
          else {
            state.quasi.value.raw += `<${wrapper.node.name}`;
            wrapper.attributes.forEach((attr) => {
              state.quasi.value.raw += ` ${fix_attribute_casing(attr.node.name)}="`;
              attr.node.chunks.forEach((chunk) => {
                if (chunk.type === "Text") {
                  state.quasi.value.raw += escape_html(chunk.data);
                } else {
                  literal2.quasis.push(state.quasi);
                  literal2.expressions.push(chunk.manipulate(block));
                  state.quasi = {
                    type: "TemplateElement",
                    value: { raw: "" }
                  };
                }
              });
              state.quasi.value.raw += '"';
            });
            if (!wrapper.void) {
              state.quasi.value.raw += ">";
              to_html(wrapper.fragment.nodes, block, literal2, state);
              state.quasi.value.raw += `</${wrapper.node.name}>`;
            } else {
              state.quasi.value.raw += "/>";
            }
          }
        });
      }
      class HeadWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          this.can_use_innerhtml = false;
          this.fragment = new FragmentWrapper(renderer, block, node2.children, this, strip_whitespace, next_sibling);
        }
        render(block, _parent_node, _parent_nodes) {
          let nodes;
          if (this.renderer.options.hydratable && this.fragment.nodes.length) {
            nodes = block.get_unique_name("head_nodes");
            block.chunks.claim.push(b`const ${nodes} = @query_selector_all('[data-svelte="${this.node.id}"]', @_document.head);`);
          }
          this.fragment.render(block, x`@_document.head`, nodes);
          if (nodes && this.renderer.options.hydratable) {
            block.chunks.claim.push(b`${nodes}.forEach(@detach);`);
          }
        }
      }
      function is_else_if(node2) {
        return node2 && node2.children.length === 1 && node2.children[0].type === "IfBlock";
      }
      class IfBlockBranch extends Wrapper {
        constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          this.var = null;
          const { expression: expression2 } = node2;
          const is_else = !expression2;
          if (expression2) {
            this.dependencies = expression2.dynamic_dependencies();
            let should_cache2 = false;
            walk(expression2.node, {
              enter(node3) {
                if (node3.type === "CallExpression" || node3.type === "NewExpression") {
                  should_cache2 = true;
                }
              }
            });
            if (should_cache2) {
              this.condition = block.get_unique_name("show_if");
              this.snippet = expression2.manipulate(block);
            } else {
              this.condition = expression2.manipulate(block);
            }
          }
          this.block = block.child({
            comment: create_debugging_comment(node2, parent.renderer.component),
            name: parent.renderer.component.get_unique_name(is_else ? "create_else_block" : "create_if_block"),
            type: node2.expression ? "if" : "else"
          });
          this.fragment = new FragmentWrapper(renderer, this.block, node2.children, parent, strip_whitespace, next_sibling);
          this.is_dynamic = this.block.dependencies.size > 0;
        }
      }
      class IfBlockWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          this.needs_update = false;
          this.var = { type: "Identifier", name: "if_block" };
          this.cannot_use_innerhtml();
          this.not_static_content();
          this.branches = [];
          const blocks = [];
          let is_dynamic2 = false;
          let has_intros = false;
          let has_outros = false;
          const create_branches = (node3) => {
            const branch = new IfBlockBranch(renderer, block, this, node3, strip_whitespace, next_sibling);
            this.branches.push(branch);
            blocks.push(branch.block);
            block.add_dependencies(node3.expression.dependencies);
            if (branch.block.dependencies.size > 0) {
              is_dynamic2 = true;
              block.add_dependencies(branch.block.dependencies);
            }
            if (branch.dependencies && branch.dependencies.length > 0) {
              this.needs_update = true;
            }
            if (branch.block.has_intros)
              has_intros = true;
            if (branch.block.has_outros)
              has_outros = true;
            if (is_else_if(node3.else)) {
              create_branches(node3.else.children[0]);
            } else if (node3.else) {
              const branch2 = new IfBlockBranch(renderer, block, this, node3.else, strip_whitespace, next_sibling);
              this.branches.push(branch2);
              blocks.push(branch2.block);
              if (branch2.block.dependencies.size > 0) {
                is_dynamic2 = true;
                block.add_dependencies(branch2.block.dependencies);
              }
              if (branch2.block.has_intros)
                has_intros = true;
              if (branch2.block.has_outros)
                has_outros = true;
            }
          };
          create_branches(this.node);
          blocks.forEach((block2) => {
            block2.has_update_method = is_dynamic2;
            block2.has_intro_method = has_intros;
            block2.has_outro_method = has_outros;
          });
          renderer.blocks.push(...blocks);
        }
        render(block, parent_node, parent_nodes) {
          const name = this.var;
          const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
          const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || "null";
          const has_else = !this.branches[this.branches.length - 1].condition;
          const if_exists_condition = has_else ? null : name;
          const dynamic = this.branches[0].block.has_update_method;
          const has_intros = this.branches[0].block.has_intro_method;
          const has_outros = this.branches[0].block.has_outro_method;
          const has_transitions = has_intros || has_outros;
          const vars = { name, anchor, if_exists_condition, has_else, has_transitions };
          const detaching = parent_node && !is_head(parent_node) ? null : "detaching";
          if (this.node.else) {
            this.branches.forEach((branch) => {
              if (branch.snippet)
                block.add_variable(branch.condition);
            });
            if (has_outros) {
              this.render_compound_with_outros(block, parent_node, parent_nodes, dynamic, vars, detaching);
              block.chunks.outro.push(b`@transition_out(${name});`);
            } else {
              this.render_compound(block, parent_node, parent_nodes, dynamic, vars, detaching);
            }
          } else {
            this.render_simple(block, parent_node, parent_nodes, dynamic, vars, detaching);
            if (has_outros) {
              block.chunks.outro.push(b`@transition_out(${name});`);
            }
          }
          if (if_exists_condition) {
            block.chunks.create.push(b`if (${if_exists_condition}) ${name}.c();`);
          } else {
            block.chunks.create.push(b`${name}.c();`);
          }
          if (parent_nodes && this.renderer.options.hydratable) {
            if (if_exists_condition) {
              block.chunks.claim.push(b`if (${if_exists_condition}) ${name}.l(${parent_nodes});`);
            } else {
              block.chunks.claim.push(b`${name}.l(${parent_nodes});`);
            }
          }
          if (has_intros || has_outros) {
            block.chunks.intro.push(b`@transition_in(${name});`);
          }
          if (needs_anchor) {
            block.add_element(anchor, x`@empty()`, parent_nodes && x`@empty()`, parent_node);
          }
          this.branches.forEach((branch) => {
            branch.fragment.render(branch.block, null, x`#nodes`);
          });
        }
        render_compound(block, parent_node, _parent_nodes, dynamic, { name, anchor, has_else, if_exists_condition, has_transitions }, detaching) {
          const select_block_type = this.renderer.component.get_unique_name("select_block_type");
          const current_block_type = block.get_unique_name("current_block_type");
          const get_block = has_else ? x`${current_block_type}(#ctx)` : x`${current_block_type} && ${current_block_type}(#ctx)`;
          if (this.needs_update) {
            block.chunks.init.push(b`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(({ dependencies, condition, snippet, block: block2 }) => condition ? b`
					${snippet && (dependencies.length > 0 ? b`if (${condition} == null || ${block2.renderer.dirty(dependencies)}) ${condition} = !!${snippet}` : b`if (${condition} == null) ${condition} = !!${snippet}`)}
					if (${condition}) return ${block2.name};` : b`return ${block2.name};`)}
				}
			`);
          } else {
            block.chunks.init.push(b`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(({ condition, snippet, block: block2 }) => condition ? b`if (${snippet || condition}) return ${block2.name};` : b`return ${block2.name};`)}
				}
			`);
          }
          block.chunks.init.push(b`
			let ${current_block_type} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
			let ${name} = ${get_block};
		`);
          const initial_mount_node = parent_node || "#target";
          const anchor_node = parent_node ? "null" : "#anchor";
          if (if_exists_condition) {
            block.chunks.mount.push(b`if (${if_exists_condition}) ${name}.m(${initial_mount_node}, ${anchor_node});`);
          } else {
            block.chunks.mount.push(b`${name}.m(${initial_mount_node}, ${anchor_node});`);
          }
          if (this.needs_update) {
            const update_mount_node = this.get_update_mount_node(anchor);
            const change_block = b`
				${if_exists_condition ? b`if (${if_exists_condition}) ${name}.d(1)` : b`${name}.d(1)`};
				${name} = ${get_block};
				if (${name}) {
					${name}.c();
					${has_transitions && b`@transition_in(${name}, 1);`}
					${name}.m(${update_mount_node}, ${anchor});
				}
			`;
            if (dynamic) {
              block.chunks.update.push(b`
					if (${current_block_type} === (${current_block_type} = ${select_block_type}(#ctx, #dirty)) && ${name}) {
						${name}.p(#ctx, #dirty);
					} else {
						${change_block}
					}
				`);
            } else {
              block.chunks.update.push(b`
					if (${current_block_type} !== (${current_block_type} = ${select_block_type}(#ctx, #dirty))) {
						${change_block}
					}
				`);
            }
          } else if (dynamic) {
            if (if_exists_condition) {
              block.chunks.update.push(b`if (${if_exists_condition}) ${name}.p(#ctx, #dirty);`);
            } else {
              block.chunks.update.push(b`${name}.p(#ctx, #dirty);`);
            }
          }
          if (if_exists_condition) {
            block.chunks.destroy.push(b`
				if (${if_exists_condition}) {
					${name}.d(${detaching});
				}
			`);
          } else {
            block.chunks.destroy.push(b`
				${name}.d(${detaching});
			`);
          }
        }
        render_compound_with_outros(block, parent_node, _parent_nodes, dynamic, { name, anchor, has_else, has_transitions, if_exists_condition }, detaching) {
          const select_block_type = this.renderer.component.get_unique_name("select_block_type");
          const current_block_type_index = block.get_unique_name("current_block_type_index");
          const previous_block_index = block.get_unique_name("previous_block_index");
          const if_block_creators = block.get_unique_name("if_block_creators");
          const if_blocks = block.get_unique_name("if_blocks");
          const if_current_block_type_index = has_else ? (nodes) => nodes : (nodes) => b`if (~${current_block_type_index}) { ${nodes} }`;
          block.add_variable(current_block_type_index);
          block.add_variable(name);
          block.chunks.init.push(b`
			const ${if_block_creators} = [
				${this.branches.map((branch) => branch.block.name)}
			];

			const ${if_blocks} = [];

			${this.needs_update ? b`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(({ dependencies, condition, snippet }, i2) => condition ? b`
						${snippet && (dependencies.length > 0 ? b`if (${block.renderer.dirty(dependencies)}) ${condition} = !!${snippet}` : b`if (${condition} == null) ${condition} = !!${snippet}`)}
						if (${condition}) return ${i2};` : b`return ${i2};`)}
						${!has_else && b`return -1;`}
					}
				` : b`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(({ condition, snippet }, i2) => condition ? b`if (${snippet || condition}) return ${i2};` : b`return ${i2};`)}
						${!has_else && b`return -1;`}
					}
				`}
		`);
          if (has_else) {
            block.chunks.init.push(b`
				${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
				${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](#ctx);
			`);
          } else {
            block.chunks.init.push(b`
				if (~(${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()}))) {
					${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](#ctx);
				}
			`);
          }
          const initial_mount_node = parent_node || "#target";
          const anchor_node = parent_node ? "null" : "#anchor";
          block.chunks.mount.push(if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].m(${initial_mount_node}, ${anchor_node});`));
          if (this.needs_update) {
            const update_mount_node = this.get_update_mount_node(anchor);
            const destroy_old_block = b`
				@group_outros();
				@transition_out(${if_blocks}[${previous_block_index}], 1, 1, () => {
					${if_blocks}[${previous_block_index}] = null;
				});
				@check_outros();
			`;
            const create_new_block = b`
				${name} = ${if_blocks}[${current_block_type_index}];
				if (!${name}) {
					${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](#ctx);
					${name}.c();
				} else {
					${dynamic && b`${name}.p(#ctx, #dirty);`}
				}
				${has_transitions && b`@transition_in(${name}, 1);`}
				${name}.m(${update_mount_node}, ${anchor});
			`;
            const change_block = has_else ? b`
					${destroy_old_block}

					${create_new_block}
				` : b`
					if (${name}) {
						${destroy_old_block}
					}

					if (~${current_block_type_index}) {
						${create_new_block}
					} else {
						${name} = null;
					}
				`;
            block.chunks.update.push(b`
				let ${previous_block_index} = ${current_block_type_index};
				${current_block_type_index} = ${select_block_type}(#ctx, #dirty);
			`);
            if (dynamic) {
              block.chunks.update.push(b`
					if (${current_block_type_index} === ${previous_block_index}) {
						${if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].p(#ctx, #dirty);`)}
					} else {
						${change_block}
					}
				`);
            } else {
              block.chunks.update.push(b`
					if (${current_block_type_index} !== ${previous_block_index}) {
						${change_block}
					}
				`);
            }
          } else if (dynamic) {
            if (if_exists_condition) {
              block.chunks.update.push(b`if (${if_exists_condition}) ${name}.p(#ctx, #dirty);`);
            } else {
              block.chunks.update.push(b`${name}.p(#ctx, #dirty);`);
            }
          }
          block.chunks.destroy.push(if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].d(${detaching});`));
        }
        render_simple(block, parent_node, _parent_nodes, dynamic, { name, anchor, if_exists_condition, has_transitions }, detaching) {
          const branch = this.branches[0];
          if (branch.snippet)
            block.add_variable(branch.condition, branch.snippet);
          block.chunks.init.push(b`
			let ${name} = ${branch.condition} && ${branch.block.name}(#ctx);
		`);
          const initial_mount_node = parent_node || "#target";
          const anchor_node = parent_node ? "null" : "#anchor";
          block.chunks.mount.push(b`if (${name}) ${name}.m(${initial_mount_node}, ${anchor_node});`);
          if (branch.dependencies.length > 0) {
            const update_mount_node = this.get_update_mount_node(anchor);
            const enter = b`
				if (${name}) {
					${dynamic && b`${name}.p(#ctx, #dirty);`}
					${has_transitions && b`if (${block.renderer.dirty(branch.dependencies)}) {
							@transition_in(${name}, 1);
						}`}
				} else {
					${name} = ${branch.block.name}(#ctx);
					${name}.c();
					${has_transitions && b`@transition_in(${name}, 1);`}
					${name}.m(${update_mount_node}, ${anchor});
				}
			`;
            if (branch.snippet) {
              block.chunks.update.push(b`if (${block.renderer.dirty(branch.dependencies)}) ${branch.condition} = ${branch.snippet}`);
            }
            if (branch.block.has_outro_method) {
              block.chunks.update.push(b`
					if (${branch.condition}) {
						${enter}
					} else if (${name}) {
						@group_outros();
						@transition_out(${name}, 1, 1, () => {
							${name} = null;
						});
						@check_outros();
					}
				`);
            } else {
              block.chunks.update.push(b`
					if (${branch.condition}) {
						${enter}
					} else if (${name}) {
						${name}.d(1);
						${name} = null;
					}
				`);
            }
          } else if (dynamic) {
            block.chunks.update.push(b`
				if (${branch.condition}) ${name}.p(#ctx, #dirty);
			`);
          }
          if (if_exists_condition) {
            block.chunks.destroy.push(b`
				if (${if_exists_condition}) ${name}.d(${detaching});
			`);
          } else {
            block.chunks.destroy.push(b`
				${name}.d(${detaching});
			`);
          }
        }
      }
      class KeyBlockWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          this.var = { type: "Identifier", name: "key_block" };
          this.cannot_use_innerhtml();
          this.not_static_content();
          this.dependencies = node2.expression.dynamic_dependencies();
          if (this.dependencies.length) {
            block = block.child({
              comment: create_debugging_comment(node2, renderer.component),
              name: renderer.component.get_unique_name("create_key_block"),
              type: "key"
            });
            renderer.blocks.push(block);
          }
          this.block = block;
          this.fragment = new FragmentWrapper(renderer, this.block, node2.children, this, strip_whitespace, next_sibling);
        }
        render(block, parent_node, parent_nodes) {
          if (this.dependencies.length === 0) {
            this.render_static_key(block, parent_node, parent_nodes);
          } else {
            this.render_dynamic_key(block, parent_node, parent_nodes);
          }
        }
        render_static_key(_block, parent_node, parent_nodes) {
          this.fragment.render(this.block, parent_node, parent_nodes);
        }
        render_dynamic_key(block, parent_node, parent_nodes) {
          this.fragment.render(this.block, null, x`#nodes`);
          const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
          const dynamic = this.block.has_update_method;
          const previous_key = block.get_unique_name("previous_key");
          const snippet = this.node.expression.manipulate(block);
          block.add_variable(previous_key, snippet);
          const not_equal = this.renderer.component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
          const condition = x`${this.renderer.dirty(this.dependencies)} && ${not_equal}(${previous_key}, ${previous_key} = ${snippet})`;
          block.chunks.init.push(b`
			let ${this.var} = ${this.block.name}(#ctx);
		`);
          block.chunks.create.push(b`${this.var}.c();`);
          if (this.renderer.options.hydratable) {
            block.chunks.claim.push(b`${this.var}.l(${parent_nodes});`);
          }
          block.chunks.mount.push(b`${this.var}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});`);
          const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
          const body = b`
			${has_transitions ? b`
						@group_outros();
						@transition_out(${this.var}, 1, 1, @noop);
						@check_outros();
					` : b`${this.var}.d(1);`}
			${this.var} = ${this.block.name}(#ctx);
			${this.var}.c();
			${has_transitions && b`@transition_in(${this.var})`}
			${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
		`;
          if (dynamic) {
            block.chunks.update.push(b`
				if (${condition}) {
					${body}
				} else {
					${this.var}.p(#ctx, #dirty);
				}
			`);
          } else {
            block.chunks.update.push(b`
				if (${condition}) {
					${body}
				}
			`);
          }
          if (has_transitions) {
            block.chunks.intro.push(b`@transition_in(${this.var})`);
            block.chunks.outro.push(b`@transition_out(${this.var})`);
          }
          block.chunks.destroy.push(b`${this.var}.d(detaching)`);
        }
      }
      function get_slot_definition(block, scope2, lets) {
        if (lets.length === 0)
          return { block, scope: scope2 };
        const context_input = {
          type: "ObjectPattern",
          properties: lets.map((l) => ({
            type: "Property",
            kind: "init",
            key: l.name,
            value: l.value || l.name
          }))
        };
        const properties2 = [];
        const value_map = new Map();
        lets.forEach((l) => {
          let value2;
          if (l.names.length > 1) {
            const unique_name = block.get_unique_name(l.names.join("_")).name;
            value_map.set(l.value, unique_name);
            value2 = { type: "Identifier", name: unique_name };
          } else {
            value2 = l.value || l.name;
          }
          properties2.push({
            type: "Property",
            kind: "init",
            key: l.name,
            value: value2
          });
        });
        const changes_input = {
          type: "ObjectPattern",
          properties: properties2
        };
        const names2 = new Set();
        const names_lookup = new Map();
        lets.forEach((l) => {
          l.names.forEach((name) => {
            names2.add(name);
            if (value_map.has(l.value)) {
              names_lookup.set(name, value_map.get(l.value));
            }
          });
        });
        const context = {
          type: "ObjectExpression",
          properties: Array.from(names2).map((name) => p`${block.renderer.context_lookup.get(name).index}: ${name}`)
        };
        const { context_lookup } = block.renderer;
        const changes = {
          type: "ParenthesizedExpression",
          get expression() {
            if (block.renderer.context_overflow) {
              const grouped = [];
              Array.from(names2).forEach((name) => {
                const i2 = context_lookup.get(name).index.value;
                const g = Math.floor(i2 / 31);
                const lookup_name = names_lookup.has(name) ? names_lookup.get(name) : name;
                if (!grouped[g])
                  grouped[g] = [];
                grouped[g].push({ name: lookup_name, n: i2 % 31 });
              });
              const elements = [];
              for (let g = 0; g < grouped.length; g += 1) {
                elements[g] = grouped[g] ? grouped[g].map(({ name, n: n2 }) => x`${name} ? ${1 << n2} : 0`).reduce((lhs, rhs) => x`${lhs} | ${rhs}`) : x`0`;
              }
              return {
                type: "ArrayExpression",
                elements
              };
            }
            return Array.from(names2).map((name) => {
              const lookup_name = names_lookup.has(name) ? names_lookup.get(name) : name;
              const i2 = context_lookup.get(name).index.value;
              return x`${lookup_name} ? ${1 << i2} : 0`;
            }).reduce((lhs, rhs) => x`${lhs} | ${rhs}`);
          }
        };
        return {
          block,
          scope: scope2,
          get_context: x`${context_input} => ${context}`,
          get_changes: x`${changes_input} => ${changes}`
        };
      }
      class SlotTemplateWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          const { scope: scope2, lets, slot_template_name } = this.node;
          lets.forEach((l) => {
            extract_names(l.value || l.name).forEach((name) => {
              renderer.add_to_context(name, true);
            });
          });
          this.block = block.child({
            comment: create_debugging_comment(this.node, this.renderer.component),
            name: this.renderer.component.get_unique_name(`create_${sanitize(slot_template_name)}_slot`),
            type: "slot"
          });
          this.renderer.blocks.push(this.block);
          const seen = new Set(lets.map((l) => l.name.name));
          this.parent.node.lets.forEach((l) => {
            if (!seen.has(l.name.name))
              lets.push(l);
          });
          this.parent.set_slot(slot_template_name, get_slot_definition(this.block, scope2, lets));
          this.fragment = new FragmentWrapper(renderer, this.block, node2.type === "SlotTemplate" ? node2.children : [node2], this, strip_whitespace, next_sibling);
          this.block.parent.add_dependencies(this.block.dependencies);
        }
        render() {
          this.fragment.render(this.block, null, x`#nodes`);
        }
      }
      function string_to_member_expression(name) {
        const parts = name.split(".");
        let node2 = {
          type: "Identifier",
          name: parts[0]
        };
        for (let i2 = 1; i2 < parts.length; i2++) {
          node2 = {
            type: "MemberExpression",
            object: node2,
            property: { type: "Identifier", name: parts[i2] }
          };
        }
        return node2;
      }
      var compiler_warnings = {
        custom_element_no_tag: {
          code: "custom-element-no-tag",
          message: `No custom element 'tag' option was specified. To automatically register a custom element, specify a name with a hyphen in it, e.g. <svelte:options tag="my-thing"/>. To hide this warning, use <svelte:options tag={null}/>`
        },
        unused_export_let: (component, property) => ({
          code: "unused-export-let",
          message: `${component} has unused export property '${property}'. If it is for external reference only, please consider using \`export const ${property}\``
        }),
        module_script_reactive_declaration: {
          code: "module-script-reactive-declaration",
          message: "$: has no effect in a module script"
        },
        non_top_level_reactive_declaration: {
          code: "non-top-level-reactive-declaration",
          message: "$: has no effect outside of the top-level"
        },
        module_script_variable_reactive_declaration: (names2) => ({
          code: "module-script-reactive-declaration",
          message: `${names2.map((name) => `"${name}"`).join(", ")} ${names2.length > 1 ? "are" : "is"} declared in a module script and will not be reactive`
        }),
        missing_declaration: (name, has_script) => ({
          code: "missing-declaration",
          message: `'${name}' is not defined` + (has_script ? "" : `. Consider adding a <script> block with 'export let ${name}' to declare a prop`)
        }),
        missing_custom_element_compile_options: {
          code: "missing-custom-element-compile-options",
          message: "The 'tag' option is used when generating a custom element. Did you forget the 'customElement: true' compile option?"
        },
        css_unused_selector: (selector2) => ({
          code: "css-unused-selector",
          message: `Unused CSS selector "${selector2}"`
        }),
        empty_block: {
          code: "empty-block",
          message: "Empty block"
        },
        reactive_component: (name) => ({
          code: "reactive-component",
          message: `<${name}/> will not be reactive if ${name} changes. Use <svelte:component this={${name}}/> if you want this reactivity.`
        }),
        component_name_lowercase: (name) => ({
          code: "component-name-lowercase",
          message: `<${name}> will be treated as an HTML element unless it begins with a capital letter`
        }),
        avoid_is: {
          code: "avoid-is",
          message: "The 'is' attribute is not supported cross-browser and should be avoided"
        },
        invalid_html_attribute: (name, suggestion) => ({
          code: "invalid-html-attribute",
          message: `'${name}' is not a valid HTML attribute. Did you mean '${suggestion}'?`
        }),
        a11y_aria_attributes: (name) => ({
          code: "a11y-aria-attributes",
          message: `A11y: <${name}> should not have aria-* attributes`
        }),
        a11y_unknown_aria_attribute: (attribute, suggestion) => ({
          code: "a11y-unknown-aria-attribute",
          message: `A11y: Unknown aria attribute 'aria-${attribute}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
        }),
        a11y_hidden: (name) => ({
          code: "a11y-hidden",
          message: `A11y: <${name}> element should not be hidden`
        }),
        a11y_misplaced_role: (name) => ({
          code: "a11y-misplaced-role",
          message: `A11y: <${name}> should not have role attribute`
        }),
        a11y_unknown_role: (role, suggestion) => ({
          code: "a11y-unknown-role",
          message: `A11y: Unknown role '${role}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
        }),
        a11y_accesskey: {
          code: "a11y-accesskey",
          message: "A11y: Avoid using accesskey"
        },
        a11y_autofocus: {
          code: "a11y-autofocus",
          message: "A11y: Avoid using autofocus"
        },
        a11y_misplaced_scope: {
          code: "a11y-misplaced-scope",
          message: "A11y: The scope attribute should only be used with <th> elements"
        },
        a11y_positive_tabindex: {
          code: "a11y-positive-tabindex",
          message: "A11y: avoid tabindex values above zero"
        },
        a11y_invalid_attribute: (href_attribute, href_value) => ({
          code: "a11y-invalid-attribute",
          message: `A11y: '${href_value}' is not a valid ${href_attribute} attribute`
        }),
        a11y_missing_attribute: (name, article, sequence2) => ({
          code: "a11y-missing-attribute",
          message: `A11y: <${name}> element should have ${article} ${sequence2} attribute`
        }),
        a11y_img_redundant_alt: {
          code: "a11y-img-redundant-alt",
          message: "A11y: Screenreaders already announce <img> elements as an image."
        },
        a11y_label_has_associated_control: {
          code: "a11y-label-has-associated-control",
          message: "A11y: A form label must be associated with a control."
        },
        a11y_media_has_caption: {
          code: "a11y-media-has-caption",
          message: 'A11y: <video> elements must have a <track kind="captions">'
        },
        a11y_distracting_elements: (name) => ({
          code: "a11y-distracting-elements",
          message: `A11y: Avoid <${name}> elements`
        }),
        a11y_structure_immediate: {
          code: "a11y-structure",
          message: "A11y: <figcaption> must be an immediate child of <figure>"
        },
        a11y_structure_first_or_last: {
          code: "a11y-structure",
          message: "A11y: <figcaption> must be first or last child of <figure>"
        },
        a11y_mouse_events_have_key_events: (event, accompanied_by) => ({
          code: "a11y-mouse-events-have-key-events",
          message: `A11y: on:${event} must be accompanied by on:${accompanied_by}`
        }),
        a11y_missing_content: (name) => ({
          code: "a11y-missing-content",
          message: `A11y: <${name}> element should have child content`
        }),
        redundant_event_modifier_for_touch: {
          code: "redundant-event-modifier",
          message: "Touch event handlers that don't use the 'event' object are passive by default"
        },
        redundant_event_modifier_passive: {
          code: "redundant-event-modifier",
          message: "The passive modifier only works with wheel and touch events"
        }
      };
      class InlineComponentWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          this.slots = new Map();
          this.children = [];
          this.cannot_use_innerhtml();
          this.not_static_content();
          if (this.node.expression) {
            block.add_dependencies(this.node.expression.dependencies);
          }
          this.node.attributes.forEach((attr) => {
            block.add_dependencies(attr.dependencies);
          });
          this.node.bindings.forEach((binding) => {
            if (binding.is_contextual) {
              mark_each_block_bindings(this, binding);
            }
            block.add_dependencies(binding.expression.dependencies);
          });
          this.node.handlers.forEach((handler2) => {
            if (handler2.expression) {
              block.add_dependencies(handler2.expression.dependencies);
            }
          });
          this.node.css_custom_properties.forEach((attr) => {
            block.add_dependencies(attr.dependencies);
          });
          this.var = {
            type: "Identifier",
            name: (this.node.name === "svelte:self" ? renderer.component.name.name : this.node.name === "svelte:component" ? "switch_instance" : sanitize(this.node.name)).toLowerCase()
          };
          if (this.node.children.length) {
            this.node.lets.forEach((l) => {
              extract_names(l.value || l.name).forEach((name) => {
                renderer.add_to_context(name, true);
              });
            });
            this.children = this.node.children.map((child) => new SlotTemplateWrapper(renderer, block, this, child, strip_whitespace, next_sibling));
          }
          block.add_outro();
        }
        set_slot(name, slot_definition) {
          if (this.slots.has(name)) {
            if (name === "default") {
              throw new Error('Found elements without slot attribute when using slot="default"');
            }
            throw new Error(`Duplicate slot name "${name}" in <${this.node.name}>`);
          }
          this.slots.set(name, slot_definition);
        }
        warn_if_reactive() {
          const { name } = this.node;
          const variable = this.renderer.component.var_lookup.get(name);
          if (!variable) {
            return;
          }
          if (variable.reassigned || variable.export_name || variable.is_reactive_dependency) {
            this.renderer.component.warn(this.node, compiler_warnings.reactive_component(name));
          }
        }
        render(block, parent_node, parent_nodes) {
          this.warn_if_reactive();
          const { renderer } = this;
          const { component } = renderer;
          const name = this.var;
          block.add_variable(name);
          const component_opts = x`{}`;
          const statements = [];
          const updates = [];
          this.children.forEach((child) => {
            this.renderer.add_to_context("$$scope", true);
            child.render(block, null, x`#nodes`);
          });
          let props;
          const name_changes = block.get_unique_name(`${name.name}_changes`);
          const uses_spread = !!this.node.attributes.find((a) => a.is_spread);
          for (const slot of this.slots.keys()) {
            if (!this.slots.get(slot).block.has_content()) {
              this.renderer.remove_block(this.slots.get(slot).block);
              this.slots.delete(slot);
            }
          }
          const has_css_custom_properties = this.node.css_custom_properties.length > 0;
          const css_custom_properties_wrapper = has_css_custom_properties ? block.get_unique_name("div") : null;
          if (has_css_custom_properties) {
            block.add_variable(css_custom_properties_wrapper);
          }
          const initial_props = this.slots.size > 0 ? [
            p`$$slots: {
					${Array.from(this.slots).map(([name2, slot]) => {
              return p`${name2}: [${slot.block.name}, ${slot.get_context || null}, ${slot.get_changes || null}]`;
            })}
				}`,
            p`$$scope: {
					ctx: #ctx
				}`
          ] : [];
          const attribute_object = uses_spread ? x`{ ${initial_props} }` : x`{
				${this.node.attributes.map((attr) => p`${attr.name}: ${attr.get_value(block)}`)},
				${initial_props}
			}`;
          if (this.node.attributes.length || this.node.bindings.length || initial_props.length) {
            if (!uses_spread && this.node.bindings.length === 0) {
              component_opts.properties.push(p`props: ${attribute_object}`);
            } else {
              props = block.get_unique_name(`${name.name}_props`);
              component_opts.properties.push(p`props: ${props}`);
            }
          }
          if (component.compile_options.dev) {
            component_opts.properties.push(p`$$inline: true`);
          }
          const fragment_dependencies = new Set(this.slots.size ? ["$$scope"] : []);
          this.slots.forEach((slot) => {
            slot.block.dependencies.forEach((name2) => {
              const is_let = slot.scope.is_let(name2);
              const variable = renderer.component.var_lookup.get(name2);
              if (is_let || is_dynamic$1(variable))
                fragment_dependencies.add(name2);
            });
          });
          const dynamic_attributes = this.node.attributes.filter((a) => a.get_dependencies().length > 0);
          if (!uses_spread && (dynamic_attributes.length > 0 || this.node.bindings.length > 0 || fragment_dependencies.size > 0)) {
            updates.push(b`const ${name_changes} = {};`);
          }
          if (this.node.attributes.length) {
            if (uses_spread) {
              const levels = block.get_unique_name(`${this.var.name}_spread_levels`);
              const initial_props2 = [];
              const changes = [];
              const all_dependencies = new Set();
              this.node.attributes.forEach((attr) => {
                add_to_set(all_dependencies, attr.dependencies);
              });
              this.node.attributes.forEach((attr, i2) => {
                const { name: name2, dependencies } = attr;
                const condition = dependencies.size > 0 && dependencies.size !== all_dependencies.size ? renderer.dirty(Array.from(dependencies)) : null;
                const unchanged = dependencies.size === 0;
                let change_object;
                if (attr.is_spread) {
                  const value2 = attr.expression.manipulate(block);
                  initial_props2.push(value2);
                  let value_object = value2;
                  if (attr.expression.node.type !== "ObjectExpression") {
                    value_object = x`@get_spread_object(${value2})`;
                  }
                  change_object = value_object;
                } else {
                  const obj = x`{ ${name2}: ${attr.get_value(block)} }`;
                  initial_props2.push(obj);
                  change_object = obj;
                }
                changes.push(unchanged ? x`${levels}[${i2}]` : condition ? x`${condition} && ${change_object}` : change_object);
              });
              block.chunks.init.push(b`
					const ${levels} = [
						${initial_props2}
					];
				`);
              statements.push(b`
					for (let #i = 0; #i < ${levels}.length; #i += 1) {
						${props} = @assign(${props}, ${levels}[#i]);
					}
				`);
              if (all_dependencies.size) {
                const condition = renderer.dirty(Array.from(all_dependencies));
                updates.push(b`
						const ${name_changes} = ${condition} ? @get_spread_update(${levels}, [
							${changes}
						]) : {}
					`);
              } else {
                updates.push(b`
						const ${name_changes} = {};
					`);
              }
            } else {
              dynamic_attributes.forEach((attribute) => {
                const dependencies = attribute.get_dependencies();
                if (dependencies.length > 0) {
                  const condition = renderer.dirty(dependencies);
                  updates.push(b`
							if (${condition}) ${name_changes}.${attribute.name} = ${attribute.get_value(block)};
						`);
                }
              });
            }
          }
          if (fragment_dependencies.size > 0) {
            updates.push(b`
				if (${renderer.dirty(Array.from(fragment_dependencies))}) {
					${name_changes}.$$scope = { dirty: #dirty, ctx: #ctx };
				}`);
          }
          const munged_bindings = this.node.bindings.map((binding) => {
            component.has_reactive_assignments = true;
            if (binding.name === "this") {
              return bind_this(component, block, new BindingWrapper(block, binding, this), this.var);
            }
            const id2 = component.get_unique_name(`${this.var.name}_${binding.name}_binding`);
            renderer.add_to_context(id2.name);
            const callee = renderer.reference(id2);
            const updating = block.get_unique_name(`updating_${binding.name}`);
            block.add_variable(updating);
            const snippet = binding.expression.manipulate(block);
            statements.push(b`
				if (${snippet} !== void 0) {
					${props}.${binding.name} = ${snippet};
				}`);
            updates.push(b`
				if (!${updating} && ${renderer.dirty(Array.from(binding.expression.dependencies))}) {
					${updating} = true;
					${name_changes}.${binding.name} = ${snippet};
					@add_flush_callback(() => ${updating} = false);
				}
			`);
            const contextual_dependencies = Array.from(binding.expression.contextual_dependencies);
            const dependencies = Array.from(binding.expression.dependencies);
            let lhs = binding.raw_expression;
            if (binding.is_contextual && binding.expression.node.type === "Identifier") {
              const { name: name2 } = binding.expression.node;
              const { object, property, snippet: snippet2 } = block.bindings.get(name2);
              lhs = snippet2;
              contextual_dependencies.push(object.name, property.name);
            }
            const params = [x`#value`];
            const args = [x`#value`];
            if (contextual_dependencies.length > 0) {
              contextual_dependencies.forEach((name2) => {
                params.push({
                  type: "Identifier",
                  name: name2
                });
                renderer.add_to_context(name2, true);
                args.push(renderer.reference(name2));
              });
              block.maintain_context = true;
            }
            block.chunks.init.push(b`
				function ${id2}(#value) {
					${callee}(${args});
				}
			`);
            let invalidate_binding = b`
				${lhs} = #value;
				${renderer.invalidate(dependencies[0])};
			`;
            if (binding.expression.node.type === "MemberExpression") {
              invalidate_binding = b`
					if ($$self.$$.not_equal(${lhs}, #value)) {
						${invalidate_binding}
					}
				`;
            }
            const body = b`
				function ${id2}(${params}) {
					${invalidate_binding}
				}
			`;
            component.partly_hoisted.push(body);
            return b`@binding_callbacks.push(() => @bind(${this.var}, '${binding.name}', ${id2}));`;
          });
          const munged_handlers = this.node.handlers.map((handler2) => {
            const event_handler = new EventHandlerWrapper(handler2, this);
            let snippet = event_handler.get_snippet(block);
            if (handler2.modifiers.has("once"))
              snippet = x`@once(${snippet})`;
            return b`${name}.$on("${handler2.name}", ${snippet});`;
          });
          if (this.node.name === "svelte:component") {
            const switch_value = block.get_unique_name("switch_value");
            const switch_props = block.get_unique_name("switch_props");
            const snippet = this.node.expression.manipulate(block);
            block.chunks.init.push(b`
				var ${switch_value} = ${snippet};

				function ${switch_props}(#ctx) {
					${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b`
					${props && b`let ${props} = ${attribute_object};`}`}
					${statements}
					return ${component_opts};
				}

				if (${switch_value}) {
					${name} = new ${switch_value}(${switch_props}(#ctx));

					${munged_bindings}
					${munged_handlers}
				}
			`);
            block.chunks.create.push(b`if (${name}) @create_component(${name}.$$.fragment);`);
            if (parent_nodes && this.renderer.options.hydratable) {
              block.chunks.claim.push(b`if (${name}) @claim_component(${name}.$$.fragment, ${parent_nodes});`);
            }
            block.chunks.mount.push(b`
				if (${name}) {
					@mount_component(${name}, ${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
				}
			`);
            const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
            const update_mount_node = this.get_update_mount_node(anchor);
            if (updates.length) {
              block.chunks.update.push(b`
					${updates}
				`);
            }
            block.chunks.update.push(b`
				if (${switch_value} !== (${switch_value} = ${snippet})) {
					if (${name}) {
						@group_outros();
						const old_component = ${name};
						@transition_out(old_component.$$.fragment, 1, 0, () => {
							@destroy_component(old_component, 1);
						});
						@check_outros();
					}

					if (${switch_value}) {
						${name} = new ${switch_value}(${switch_props}(#ctx));

						${munged_bindings}
						${munged_handlers}

						@create_component(${name}.$$.fragment);
						@transition_in(${name}.$$.fragment, 1);
						@mount_component(${name}, ${update_mount_node}, ${anchor});
					} else {
						${name} = null;
					}
				} else if (${switch_value}) {
					${updates.length > 0 && b`${name}.$set(${name_changes});`}
				}
			`);
            block.chunks.intro.push(b`
				if (${name}) @transition_in(${name}.$$.fragment, #local);
			`);
            block.chunks.outro.push(b`if (${name}) @transition_out(${name}.$$.fragment, #local);`);
            block.chunks.destroy.push(b`if (${name}) @destroy_component(${name}, ${parent_node ? null : "detaching"});`);
          } else {
            const expression2 = this.node.name === "svelte:self" ? component.name : this.renderer.reference(string_to_member_expression(this.node.name));
            block.chunks.init.push(b`
				${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b`
				${props && b`let ${props} = ${attribute_object};`}`}
				${statements}
				${name} = new ${expression2}(${component_opts});

				${munged_bindings}
				${munged_handlers}
			`);
            if (has_css_custom_properties) {
              block.chunks.create.push(b`${css_custom_properties_wrapper} = @element("div");`);
              block.chunks.hydrate.push(b`@set_style(${css_custom_properties_wrapper}, "display", "contents");`);
              this.node.css_custom_properties.forEach((attr) => {
                const dependencies = attr.get_dependencies();
                const should_cache2 = attr.should_cache();
                const last = should_cache2 && block.get_unique_name(`${attr.name.replace(/[^a-zA-Z_$]/g, "_")}_last`);
                if (should_cache2)
                  block.add_variable(last);
                const value2 = attr.get_value(block);
                const init2 = should_cache2 ? x`${last} = ${value2}` : value2;
                block.chunks.hydrate.push(b`@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${init2});`);
                if (dependencies.length > 0) {
                  let condition = block.renderer.dirty(dependencies);
                  if (should_cache2)
                    condition = x`${condition} && (${last} !== (${last} = ${value2}))`;
                  block.chunks.update.push(b`
							if (${condition}) {
								@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${should_cache2 ? last : value2});
							}
						`);
                }
              });
            }
            block.chunks.create.push(b`@create_component(${name}.$$.fragment);`);
            if (parent_nodes && this.renderer.options.hydratable) {
              let nodes = parent_nodes;
              if (has_css_custom_properties) {
                nodes = block.get_unique_name(`${css_custom_properties_wrapper.name}_nodes`);
                block.chunks.claim.push(b`
						${css_custom_properties_wrapper} = @claim_element(${parent_nodes}, "DIV", { style: true })
						var ${nodes} = @children(${css_custom_properties_wrapper});
					`);
              }
              block.chunks.claim.push(b`@claim_component(${name}.$$.fragment, ${nodes});`);
            }
            if (has_css_custom_properties) {
              if (parent_node) {
                block.chunks.mount.push(b`@append(${parent_node}, ${css_custom_properties_wrapper})`);
                if (is_head(parent_node)) {
                  block.chunks.destroy.push(b`@detach(${css_custom_properties_wrapper});`);
                }
              } else {
                block.chunks.mount.push(b`@insert(#target, ${css_custom_properties_wrapper}, #anchor);`);
                block.chunks.destroy.push(b`if (detaching) @detach(${css_custom_properties_wrapper});`);
              }
              block.chunks.mount.push(b`@mount_component(${name}, ${css_custom_properties_wrapper}, null);`);
            } else {
              block.chunks.mount.push(b`@mount_component(${name}, ${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});`);
            }
            block.chunks.intro.push(b`
				@transition_in(${name}.$$.fragment, #local);
			`);
            if (updates.length) {
              block.chunks.update.push(b`
					${updates}
					${name}.$set(${name_changes});
				`);
            }
            block.chunks.destroy.push(b`
				@destroy_component(${name}, ${parent_node ? null : "detaching"});
			`);
            block.chunks.outro.push(b`@transition_out(${name}.$$.fragment, #local);`);
          }
        }
      }
      function get_slot_data(values, block = null) {
        return {
          type: "ObjectExpression",
          properties: Array.from(values.values()).filter((attribute) => attribute.name !== "name").map((attribute) => {
            if (attribute.is_spread) {
              const argument = get_spread_value(block, attribute);
              return {
                type: "SpreadElement",
                argument
              };
            }
            const value2 = get_value(block, attribute);
            return p`${attribute.name}: ${value2}`;
          })
        };
      }
      function get_value(block, attribute) {
        if (attribute.is_true)
          return x`true`;
        if (attribute.chunks.length === 0)
          return x`""`;
        let value2 = attribute.chunks.map((chunk) => chunk.type === "Text" ? string_literal(chunk.data) : block ? chunk.manipulate(block) : chunk.node).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
        if (attribute.chunks.length > 1 && attribute.chunks[0].type !== "Text") {
          value2 = x`"" + ${value2}`;
        }
        return value2;
      }
      function get_spread_value(block, attribute) {
        return block ? attribute.expression.manipulate(block) : attribute.expression.node;
      }
      class SlotWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
          super(renderer, block, parent, node2);
          this.fallback = null;
          this.var = { type: "Identifier", name: "slot" };
          this.dependencies = new Set(["$$scope"]);
          this.cannot_use_innerhtml();
          this.not_static_content();
          if (this.node.children.length) {
            this.fallback = block.child({
              comment: create_debugging_comment(this.node.children[0], this.renderer.component),
              name: this.renderer.component.get_unique_name("fallback_block"),
              type: "fallback"
            });
            renderer.blocks.push(this.fallback);
          }
          this.fragment = new FragmentWrapper(renderer, this.fallback, node2.children, this, strip_whitespace, next_sibling);
          this.node.values.forEach((attribute) => {
            add_to_set(this.dependencies, attribute.dependencies);
          });
          block.add_dependencies(this.dependencies);
          block.add_intro();
          block.add_outro();
        }
        render(block, parent_node, parent_nodes) {
          const { renderer } = this;
          const { slot_name } = this.node;
          if (this.slot_block) {
            block = this.slot_block;
          }
          let get_slot_changes_fn;
          let get_slot_spread_changes_fn;
          let get_slot_context_fn;
          if (this.node.values.size > 0) {
            get_slot_changes_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_changes`);
            get_slot_context_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_context`);
            const changes = x`{}`;
            const spread_dynamic_dependencies = new Set();
            this.node.values.forEach((attribute) => {
              if (attribute.type === "Spread") {
                add_to_set(spread_dynamic_dependencies, Array.from(attribute.dependencies).filter((name) => this.is_dependency_dynamic(name)));
              } else {
                const dynamic_dependencies2 = Array.from(attribute.dependencies).filter((name) => this.is_dependency_dynamic(name));
                if (dynamic_dependencies2.length > 0) {
                  changes.properties.push(p`${attribute.name}: ${renderer.dirty(dynamic_dependencies2)}`);
                }
              }
            });
            renderer.blocks.push(b`
				const ${get_slot_changes_fn} = #dirty => ${changes};
				const ${get_slot_context_fn} = #ctx => ${get_slot_data(this.node.values, block)};
			`);
            if (spread_dynamic_dependencies.size) {
              get_slot_spread_changes_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_spread_changes`);
              renderer.blocks.push(b`
					const ${get_slot_spread_changes_fn} = #dirty => ${renderer.dirty(Array.from(spread_dynamic_dependencies))};
				`);
            }
          } else {
            get_slot_changes_fn = "null";
            get_slot_context_fn = "null";
          }
          let has_fallback = !!this.fallback;
          if (this.fallback) {
            this.fragment.render(this.fallback, null, x`#nodes`);
            has_fallback = this.fallback.has_content();
            if (!has_fallback) {
              renderer.remove_block(this.fallback);
            }
          }
          const slot = block.get_unique_name(`${sanitize(slot_name)}_slot`);
          const slot_definition = block.get_unique_name(`${sanitize(slot_name)}_slot_template`);
          const slot_or_fallback = has_fallback ? block.get_unique_name(`${sanitize(slot_name)}_slot_or_fallback`) : slot;
          block.chunks.init.push(b`
			const ${slot_definition} = ${renderer.reference("#slots")}.${slot_name};
			const ${slot} = @create_slot(${slot_definition}, #ctx, ${renderer.reference("$$scope")}, ${get_slot_context_fn});
			${has_fallback ? b`const ${slot_or_fallback} = ${slot} || ${this.fallback.name}(#ctx);` : null}
		`);
          block.chunks.create.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.c();`);
          if (renderer.options.hydratable) {
            block.chunks.claim.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.l(${parent_nodes});`);
          }
          block.chunks.mount.push(b`
			if (${slot_or_fallback}) {
				${slot_or_fallback}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
			}
		`);
          block.chunks.intro.push(b`@transition_in(${slot_or_fallback}, #local);`);
          block.chunks.outro.push(b`@transition_out(${slot_or_fallback}, #local);`);
          const dynamic_dependencies = Array.from(this.dependencies).filter((name) => this.is_dependency_dynamic(name));
          const fallback_dynamic_dependencies = has_fallback ? Array.from(this.fallback.dependencies).filter((name) => this.is_dependency_dynamic(name)) : [];
          let condition = renderer.dirty(dynamic_dependencies);
          if (block.has_outros) {
            condition = x`!#current || ${condition}`;
          }
          const all_dirty_conditions = [
            get_slot_spread_changes_fn ? x`${get_slot_spread_changes_fn}(#dirty)` : null,
            block.has_outros ? x`!#current` : null
          ].filter(Boolean);
          const all_dirty_condition = all_dirty_conditions.length ? all_dirty_conditions.reduce((condition1, condition2) => x`${condition1} || ${condition2}`) : null;
          let slot_update;
          if (all_dirty_condition) {
            const dirty = x`${all_dirty_condition} ? @get_all_dirty_from_scope(${renderer.reference("$$scope")}) : @get_slot_changes(${slot_definition}, ${renderer.reference("$$scope")}, #dirty, ${get_slot_changes_fn})`;
            slot_update = b`
				if (${slot}.p && ${condition}) {
					@update_slot_base(${slot}, ${slot_definition}, #ctx, ${renderer.reference("$$scope")}, ${dirty}, ${get_slot_context_fn});
				}
			`;
          } else {
            slot_update = b`
				if (${slot}.p && ${condition}) {
					@update_slot(${slot}, ${slot_definition}, #ctx, ${renderer.reference("$$scope")}, #dirty, ${get_slot_changes_fn}, ${get_slot_context_fn});
				}
			`;
          }
          let fallback_condition = renderer.dirty(fallback_dynamic_dependencies);
          let fallback_dirty = x`#dirty`;
          if (block.has_outros) {
            fallback_condition = x`!#current || ${fallback_condition}`;
            fallback_dirty = x`!#current ? ${renderer.get_initial_dirty()} : ${fallback_dirty}`;
          }
          const fallback_update = has_fallback && fallback_dynamic_dependencies.length > 0 && b`
			if (${slot_or_fallback} && ${slot_or_fallback}.p && ${fallback_condition}) {
				${slot_or_fallback}.p(#ctx, ${fallback_dirty});
			}
		`;
          if (fallback_update) {
            block.chunks.update.push(b`
				if (${slot}) {
					${slot_update}
				} else {
					${fallback_update}
				}
			`);
          } else {
            block.chunks.update.push(b`
				if (${slot}) {
					${slot_update}
				}
			`);
          }
          block.chunks.destroy.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.d(detaching);`);
        }
        is_dependency_dynamic(name) {
          if (name === "$$scope")
            return true;
          if (this.node.scope.is_let(name))
            return true;
          if (is_reserved_keyword(name))
            return true;
          const variable = this.renderer.component.var_lookup.get(name);
          return is_dynamic$1(variable);
        }
      }
      class TitleWrapper extends Wrapper {
        constructor(renderer, block, parent, node2, _strip_whitespace, _next_sibling) {
          super(renderer, block, parent, node2);
        }
        render(block, _parent_node, _parent_nodes) {
          const is_dynamic2 = !!this.node.children.find((node2) => node2.type !== "Text");
          if (is_dynamic2) {
            let value2;
            const all_dependencies = new Set();
            if (this.node.children.length === 1) {
              const { expression: expression2 } = this.node.children[0];
              value2 = expression2.manipulate(block);
              add_to_set(all_dependencies, expression2.dependencies);
            } else {
              value2 = this.node.children.map((chunk) => {
                if (chunk.type === "Text")
                  return string_literal(chunk.data);
                chunk.expression.dependencies.forEach((d2) => {
                  all_dependencies.add(d2);
                });
                return chunk.expression.manipulate(block);
              }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
              if (this.node.children[0].type !== "Text") {
                value2 = x`"" + ${value2}`;
              }
            }
            const last = this.node.should_cache && block.get_unique_name("title_value");
            if (this.node.should_cache)
              block.add_variable(last);
            const init2 = this.node.should_cache ? x`${last} = ${value2}` : value2;
            block.chunks.init.push(b`@_document.title = ${init2};`);
            const updater = b`@_document.title = ${this.node.should_cache ? last : value2};`;
            if (all_dependencies.size) {
              const dependencies = Array.from(all_dependencies);
              let condition = block.renderer.dirty(dependencies);
              if (block.has_outros) {
                condition = x`!#current || ${condition}`;
              }
              if (this.node.should_cache) {
                condition = x`${condition} && (${last} !== (${last} = ${value2}))`;
              }
              block.chunks.update.push(b`
					if (${condition}) {
						${updater}
					}`);
            }
          } else {
            const value2 = this.node.children.length > 0 ? string_literal(this.node.children[0].data) : x`""`;
            block.chunks.hydrate.push(b`@_document.title = ${value2};`);
          }
        }
      }
      const associated_events = {
        innerWidth: "resize",
        innerHeight: "resize",
        outerWidth: "resize",
        outerHeight: "resize",
        scrollX: "scroll",
        scrollY: "scroll"
      };
      const properties$1 = {
        scrollX: "pageXOffset",
        scrollY: "pageYOffset"
      };
      const readonly = new Set([
        "innerWidth",
        "innerHeight",
        "outerWidth",
        "outerHeight",
        "online"
      ]);
      class WindowWrapper extends Wrapper {
        constructor(renderer, block, parent, node2) {
          super(renderer, block, parent, node2);
          this.handlers = this.node.handlers.map((handler2) => new EventHandlerWrapper(handler2, this));
        }
        render(block, _parent_node, _parent_nodes) {
          const { renderer } = this;
          const { component } = renderer;
          const events2 = {};
          const bindings = {};
          add_actions(block, "@_window", this.node.actions);
          add_event_handlers(block, "@_window", this.handlers);
          this.node.bindings.forEach((binding) => {
            const binding_name = binding.expression.node.name;
            if (readonly.has(binding.name)) {
              renderer.readonly.add(binding_name);
            }
            bindings[binding.name] = binding_name;
            if (binding.name === "online")
              return;
            const associated_event = associated_events[binding.name];
            const property = properties$1[binding.name] || binding.name;
            if (!events2[associated_event])
              events2[associated_event] = [];
            events2[associated_event].push({
              name: binding_name,
              value: property
            });
          });
          const scrolling = block.get_unique_name("scrolling");
          const clear_scrolling = block.get_unique_name("clear_scrolling");
          const scrolling_timeout = block.get_unique_name("scrolling_timeout");
          Object.keys(events2).forEach((event) => {
            const id2 = block.get_unique_name(`onwindow${event}`);
            const props = events2[event];
            renderer.add_to_context(id2.name);
            const fn = renderer.reference(id2.name);
            if (event === "scroll") {
              block.add_variable(scrolling, x`false`);
              block.add_variable(clear_scrolling, x`() => { ${scrolling} = false }`);
              block.add_variable(scrolling_timeout);
              const condition = bindings.scrollX && bindings.scrollY ? x`"${bindings.scrollX}" in this._state || "${bindings.scrollY}" in this._state` : x`"${bindings.scrollX || bindings.scrollY}" in this._state`;
              const scrollX = bindings.scrollX && x`this._state.${bindings.scrollX}`;
              const scrollY = bindings.scrollY && x`this._state.${bindings.scrollY}`;
              renderer.meta_bindings.push(b`
					if (${condition}) {
						@_scrollTo(${scrollX || "@_window.pageXOffset"}, ${scrollY || "@_window.pageYOffset"});
					}
					${scrollX && `${scrollX} = @_window.pageXOffset;`}
					${scrollY && `${scrollY} = @_window.pageYOffset;`}
				`);
              block.event_listeners.push(x`
					@listen(@_window, "${event}", () => {
						${scrolling} = true;
						@_clearTimeout(${scrolling_timeout});
						${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
						${fn}();
					})
				`);
            } else {
              props.forEach((prop) => {
                renderer.meta_bindings.push(b`this._state.${prop.name} = @_window.${prop.value};`);
              });
              block.event_listeners.push(x`
					@listen(@_window, "${event}", ${fn})
				`);
            }
            component.partly_hoisted.push(b`
				function ${id2}() {
					${props.map((prop) => renderer.invalidate(prop.name, x`${prop.name} = @_window.${prop.value}`))}
				}
			`);
            block.chunks.init.push(b`
				@add_render_callback(${fn});
			`);
            component.has_reactive_assignments = true;
          });
          if (bindings.scrollX || bindings.scrollY) {
            const condition = renderer.dirty([bindings.scrollX, bindings.scrollY].filter(Boolean));
            const scrollX = bindings.scrollX ? renderer.reference(bindings.scrollX) : x`@_window.pageXOffset`;
            const scrollY = bindings.scrollY ? renderer.reference(bindings.scrollY) : x`@_window.pageYOffset`;
            block.chunks.update.push(b`
				if (${condition} && !${scrolling}) {
					${scrolling} = true;
					@_clearTimeout(${scrolling_timeout});
					@_scrollTo(${scrollX}, ${scrollY});
					${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
				}
			`);
          }
          if (bindings.online) {
            const id2 = block.get_unique_name("onlinestatuschanged");
            const name = bindings.online;
            renderer.add_to_context(id2.name);
            const reference = renderer.reference(id2.name);
            component.partly_hoisted.push(b`
				function ${id2}() {
					${renderer.invalidate(name, x`${name} = @_navigator.onLine`)}
				}
			`);
            block.chunks.init.push(b`
				@add_render_callback(${reference});
			`);
            block.event_listeners.push(x`@listen(@_window, "online", ${reference})`, x`@listen(@_window, "offline", ${reference})`);
            component.has_reactive_assignments = true;
          }
        }
      }
      function link(next, prev) {
        prev.next = next;
        if (next)
          next.prev = prev;
      }
      const wrappers = {
        AwaitBlock: AwaitBlockWrapper,
        Body: BodyWrapper,
        Comment: null,
        DebugTag: DebugTagWrapper,
        EachBlock: EachBlockWrapper,
        Element: ElementWrapper,
        Head: HeadWrapper,
        IfBlock: IfBlockWrapper,
        InlineComponent: InlineComponentWrapper,
        KeyBlock: KeyBlockWrapper,
        MustacheTag: MustacheTagWrapper,
        Options: null,
        RawMustacheTag: RawMustacheTagWrapper,
        Slot: SlotWrapper,
        SlotTemplate: SlotTemplateWrapper,
        Text: TextWrapper,
        Title: TitleWrapper,
        Window: WindowWrapper
      };
      function trimmable_at(child, next_sibling) {
        return next_sibling.node.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.node.prev.type === "EachBlock";
      }
      class FragmentWrapper {
        constructor(renderer, block, nodes, parent, strip_whitespace, next_sibling) {
          this.nodes = [];
          let last_child;
          let window_wrapper;
          let i2 = nodes.length;
          while (i2--) {
            const child = nodes[i2];
            if (!child.type) {
              throw new Error("missing type");
            }
            if (!(child.type in wrappers)) {
              throw new Error(`TODO implement ${child.type}`);
            }
            if (child.type === "Window") {
              window_wrapper = new WindowWrapper(renderer, block, parent, child);
              continue;
            }
            if (child.type === "Text") {
              let { data: data2 } = child;
              if (this.nodes.length === 0) {
                const should_trim = next_sibling ? next_sibling.node.type === "Text" && /^\s/.test(next_sibling.node.data) && trimmable_at(child, next_sibling) : !child.has_ancestor("EachBlock");
                if (should_trim) {
                  data2 = trim_end(data2);
                  if (!data2)
                    continue;
                }
              }
              if (last_child && last_child.node.type === "Text") {
                last_child.data = data2 + last_child.data;
                continue;
              }
              const wrapper = new TextWrapper(renderer, block, parent, child, data2);
              if (wrapper.skip)
                continue;
              this.nodes.unshift(wrapper);
              link(last_child, last_child = wrapper);
            } else {
              const Wrapper2 = wrappers[child.type];
              if (!Wrapper2)
                continue;
              const wrapper = new Wrapper2(renderer, block, parent, child, strip_whitespace, last_child || next_sibling);
              this.nodes.unshift(wrapper);
              link(last_child, last_child = wrapper);
            }
          }
          if (strip_whitespace) {
            const first = this.nodes[0];
            if (first && first.node.type === "Text") {
              first.data = trim_start(first.data);
              if (!first.data) {
                first.var = null;
                this.nodes.shift();
                if (this.nodes[0]) {
                  this.nodes[0].prev = null;
                }
              }
            }
          }
          if (window_wrapper) {
            this.nodes.unshift(window_wrapper);
            link(last_child, window_wrapper);
          }
        }
        render(block, parent_node, parent_nodes) {
          for (let i2 = 0; i2 < this.nodes.length; i2 += 1) {
            this.nodes[i2].render(block, parent_node, parent_nodes);
          }
        }
      }
      class Renderer {
        constructor(component, options3) {
          this.context = [];
          this.initial_context = [];
          this.context_lookup = new Map();
          this.blocks = [];
          this.readonly = new Set();
          this.meta_bindings = [];
          this.binding_groups = new Map();
          this.component = component;
          this.options = options3;
          this.locate = component.locate;
          this.file_var = options3.dev && this.component.get_unique_name("file");
          component.vars.filter((v) => !v.hoistable || v.export_name && !v.module).forEach((v) => this.add_to_context(v.name));
          component.vars.filter((v) => v.subscribable).forEach((v) => this.add_to_context(`$${v.name}`));
          reserved_keywords.forEach((keyword) => {
            if (component.var_lookup.has(keyword)) {
              this.add_to_context(keyword);
            }
          });
          if (component.slots.size > 0) {
            this.add_to_context("$$scope");
            this.add_to_context("#slots");
          }
          if (this.binding_groups.size > 0) {
            this.add_to_context("$$binding_groups");
          }
          this.block = new Block$1({
            renderer: this,
            name: null,
            type: "component",
            key: null,
            bindings: new Map(),
            dependencies: new Set()
          });
          this.block.has_update_method = true;
          this.fragment = new FragmentWrapper(this, this.block, component.fragment.children, null, true, null);
          this.blocks.forEach((block) => {
            if (block instanceof Block$1) {
              block.assign_variable_names();
            }
          });
          this.block.assign_variable_names();
          this.fragment.render(this.block, null, x`#nodes`);
          this.context_overflow = this.context.length > 31;
          this.context.forEach((member) => {
            const { variable } = member;
            if (variable) {
              member.priority += 2;
              if (variable.mutated || variable.reassigned)
                member.priority += 4;
              if (variable.is_reactive_dependency && (variable.mutated || variable.reassigned))
                member.priority += 16;
              if (variable.export_name)
                member.priority += 32;
              if (variable.referenced)
                member.priority += 64;
            } else if (member.is_non_contextual) {
              member.priority += 8;
            }
            if (!member.is_contextual) {
              member.priority += 1;
            }
          });
          this.context.sort((a, b2) => b2.priority - a.priority || a.index.value - b2.index.value);
          this.context.forEach((member, i3) => member.index.value = i3);
          let i2 = this.context.length;
          while (i2--) {
            const member = this.context[i2];
            if (member.variable) {
              if (member.variable.referenced || member.variable.export_name || member.variable.is_reactive_dependency && (member.variable.mutated || member.variable.reassigned))
                break;
            } else if (member.is_non_contextual) {
              break;
            }
          }
          this.initial_context = this.context.slice(0, i2 + 1);
        }
        add_to_context(name, contextual = false) {
          if (!this.context_lookup.has(name)) {
            const member2 = {
              name,
              index: { type: "Literal", value: this.context.length },
              is_contextual: false,
              is_non_contextual: false,
              variable: null,
              priority: 0
            };
            this.context_lookup.set(name, member2);
            this.context.push(member2);
          }
          const member = this.context_lookup.get(name);
          if (contextual) {
            member.is_contextual = true;
          } else {
            member.is_non_contextual = true;
            member.variable = this.component.var_lookup.get(name);
          }
          return member;
        }
        invalidate(name, value2, main_execution_context = false) {
          return renderer_invalidate(this, name, value2, main_execution_context);
        }
        dirty(names2, is_reactive_declaration = false) {
          const renderer = this;
          const dirty = is_reactive_declaration ? x`$$self.$$.dirty` : x`#dirty`;
          const get_bitmask = () => {
            const bitmask = [];
            names2.forEach((name) => {
              const member = renderer.context_lookup.get(name);
              if (!member)
                return;
              if (member.index.value === -1) {
                throw new Error("unset index");
              }
              const value2 = member.index.value;
              const i2 = value2 / 31 | 0;
              const n2 = 1 << value2 % 31;
              if (!bitmask[i2])
                bitmask[i2] = { n: 0, names: [] };
              bitmask[i2].n |= n2;
              bitmask[i2].names.push(name);
            });
            return bitmask;
          };
          return {
            type: "ParenthesizedExpression",
            get expression() {
              const bitmask = get_bitmask();
              if (!bitmask.length) {
                return x`${dirty} & /*${names2.join(", ")}*/ 0`;
              }
              if (renderer.context_overflow) {
                return bitmask.map((b2, i2) => ({ b: b2, i: i2 })).filter(({ b: b2 }) => b2).map(({ b: b2, i: i2 }) => x`${dirty}[${i2}] & /*${b2.names.join(", ")}*/ ${b2.n}`).reduce((lhs, rhs) => x`${lhs} | ${rhs}`);
              }
              return x`${dirty} & /*${names2.join(", ")}*/ ${bitmask[0].n}`;
            }
          };
        }
        get_initial_dirty() {
          const _this = this;
          const val = x`-1`;
          return {
            get type() {
              return _this.context_overflow ? "ArrayExpression" : "UnaryExpression";
            },
            get elements() {
              const elements = [];
              for (let i2 = 0; i2 < _this.context.length; i2 += 31) {
                elements.push(val);
              }
              return elements;
            },
            operator: val.operator,
            prefix: val.prefix,
            argument: val.argument
          };
        }
        reference(node2) {
          if (typeof node2 === "string") {
            node2 = { type: "Identifier", name: node2 };
          }
          const { name, nodes } = flatten_reference(node2);
          const member = this.context_lookup.get(name);
          if (this.component.var_lookup.get(name)) {
            this.component.add_reference(name);
          }
          if (member !== void 0) {
            const replacement = x`/*${member.name}*/ #ctx[${member.index}]`;
            if (nodes[0].loc)
              replacement.object.loc = nodes[0].loc;
            nodes[0] = replacement;
            return nodes.reduce((lhs, rhs) => x`${lhs}.${rhs}`);
          }
          return node2;
        }
        remove_block(block) {
          this.blocks.splice(this.blocks.indexOf(block), 1);
        }
      }
      var charToInteger$1 = {};
      var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      for (var i$2 = 0; i$2 < chars$1.length; i$2++) {
        charToInteger$1[chars$1.charCodeAt(i$2)] = i$2;
      }
      function decode$1(mappings) {
        var decoded = [];
        var line = [];
        var segment = [
          0,
          0,
          0,
          0,
          0
        ];
        var j = 0;
        for (var i2 = 0, shift = 0, value2 = 0; i2 < mappings.length; i2++) {
          var c2 = mappings.charCodeAt(i2);
          if (c2 === 44) {
            segmentify$1(line, segment, j);
            j = 0;
          } else if (c2 === 59) {
            segmentify$1(line, segment, j);
            j = 0;
            decoded.push(line);
            line = [];
            segment[0] = 0;
          } else {
            var integer = charToInteger$1[c2];
            if (integer === void 0) {
              throw new Error("Invalid character (" + String.fromCharCode(c2) + ")");
            }
            var hasContinuationBit = integer & 32;
            integer &= 31;
            value2 += integer << shift;
            if (hasContinuationBit) {
              shift += 5;
            } else {
              var shouldNegate = value2 & 1;
              value2 >>>= 1;
              if (shouldNegate) {
                value2 = value2 === 0 ? -2147483648 : -value2;
              }
              segment[j] += value2;
              j++;
              value2 = shift = 0;
            }
          }
        }
        segmentify$1(line, segment, j);
        decoded.push(line);
        return decoded;
      }
      function segmentify$1(line, segment, j) {
        if (j === 4)
          line.push([segment[0], segment[1], segment[2], segment[3]]);
        else if (j === 5)
          line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);
        else if (j === 1)
          line.push([segment[0]]);
      }
      function encode$1(decoded) {
        var sourceFileIndex = 0;
        var sourceCodeLine = 0;
        var sourceCodeColumn = 0;
        var nameIndex = 0;
        var mappings = "";
        for (var i2 = 0; i2 < decoded.length; i2++) {
          var line = decoded[i2];
          if (i2 > 0)
            mappings += ";";
          if (line.length === 0)
            continue;
          var generatedCodeColumn = 0;
          var lineMappings = [];
          for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
            var segment = line_1[_i];
            var segmentMappings = encodeInteger$1(segment[0] - generatedCodeColumn);
            generatedCodeColumn = segment[0];
            if (segment.length > 1) {
              segmentMappings += encodeInteger$1(segment[1] - sourceFileIndex) + encodeInteger$1(segment[2] - sourceCodeLine) + encodeInteger$1(segment[3] - sourceCodeColumn);
              sourceFileIndex = segment[1];
              sourceCodeLine = segment[2];
              sourceCodeColumn = segment[3];
            }
            if (segment.length === 5) {
              segmentMappings += encodeInteger$1(segment[4] - nameIndex);
              nameIndex = segment[4];
            }
            lineMappings.push(segmentMappings);
          }
          mappings += lineMappings.join(",");
        }
        return mappings;
      }
      function encodeInteger$1(num) {
        var result = "";
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          var clamped = num & 31;
          num >>>= 5;
          if (num > 0) {
            clamped |= 32;
          }
          result += chars$1[clamped];
        } while (num > 0);
        return result;
      }
      function defaults(target, source) {
        return Object.assign(Object.create(null), source, target);
      }
      function decodeSourceMap(map) {
        if (typeof map === "string") {
          map = JSON.parse(map);
        }
        let { mappings } = map;
        if (typeof mappings === "string") {
          mappings = decode$1(mappings);
        } else {
          mappings = mappings.map(cloneSegmentLine);
        }
        mappings.forEach(sortSegments);
        return defaults({ mappings }, map);
      }
      function cloneSegmentLine(segments) {
        return segments.slice();
      }
      function sortSegments(segments) {
        segments.sort(segmentComparator);
      }
      function segmentComparator(a, b2) {
        return a[0] - b2[0];
      }
      class OriginalSource {
        constructor(filename, content) {
          this.filename = filename;
          this.content = content;
        }
        traceSegment(line, column, name) {
          return { column, line, name, source: this };
        }
      }
      const Url$1 = typeof URL !== "undefined" ? URL : require("url").URL;
      const parentRegex = /(^|\/)\.\.(?=\/|$)/g;
      function isAbsoluteUrl(url) {
        try {
          return !!new Url$1(url);
        } catch (e) {
          return false;
        }
      }
      function uniqInStr(str2) {
        let uniq = String(Math.random()).slice(2);
        while (str2.indexOf(uniq) > -1) {
          uniq += uniq;
        }
        return uniq;
      }
      function stripPathFilename(path2) {
        path2 = normalizePath(path2);
        const index2 = path2.lastIndexOf("/");
        return path2.slice(0, index2 + 1);
      }
      function normalizeProtocolRelative(input, absoluteBase) {
        const { href, protocol } = new Url$1(input, absoluteBase);
        return href.slice(protocol.length);
      }
      function normalizeSimplePath(input) {
        const { href } = new Url$1(input, "https://foo.com/");
        return href.slice("https://foo.com/".length);
      }
      function normalizePath(input) {
        if (!parentRegex.test(input))
          return normalizeSimplePath(input);
        let total = 1;
        while (parentRegex.test(input))
          total++;
        const uniqDirectory = `z${uniqInStr(input)}/`;
        const search = new RegExp(`^(?:${uniqDirectory})*`);
        const relative = normalizeSimplePath(uniqDirectory.repeat(total) + input);
        return relative.replace(search, (all) => {
          const leftover = all.length / uniqDirectory.length;
          return "../".repeat(total - leftover);
        });
      }
      function resolve2(input, base2) {
        if (!base2)
          base2 = "";
        if (isAbsoluteUrl(input))
          return new Url$1(input).href;
        if (base2) {
          if (isAbsoluteUrl(base2))
            return new Url$1(input, base2).href;
          if (base2.startsWith("//"))
            return normalizeProtocolRelative(input, `https:${base2}`);
        }
        if (input.startsWith("//"))
          return normalizeProtocolRelative(input, "https://foo.com/");
        if (input.startsWith("/"))
          return "/" + normalizeSimplePath(input);
        const joined = stripPathFilename(base2) + input;
        if (base2.startsWith("/"))
          return "/" + normalizeSimplePath(joined);
        const relative = normalizePath(joined);
        if ((base2 || input).startsWith(".") && !relative.startsWith(".")) {
          return "./" + relative;
        }
        return relative;
      }
      function resolve$1(input, base2) {
        if (base2 && !base2.endsWith("/"))
          base2 += "/";
        return resolve2(input, base2);
      }
      function binarySearch(haystack, needle, comparator) {
        let low = 0;
        let high = haystack.length - 1;
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = comparator(haystack[mid], needle);
          if (cmp === 0) {
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        return ~low;
      }
      class FastStringArray {
        constructor() {
          this.indexes = Object.create(null);
          this.array = [];
        }
        put(key) {
          const { array, indexes } = this;
          let index2 = indexes[key];
          if (index2 === void 0) {
            index2 = indexes[key] = array.length;
            array.push(key);
          }
          return index2;
        }
      }
      class SourceMapTree {
        constructor(map, sources) {
          this.map = map;
          this.sources = sources;
        }
        traceMappings() {
          const mappings = [];
          const names2 = new FastStringArray();
          const sources = new FastStringArray();
          const sourcesContent = [];
          const { mappings: rootMappings, names: rootNames } = this.map;
          for (let i2 = 0; i2 < rootMappings.length; i2++) {
            const segments = rootMappings[i2];
            const tracedSegments = [];
            for (let j = 0; j < segments.length; j++) {
              const segment = segments[j];
              if (segment.length === 1)
                continue;
              const source = this.sources[segment[1]];
              const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
              if (!traced)
                continue;
              const { column, line, name } = traced;
              const { content, filename } = traced.source;
              const sourceIndex = sources.put(filename);
              sourcesContent[sourceIndex] = content;
              if (name) {
                tracedSegments.push([segment[0], sourceIndex, line, column, names2.put(name)]);
              } else {
                tracedSegments.push([segment[0], sourceIndex, line, column]);
              }
            }
            mappings.push(tracedSegments);
          }
          return defaults({
            mappings,
            names: names2.array,
            sources: sources.array,
            sourcesContent
          }, this.map);
        }
        traceSegment(line, column, name) {
          const { mappings, names: names2 } = this.map;
          if (line >= mappings.length)
            return null;
          const segments = mappings[line];
          if (segments.length === 0)
            return null;
          let index2 = binarySearch(segments, column, segmentComparator$1);
          if (index2 === -1)
            return null;
          if (index2 < 0) {
            index2 = ~index2 - 1;
          }
          const segment = segments[index2];
          if (segment.length === 1)
            return null;
          const source = this.sources[segment[1]];
          return source.traceSegment(segment[2], segment[3], segment.length === 5 ? names2[segment[4]] : name);
        }
      }
      function segmentComparator$1(segment, column) {
        return segment[0] - column;
      }
      function stripFilename(path2) {
        if (!path2)
          return "";
        const index2 = path2.lastIndexOf("/");
        return path2.slice(0, index2 + 1);
      }
      function asArray(value2) {
        if (Array.isArray(value2))
          return value2;
        return [value2];
      }
      function buildSourceMapTree(input, loader, relativeRoot) {
        const maps = asArray(input).map(decodeSourceMap);
        const map = maps.pop();
        for (let i2 = 0; i2 < maps.length; i2++) {
          if (maps[i2].sources.length !== 1) {
            throw new Error(`Transformation map ${i2} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
          }
        }
        const { sourceRoot, sources, sourcesContent } = map;
        const children = sources.map((sourceFile, i2) => {
          const uri = resolve$1(sourceFile || "", resolve$1(sourceRoot || "", stripFilename(relativeRoot)));
          const sourceMap = loader(uri);
          if (!sourceMap) {
            const sourceContent = sourcesContent ? sourcesContent[i2] : null;
            return new OriginalSource(uri, sourceContent);
          }
          return buildSourceMapTree(decodeSourceMap(sourceMap), loader, uri);
        });
        let tree = new SourceMapTree(map, children);
        for (let i2 = maps.length - 1; i2 >= 0; i2--) {
          tree = new SourceMapTree(maps[i2], [tree]);
        }
        return tree;
      }
      class SourceMap {
        constructor(map, excludeContent) {
          this.version = 3;
          if ("file" in map)
            this.file = map.file;
          this.mappings = encode$1(map.mappings);
          this.names = map.names;
          this.sources = map.sources;
          if (!excludeContent && "sourcesContent" in map)
            this.sourcesContent = map.sourcesContent;
        }
        toString() {
          return JSON.stringify(this);
        }
      }
      function remapping(input, loader, excludeContent) {
        const graph = buildSourceMapTree(input, loader);
        return new SourceMap(graph.traceMappings(), !!excludeContent);
      }
      function last_line_length(s2) {
        return s2.length - s2.lastIndexOf("\n") - 1;
      }
      function sourcemap_add_offset(map, offset, source_index) {
        if (map.mappings.length == 0)
          return;
        for (let line = 0; line < map.mappings.length; line++) {
          const segment_list = map.mappings[line];
          for (let segment = 0; segment < segment_list.length; segment++) {
            const seg = segment_list[segment];
            if (seg[1] === source_index) {
              if (seg[2] === 0) {
                seg[3] += offset.column;
              }
              seg[2] += offset.line;
            }
          }
        }
      }
      function merge_tables(this_table, other_table) {
        const new_table = this_table.slice();
        const idx_map = [];
        other_table = other_table || [];
        let val_changed = false;
        for (const [other_idx, other_val] of other_table.entries()) {
          const this_idx = this_table.indexOf(other_val);
          if (this_idx >= 0) {
            idx_map[other_idx] = this_idx;
          } else {
            const new_idx = new_table.length;
            new_table[new_idx] = other_val;
            idx_map[other_idx] = new_idx;
            val_changed = true;
          }
        }
        let idx_changed = val_changed;
        if (val_changed) {
          if (idx_map.find((val, idx) => val != idx) === void 0) {
            idx_changed = false;
          }
        }
        return [new_table, idx_map, val_changed, idx_changed];
      }
      function pushArray(_this, other) {
        for (let i2 = 0; i2 < other.length; i2++) {
          _this.push(other[i2]);
        }
      }
      class MappedCode {
        constructor(string = "", map = null) {
          this.string = string;
          if (map) {
            this.map = map;
          } else {
            this.map = {
              version: 3,
              mappings: [],
              sources: [],
              names: []
            };
          }
        }
        concat(other) {
          if (other.string == "")
            return this;
          if (this.string == "") {
            this.string = other.string;
            this.map = other.map;
            return this;
          }
          const column_offset = last_line_length(this.string);
          this.string += other.string;
          const m1 = this.map;
          const m2 = other.map;
          if (m2.mappings.length == 0)
            return this;
          const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(m1.sources, m2.sources);
          const [names2, new_name_idx, names_changed, names_idx_changed] = merge_tables(m1.names, m2.names);
          if (sources_changed)
            m1.sources = sources;
          if (names_changed)
            m1.names = names2;
          if (sources_idx_changed && names_idx_changed) {
            for (let line = 0; line < m2.mappings.length; line++) {
              const segment_list = m2.mappings[line];
              for (let segment = 0; segment < segment_list.length; segment++) {
                const seg = segment_list[segment];
                if (seg[1] >= 0)
                  seg[1] = new_source_idx[seg[1]];
                if (seg[4] >= 0)
                  seg[4] = new_name_idx[seg[4]];
              }
            }
          } else if (sources_idx_changed) {
            for (let line = 0; line < m2.mappings.length; line++) {
              const segment_list = m2.mappings[line];
              for (let segment = 0; segment < segment_list.length; segment++) {
                const seg = segment_list[segment];
                if (seg[1] >= 0)
                  seg[1] = new_source_idx[seg[1]];
              }
            }
          } else if (names_idx_changed) {
            for (let line = 0; line < m2.mappings.length; line++) {
              const segment_list = m2.mappings[line];
              for (let segment = 0; segment < segment_list.length; segment++) {
                const seg = segment_list[segment];
                if (seg[4] >= 0)
                  seg[4] = new_name_idx[seg[4]];
              }
            }
          }
          if (m2.mappings.length > 0 && column_offset > 0) {
            const first_line = m2.mappings[0];
            for (let i2 = 0; i2 < first_line.length; i2++) {
              first_line[i2][0] += column_offset;
            }
          }
          pushArray(m1.mappings[m1.mappings.length - 1], m2.mappings.shift());
          pushArray(m1.mappings, m2.mappings);
          return this;
        }
        static from_processed(string, map) {
          const line_count = string.split("\n").length;
          if (map) {
            const missing_lines = line_count - map.mappings.length;
            for (let i2 = 0; i2 < missing_lines; i2++) {
              map.mappings.push([]);
            }
            return new MappedCode(string, map);
          }
          if (string == "")
            return new MappedCode();
          map = { version: 3, names: [], sources: [], mappings: [] };
          for (let i2 = 0; i2 < line_count; i2++)
            map.mappings.push([]);
          return new MappedCode(string, map);
        }
        static from_source({ source, file_basename, get_location }) {
          let offset = get_location(0);
          if (!offset)
            offset = { line: 0, column: 0 };
          const map = { version: 3, names: [], sources: [file_basename], mappings: [] };
          if (source == "")
            return new MappedCode(source, map);
          const line_list = source.split("\n");
          for (let line = 0; line < line_list.length; line++) {
            map.mappings.push([]);
            const token_list = line_list[line].split(/([^\d\w\s]|\s+)/g);
            for (let token = 0, column = 0; token < token_list.length; token++) {
              if (token_list[token] == "")
                continue;
              map.mappings[line].push([column, 0, offset.line + line, column]);
              column += token_list[token].length;
            }
          }
          const segment_list = map.mappings[0];
          for (let segment = 0; segment < segment_list.length; segment++) {
            segment_list[segment][3] += offset.column;
          }
          return new MappedCode(source, map);
        }
      }
      function combine_sourcemaps(filename, sourcemap_list) {
        if (sourcemap_list.length == 0)
          return null;
        let map_idx = 1;
        const map = sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === void 0 ? remapping(sourcemap_list, () => null, true) : remapping(sourcemap_list[0], function loader(sourcefile) {
          if (sourcefile === filename && sourcemap_list[map_idx]) {
            return sourcemap_list[map_idx++];
          } else {
            return null;
          }
        }, true);
        if (!map.file)
          delete map.file;
        if (!map.sources.length)
          map.sources = [filename];
        return map;
      }
      const b64enc = typeof btoa == "function" ? btoa : (b2) => Buffer.from(b2).toString("base64");
      const b64dec = typeof atob == "function" ? atob : (a) => Buffer.from(a, "base64").toString();
      function apply_preprocessor_sourcemap(filename, svelte_map, preprocessor_map_input) {
        if (!svelte_map || !preprocessor_map_input)
          return svelte_map;
        const preprocessor_map = typeof preprocessor_map_input === "string" ? JSON.parse(preprocessor_map_input) : preprocessor_map_input;
        const result_map = combine_sourcemaps(filename, [
          svelte_map,
          preprocessor_map
        ]);
        Object.defineProperties(result_map, {
          toString: {
            enumerable: false,
            value: function toString2() {
              return JSON.stringify(this);
            }
          },
          toUrl: {
            enumerable: false,
            value: function toUrl() {
              return "data:application/json;charset=utf-8;base64," + b64enc(this.toString());
            }
          }
        });
        return result_map;
      }
      function parse_attached_sourcemap(processed, tag_name) {
        const r_in = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)";
        const regex = tag_name == "script" ? new RegExp("(?://" + r_in + ")|(?:/\\*" + r_in + "\\s*\\*/)$") : new RegExp("/\\*" + r_in + "\\s*\\*/$");
        function log_warning(message) {
          const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + " [...]";
          console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
        }
        processed.code = processed.code.replace(regex, (_, match1, match2) => {
          const map_url = tag_name == "script" ? match1 || match2 : match1;
          const map_data = (map_url.match(/data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/) || [])[1];
          if (map_data) {
            if (processed.map) {
              log_warning("Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap.");
              return "";
            }
            processed.map = b64dec(map_data);
            return "";
          }
          if (!processed.map) {
            log_warning(`Found sourcemap path ${JSON.stringify(map_url)} in processed.code, but no sourcemap data. Please update your preprocessor to return sourcemap data directly.`);
          }
          return "";
        });
      }
      function dom(component, options3) {
        const { name } = component;
        const renderer = new Renderer(component, options3);
        const { block } = renderer;
        block.has_outro_method = true;
        if (options3.customElement)
          block.chunks.create.push(b`this.c = @noop;`);
        const body = [];
        if (renderer.file_var) {
          const file = component.file ? x`"${component.file}"` : x`undefined`;
          body.push(b`const ${renderer.file_var} = ${file};`);
        }
        const css2 = component.stylesheet.render(options3.filename, !options3.customElement);
        css2.map = apply_preprocessor_sourcemap(options3.filename, css2.map, options3.sourcemap);
        const styles = component.stylesheet.has_styles && options3.dev ? `${css2.code}
/*# sourceMappingURL=${css2.map.toUrl()} */` : css2.code;
        const add_css = component.get_unique_name("add_css");
        const should_add_css = !options3.customElement && !!styles && options3.css !== false;
        if (should_add_css) {
          body.push(b`
			function ${add_css}(target) {
				@append_styles(target, "${component.stylesheet.id}", "${styles}");
			}
		`);
        }
        const blocks = renderer.blocks.slice().reverse();
        body.push(...blocks.map((block2) => {
          if (block2.render)
            return block2.render();
          return block2;
        }));
        if (options3.dev && !options3.hydratable) {
          block.chunks.claim.push(b`throw new @_Error("options.hydrate only works if the component was compiled with the \`hydratable: true\` option");`);
        }
        const uses_slots = component.var_lookup.has("$$slots");
        let compute_slots;
        if (uses_slots) {
          compute_slots = b`
			const $$slots = @compute_slots(#slots);
		`;
        }
        const uses_props = component.var_lookup.has("$$props");
        const uses_rest = component.var_lookup.has("$$restProps");
        const $$props = uses_props || uses_rest ? "$$new_props" : "$$props";
        const props = component.vars.filter((variable) => !variable.module && variable.export_name);
        const writable_props = props.filter((variable) => variable.writable);
        const omit_props_names = component.get_unique_name("omit_props_names");
        const compute_rest = x`@compute_rest_props($$props, ${omit_props_names.name})`;
        const rest = uses_rest ? b`
		const ${omit_props_names.name} = [${props.map((prop) => `"${prop.export_name}"`).join(",")}];
		let $$restProps = ${compute_rest};
	` : null;
        const set = uses_props || uses_rest || writable_props.length > 0 || component.slots.size > 0 ? x`
			${$$props} => {
				${uses_props && renderer.invalidate("$$props", x`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`)}
				${uses_rest && !uses_props && x`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`}
				${uses_rest && renderer.invalidate("$$restProps", x`$$restProps = ${compute_rest}`)}
				${writable_props.map((prop) => b`if ('${prop.export_name}' in ${$$props}) ${renderer.invalidate(prop.name, x`${prop.name} = ${$$props}.${prop.export_name}`)};`)}
				${component.slots.size > 0 && b`if ('$$scope' in ${$$props}) ${renderer.invalidate("$$scope", x`$$scope = ${$$props}.$$scope`)};`}
			}
		` : null;
        const accessors = [];
        const not_equal = component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
        let dev_props_check;
        let inject_state;
        let capture_state;
        let props_inject;
        props.forEach((prop) => {
          const variable = component.var_lookup.get(prop.name);
          if (!variable.writable || component.component_options.accessors) {
            accessors.push({
              type: "MethodDefinition",
              kind: "get",
              key: { type: "Identifier", name: prop.export_name },
              value: x`function() {
					return ${prop.hoistable ? prop.name : x`this.$$.ctx[${renderer.context_lookup.get(prop.name).index}]`}
				}`
            });
          } else if (component.compile_options.dev) {
            accessors.push({
              type: "MethodDefinition",
              kind: "get",
              key: { type: "Identifier", name: prop.export_name },
              value: x`function() {
					throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
            });
          }
          if (component.component_options.accessors) {
            if (variable.writable && !renderer.readonly.has(prop.name)) {
              accessors.push({
                type: "MethodDefinition",
                kind: "set",
                key: { type: "Identifier", name: prop.export_name },
                value: x`function(${prop.name}) {
						this.$$set({ ${prop.export_name}: ${prop.name} });
						@flush();
					}`
              });
            } else if (component.compile_options.dev) {
              accessors.push({
                type: "MethodDefinition",
                kind: "set",
                key: { type: "Identifier", name: prop.export_name },
                value: x`function(value) {
						throw new @_Error("<${component.tag}>: Cannot set read-only property '${prop.export_name}'");
					}`
              });
            }
          } else if (component.compile_options.dev) {
            accessors.push({
              type: "MethodDefinition",
              kind: "set",
              key: { type: "Identifier", name: prop.export_name },
              value: x`function(value) {
					throw new @_Error("<${component.tag}>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
            });
          }
        });
        component.instance_exports_from.forEach((exports_from) => {
          const import_declaration = Object.assign(Object.assign({}, exports_from), { type: "ImportDeclaration", specifiers: [], source: exports_from.source });
          component.imports.push(import_declaration);
          exports_from.specifiers.forEach((specifier) => {
            if (component.component_options.accessors) {
              const name2 = component.get_unique_name(specifier.exported.name);
              import_declaration.specifiers.push(Object.assign(Object.assign({}, specifier), { type: "ImportSpecifier", imported: specifier.local, local: name2 }));
              accessors.push({
                type: "MethodDefinition",
                kind: "get",
                key: { type: "Identifier", name: specifier.exported.name },
                value: x`function() {
						return ${name2}
					}`
              });
            } else if (component.compile_options.dev) {
              accessors.push({
                type: "MethodDefinition",
                kind: "get",
                key: { type: "Identifier", name: specifier.exported.name },
                value: x`function() {
						throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
					}`
              });
            }
          });
        });
        if (component.compile_options.dev) {
          const expected = props.filter((prop) => prop.writable && !prop.initialised);
          if (expected.length) {
            dev_props_check = b`
				const { ctx: #ctx } = this.$$;
				const props = ${options3.customElement ? x`this.attributes` : x`options.props || {}`};
				${expected.map((prop) => b`
				if (${renderer.reference(prop.name)} === undefined && !('${prop.export_name}' in props)) {
					@_console.warn("<${component.tag}> was created without expected prop '${prop.export_name}'");
				}`)}
			`;
          }
          const capturable_vars = component.vars.filter((v) => !v.internal && !v.global && !v.name.startsWith("$$"));
          if (capturable_vars.length > 0) {
            capture_state = x`() => ({ ${capturable_vars.map((prop) => p`${prop.name}`)} })`;
          }
          const injectable_vars = capturable_vars.filter((v) => !v.module && v.writable && v.name[0] !== "$");
          if (uses_props || injectable_vars.length > 0) {
            inject_state = x`
				${$$props} => {
					${uses_props && renderer.invalidate("$$props", x`$$props = @assign(@assign({}, $$props), $$new_props)`)}
					${injectable_vars.map((v) => b`if ('${v.name}' in $$props) ${renderer.invalidate(v.name, x`${v.name} = ${$$props}.${v.name}`)};`)}
				}
			`;
            props_inject = b`
				if ($$props && "$$inject" in $$props) {
					$$self.$inject_state($$props.$$inject);
				}
			`;
          }
        }
        if (component.ast.instance) {
          let scope2 = component.instance_scope;
          const map = component.instance_scope_map;
          let execution_context = null;
          walk(component.ast.instance.content, {
            enter(node2) {
              if (map.has(node2)) {
                scope2 = map.get(node2);
                if (!execution_context && !scope2.block) {
                  execution_context = node2;
                }
              } else if (!execution_context && node2.type === "LabeledStatement" && node2.label.name === "$") {
                execution_context = node2;
              }
            },
            leave(node2) {
              if (map.has(node2)) {
                scope2 = scope2.parent;
              }
              if (execution_context === node2) {
                execution_context = null;
              }
              if (node2.type === "AssignmentExpression" || node2.type === "UpdateExpression") {
                const assignee = node2.type === "AssignmentExpression" ? node2.left : node2.argument;
                const names2 = new Set(extract_names(assignee));
                this.replace(invalidate(renderer, scope2, node2, names2, execution_context === null));
              }
            }
          });
          component.rewrite_props(({ name: name2, reassigned, export_name }) => {
            const value2 = `$${name2}`;
            const i2 = renderer.context_lookup.get(`$${name2}`).index;
            const insert = reassigned || export_name ? b`${`$$subscribe_${name2}`}()` : b`@component_subscribe($$self, ${name2}, #value => $$invalidate(${i2}, ${value2} = #value))`;
            if (component.compile_options.dev) {
              return b`@validate_store(${name2}, '${name2}'); ${insert}`;
            }
            return insert;
          });
        }
        const args = [x`$$self`];
        const has_invalidate = props.length > 0 || component.has_reactive_assignments || component.slots.size > 0 || capture_state || inject_state;
        if (has_invalidate) {
          args.push(x`$$props`, x`$$invalidate`);
        } else if (component.compile_options.dev) {
          args.push(x`$$props`);
        }
        const has_create_fragment = component.compile_options.dev || block.has_content();
        if (has_create_fragment) {
          body.push(b`
			function create_fragment(#ctx) {
				${block.get_contents()}
			}
		`);
        }
        body.push(b`
		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}
	`);
        const filtered_props = props.filter((prop) => {
          const variable = component.var_lookup.get(prop.name);
          if (variable.hoistable)
            return false;
          return prop.name[0] !== "$";
        });
        const reactive_stores = component.vars.filter((variable) => variable.name[0] === "$" && variable.name[1] !== "$");
        const instance_javascript = component.extract_javascript(component.ast.instance);
        const has_definition = component.compile_options.dev || instance_javascript && instance_javascript.length > 0 || filtered_props.length > 0 || uses_props || component.partly_hoisted.length > 0 || renderer.initial_context.length > 0 || component.reactive_declarations.length > 0 || capture_state || inject_state;
        const definition = has_definition ? component.alias("instance") : { type: "Literal", value: null };
        const reactive_store_subscriptions = reactive_stores.filter((store) => {
          const variable = component.var_lookup.get(store.name.slice(1));
          return !variable || variable.hoistable;
        }).map(({ name: name2 }) => b`
			${component.compile_options.dev && b`@validate_store(${name2.slice(1)}, '${name2.slice(1)}');`}
			@component_subscribe($$self, ${name2.slice(1)}, $$value => $$invalidate(${renderer.context_lookup.get(name2).index}, ${name2} = $$value));
		`);
        const resubscribable_reactive_store_unsubscribers = reactive_stores.filter((store) => {
          const variable = component.var_lookup.get(store.name.slice(1));
          return variable && (variable.reassigned || variable.export_name);
        }).map(({ name: name2 }) => b`$$self.$$.on_destroy.push(() => ${`$$unsubscribe_${name2.slice(1)}`}());`);
        if (has_definition) {
          const reactive_declarations = [];
          const fixed_reactive_declarations = [];
          component.reactive_declarations.forEach((d2) => {
            const dependencies = Array.from(d2.dependencies);
            const uses_rest_or_props = !!dependencies.find((n2) => n2 === "$$props" || n2 === "$$restProps");
            const writable2 = dependencies.filter((n2) => {
              const variable = component.var_lookup.get(n2);
              return variable && (variable.export_name || variable.mutated || variable.reassigned);
            });
            const condition = !uses_rest_or_props && writable2.length > 0 && renderer.dirty(writable2, true);
            let statement = d2.node;
            if (condition)
              statement = b`if (${condition}) { ${statement} }`[0];
            if (condition || uses_rest_or_props) {
              reactive_declarations.push(statement);
            } else {
              fixed_reactive_declarations.push(statement);
            }
          });
          const injected = Array.from(component.injected_reactive_declaration_vars).filter((name2) => {
            const variable = component.var_lookup.get(name2);
            return variable.injected && variable.name[0] !== "$";
          });
          const reactive_store_declarations = reactive_stores.map((variable) => {
            const $name = variable.name;
            const name2 = $name.slice(1);
            const store = component.var_lookup.get(name2);
            if (store && (store.reassigned || store.export_name)) {
              const unsubscribe = `$$unsubscribe_${name2}`;
              const subscribe = `$$subscribe_${name2}`;
              const i2 = renderer.context_lookup.get($name).index;
              return b`let ${$name}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${name2}, $$value => $$invalidate(${i2}, ${$name} = $$value)), ${name2})`;
            }
            return b`let ${$name};`;
          });
          let unknown_props_check;
          if (component.compile_options.dev && !(uses_props || uses_rest)) {
            unknown_props_check = b`
				const writable_props = [${writable_props.map((prop) => x`'${prop.export_name}'`)}];
				@_Object.keys($$props).forEach(key => {
					if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') @_console.warn(\`<${component.tag}> was created with unknown prop '\${key}'\`);
				});
			`;
          }
          const return_value = {
            type: "ArrayExpression",
            elements: renderer.initial_context.map((member) => ({
              type: "Identifier",
              name: member.name
            }))
          };
          body.push(b`
			function ${definition}(${args}) {
				${injected.map((name2) => b`let ${name2};`)}

				${rest}

				${reactive_store_declarations}

				${reactive_store_subscriptions}

				${resubscribable_reactive_store_unsubscribers}

				${component.slots.size || component.compile_options.dev || uses_slots ? b`let { $$slots: #slots = {}, $$scope } = $$props;` : null}
				${component.compile_options.dev && b`@validate_slots('${component.tag}', #slots, [${[...component.slots.keys()].map((key) => `'${key}'`).join(",")}]);`}
				${compute_slots}

				${instance_javascript}

				${unknown_props_check}

				${renderer.binding_groups.size > 0 && b`const $$binding_groups = [${[...renderer.binding_groups.keys()].map((_) => x`[]`)}];`}

				${component.partly_hoisted}

				${set && b`$$self.$$set = ${set};`}

				${capture_state && b`$$self.$capture_state = ${capture_state};`}

				${inject_state && b`$$self.$inject_state = ${inject_state};`}

				${props_inject}

				${reactive_declarations.length > 0 && b`
				$$self.$$.update = () => {
					${reactive_declarations}
				};
				`}

				${fixed_reactive_declarations}

				${uses_props && b`$$props = @exclude_internal_props($$props);`}

				return ${return_value};
			}
		`);
        }
        const prop_indexes = x`{
		${props.filter((v) => v.export_name && !v.module).map((v) => p`${v.export_name}: ${renderer.context_lookup.get(v.name).index}`)}
	}`;
        let dirty;
        if (renderer.context_overflow) {
          dirty = x`[]`;
          for (let i2 = 0; i2 < renderer.context.length; i2 += 31) {
            dirty.elements.push(x`-1`);
          }
        }
        if (options3.customElement) {
          let init_props = x`@attribute_to_object(this.attributes)`;
          if (uses_slots) {
            init_props = x`{ ...${init_props}, $$slots: @get_custom_elements_slots(this) }`;
          }
          const declaration = b`
			class ${name} extends @SvelteElement {
				constructor(options) {
					super();

					${css2.code && b`this.shadowRoot.innerHTML = \`<style>${css2.code.replace(/\\/g, "\\\\")}${options3.dev ? `
/*# sourceMappingURL=${css2.map.toUrl()} */` : ""}</style>\`;`}

					@init(this, { target: this.shadowRoot, props: ${init_props}, customElement: true }, ${definition}, ${has_create_fragment ? "create_fragment" : "null"}, ${not_equal}, ${prop_indexes}, null, ${dirty});

					${dev_props_check}

					if (options) {
						if (options.target) {
							@insert(options.target, this, options.anchor);
						}

						${(props.length > 0 || uses_props || uses_rest) && b`
						if (options.props) {
							this.$set(options.props);
							@flush();
						}`}
					}
				}
			}
		`[0];
          if (props.length > 0) {
            declaration.body.body.push({
              type: "MethodDefinition",
              kind: "get",
              static: true,
              computed: false,
              key: { type: "Identifier", name: "observedAttributes" },
              value: x`function() {
					return [${props.map((prop) => x`"${prop.export_name}"`)}];
				}`
            });
          }
          declaration.body.body.push(...accessors);
          body.push(declaration);
          if (component.tag != null) {
            body.push(b`
				@_customElements.define("${component.tag}", ${name});
			`);
          }
        } else {
          const superclass = {
            type: "Identifier",
            name: options3.dev ? "@SvelteComponentDev" : "@SvelteComponent"
          };
          const optional_parameters = [];
          if (should_add_css) {
            optional_parameters.push(add_css);
          } else if (dirty) {
            optional_parameters.push(x`null`);
          }
          if (dirty) {
            optional_parameters.push(dirty);
          }
          const declaration = b`
			class ${name} extends ${superclass} {
				constructor(options) {
					super(${options3.dev && "options"});
					@init(this, options, ${definition}, ${has_create_fragment ? "create_fragment" : "null"}, ${not_equal}, ${prop_indexes}, ${optional_parameters});
					${options3.dev && b`@dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "${name.name}", options, id: create_fragment.name });`}

					${dev_props_check}
				}
			}
		`[0];
          declaration.body.body.push(...accessors);
          body.push(declaration);
        }
        return { js: flatten$1(body), css: css2 };
      }
      function AwaitBlock(node2, renderer, options3) {
        renderer.push();
        renderer.render(node2.pending.children, options3);
        const pending = renderer.pop();
        renderer.push();
        renderer.render(node2.then.children, options3);
        const then = renderer.pop();
        renderer.add_expression(x`
		function(__value) {
			if (@is_promise(__value)) return ${pending};
			return (function(${node2.then_node ? node2.then_node : ""}) { return ${then}; }(__value));
		}(${node2.expression.node})
	`);
      }
      function Comment$1(node2, renderer, options3) {
        if (options3.preserveComments) {
          renderer.add_string(`<!--${node2.data}-->`);
        }
      }
      function DebugTag(node2, renderer, options3) {
        if (!options3.dev)
          return;
        const filename = options3.filename || null;
        const { line, column } = options3.locate(node2.start + 1);
        const obj = x`{
		${node2.expressions.map((e) => p`${e.node.name}`)}
	}`;
        renderer.add_expression(x`@debug(${filename ? x`"${filename}"` : x`null`}, ${line - 1}, ${column}, ${obj})`);
      }
      function EachBlock(node2, renderer, options3) {
        const args = [node2.context_node];
        if (node2.index)
          args.push({ type: "Identifier", name: node2.index });
        renderer.push();
        renderer.render(node2.children, options3);
        const result = renderer.pop();
        const consequent = x`@each(${node2.expression.node}, (${args}) => ${result})`;
        if (node2.else) {
          renderer.push();
          renderer.render(node2.else.children, options3);
          const alternate = renderer.pop();
          renderer.add_expression(x`${node2.expression.node}.length ? ${consequent} : ${alternate}`);
        } else {
          renderer.add_expression(consequent);
        }
      }
      function get_class_attribute_value(attribute) {
        if (attribute.chunks.length === 2 && attribute.chunks[1].synthetic) {
          const value2 = attribute.chunks[0].node;
          return x`@escape(@null_to_empty(${value2})) + "${attribute.chunks[1].data}"`;
        }
        return get_attribute_value(attribute);
      }
      function get_attribute_value(attribute) {
        if (attribute.chunks.length === 0)
          return x`""`;
        return attribute.chunks.map((chunk) => {
          return chunk.type === "Text" ? string_literal(chunk.data.replace(/"/g, "&quot;")) : x`@escape(${chunk.node})`;
        }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
      }
      function get_attribute_expression(attribute) {
        if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Expression") {
          return attribute.chunks[0].node;
        }
        return get_attribute_value(attribute);
      }
      const boolean_attributes = new Set([
        "allowfullscreen",
        "allowpaymentrequest",
        "async",
        "autofocus",
        "autoplay",
        "checked",
        "controls",
        "default",
        "defer",
        "disabled",
        "formnovalidate",
        "hidden",
        "ismap",
        "loop",
        "multiple",
        "muted",
        "nomodule",
        "novalidate",
        "open",
        "playsinline",
        "readonly",
        "required",
        "reversed",
        "selected"
      ]);
      function remove_whitespace_children(children, next) {
        const nodes = [];
        let last_child;
        let i2 = children.length;
        while (i2--) {
          const child = children[i2];
          if (child.type === "Text") {
            if (child.should_skip()) {
              continue;
            }
            let { data: data2 } = child;
            if (nodes.length === 0) {
              const should_trim = next ? next.type === "Text" && /^\s/.test(next.data) && trimmable_at$1(child, next) : !child.has_ancestor("EachBlock");
              if (should_trim) {
                data2 = trim_end(data2);
                if (!data2)
                  continue;
              }
            }
            if (last_child && last_child.type === "Text") {
              last_child.data = data2 + last_child.data;
              continue;
            }
            nodes.unshift(child);
            link(last_child, last_child = child);
          } else {
            nodes.unshift(child);
            link(last_child, last_child = child);
          }
        }
        const first = nodes[0];
        if (first && first.type === "Text") {
          first.data = trim_start(first.data);
          if (!first.data) {
            first.var = null;
            nodes.shift();
            if (nodes[0]) {
              nodes[0].prev = null;
            }
          }
        }
        return nodes;
      }
      function trimmable_at$1(child, next_sibling) {
        return next_sibling.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.prev.type === "EachBlock";
      }
      function Element2(node2, renderer, options3) {
        const children = remove_whitespace_children(node2.children, node2.next);
        let node_contents;
        const contenteditable = node2.name !== "textarea" && node2.name !== "input" && node2.attributes.some((attribute) => attribute.name === "contenteditable");
        renderer.add_string(`<${node2.name}`);
        const class_expression_list = node2.classes.map((class_directive) => {
          const { expression: expression2, name } = class_directive;
          const snippet = expression2 ? expression2.node : x`#ctx.${name}`;
          return x`${snippet} ? "${name}" : ""`;
        });
        if (node2.needs_manual_style_scoping) {
          class_expression_list.push(x`"${node2.component.stylesheet.id}"`);
        }
        const class_expression = class_expression_list.length > 0 && class_expression_list.reduce((lhs, rhs) => x`${lhs} + ' ' + ${rhs}`);
        if (node2.attributes.some((attr) => attr.is_spread)) {
          const args = [];
          node2.attributes.forEach((attribute) => {
            if (attribute.is_spread) {
              args.push(x`@escape_object(${attribute.expression.node})`);
            } else {
              const attr_name = node2.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
              const name = attribute.name.toLowerCase();
              if (name === "value" && node2.name.toLowerCase() === "textarea") {
                node_contents = get_attribute_value(attribute);
              } else if (attribute.is_true) {
                args.push(x`{ ${attr_name}: true }`);
              } else if (boolean_attributes.has(name) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
                args.push(x`{ ${attr_name}: ${attribute.chunks[0].node} || null }`);
              } else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
                const snippet = attribute.chunks[0].node;
                args.push(x`{ ${attr_name}: @escape_attribute_value(${snippet}) }`);
              } else {
                args.push(x`{ ${attr_name}: ${get_attribute_value(attribute)} }`);
              }
            }
          });
          renderer.add_expression(x`@spread([${args}], ${class_expression})`);
        } else {
          let add_class_attribute = !!class_expression;
          node2.attributes.forEach((attribute) => {
            const name = attribute.name.toLowerCase();
            const attr_name = node2.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
            if (name === "value" && node2.name.toLowerCase() === "textarea") {
              node_contents = get_attribute_value(attribute);
            } else if (attribute.is_true) {
              renderer.add_string(` ${attr_name}`);
            } else if (boolean_attributes.has(name) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
              renderer.add_string(" ");
              renderer.add_expression(x`${attribute.chunks[0].node} ? "${attr_name}" : ""`);
            } else if (name === "class" && class_expression) {
              add_class_attribute = false;
              renderer.add_string(` ${attr_name}="`);
              renderer.add_expression(x`[${get_class_attribute_value(attribute)}, ${class_expression}].join(' ').trim()`);
              renderer.add_string('"');
            } else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
              const snippet = attribute.chunks[0].node;
              renderer.add_expression(x`@add_attribute("${attr_name}", ${snippet}, ${boolean_attributes.has(name) ? 1 : 0})`);
            } else {
              renderer.add_string(` ${attr_name}="`);
              renderer.add_expression((name === "class" ? get_class_attribute_value : get_attribute_value)(attribute));
              renderer.add_string('"');
            }
          });
          if (add_class_attribute) {
            renderer.add_expression(x`@add_classes([${class_expression}].join(' ').trim())`);
          }
        }
        node2.bindings.forEach((binding) => {
          const { name, expression: expression2 } = binding;
          if (binding.is_readonly) {
            return;
          }
          if (name === "group") {
            const value_attribute = node2.attributes.find(({ name: name2 }) => name2 === "value");
            if (value_attribute) {
              const value2 = get_attribute_expression(value_attribute);
              const type = node2.get_static_attribute_value("type");
              const bound = expression2.node;
              const condition = type === "checkbox" ? x`~${bound}.indexOf(${value2})` : x`${value2} === ${bound}`;
              renderer.add_expression(x`${condition} ? @add_attribute("checked", true, 1) : ""`);
            }
          } else if (contenteditable && (name === "textContent" || name === "innerHTML")) {
            node_contents = expression2.node;
          } else if (binding.name === "value" && node2.name === "textarea") {
            const snippet = expression2.node;
            node_contents = x`${snippet} || ""`;
          } else if (binding.name === "value" && node2.name === "select")
            ;
          else {
            const snippet = expression2.node;
            renderer.add_expression(x`@add_attribute("${name}", ${snippet}, ${boolean_attributes.has(name) ? 1 : 0})`);
          }
        });
        if (options3.hydratable && options3.head_id) {
          renderer.add_string(` data-svelte="${options3.head_id}"`);
        }
        renderer.add_string(">");
        if (node_contents !== void 0) {
          if (contenteditable) {
            renderer.push();
            renderer.render(children, options3);
            const result = renderer.pop();
            renderer.add_expression(x`($$value => $$value === void 0 ? ${result} : $$value)(${node_contents})`);
          } else {
            renderer.add_expression(node_contents);
          }
          if (!is_void(node2.name)) {
            renderer.add_string(`</${node2.name}>`);
          }
        } else {
          renderer.render(children, options3);
          if (!is_void(node2.name)) {
            renderer.add_string(`</${node2.name}>`);
          }
        }
      }
      function Head(node2, renderer, options3) {
        const head_options = Object.assign(Object.assign({}, options3), { head_id: node2.id });
        renderer.push();
        renderer.render(node2.children, head_options);
        const result = renderer.pop();
        renderer.add_expression(x`$$result.head += ${result}, ""`);
      }
      function HtmlTag(node2, renderer, options3) {
        if (options3.hydratable)
          renderer.add_string("<!-- HTML_TAG_START -->");
        renderer.add_expression(node2.expression.node);
        if (options3.hydratable)
          renderer.add_string("<!-- HTML_TAG_END -->");
      }
      function IfBlock(node2, renderer, options3) {
        const condition = node2.expression.node;
        renderer.push();
        renderer.render(node2.children, options3);
        const consequent = renderer.pop();
        renderer.push();
        if (node2.else)
          renderer.render(node2.else.children, options3);
        const alternate = renderer.pop();
        renderer.add_expression(x`${condition} ? ${consequent} : ${alternate}`);
      }
      function get_prop_value(attribute) {
        if (attribute.is_true)
          return x`true`;
        if (attribute.chunks.length === 0)
          return x`''`;
        return attribute.chunks.map((chunk) => {
          if (chunk.type === "Text")
            return string_literal(chunk.data);
          return chunk.node;
        }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
      }
      function InlineComponent(node2, renderer, options3) {
        const binding_props = [];
        const binding_fns = [];
        node2.bindings.forEach((binding) => {
          renderer.has_bindings = true;
          const snippet = binding.expression.node;
          binding_props.push(p`${binding.name}: ${snippet}`);
          binding_fns.push(p`${binding.name}: $$value => { ${snippet} = $$value; $$settled = false }`);
        });
        const uses_spread = node2.attributes.find((attr) => attr.is_spread);
        let props;
        if (uses_spread) {
          props = x`@_Object.assign(${node2.attributes.map((attribute) => {
            if (attribute.is_spread) {
              return attribute.expression.node;
            } else {
              return x`{ ${attribute.name}: ${get_prop_value(attribute)} }`;
            }
          }).concat(binding_props.map((p2) => x`{ ${p2} }`))})`;
        } else {
          props = x`{
			${node2.attributes.map((attribute) => p`${attribute.name}: ${get_prop_value(attribute)}`)},
			${binding_props}
		}`;
        }
        const bindings = x`{
		${binding_fns}
	}`;
        const expression2 = node2.name === "svelte:self" ? renderer.name : node2.name === "svelte:component" ? x`(${node2.expression.node}) || @missing_component` : node2.name.split(".").reduce((lhs, rhs) => x`${lhs}.${rhs}`);
        const slot_fns = [];
        const children = node2.children;
        if (children.length) {
          const slot_scopes = new Map();
          renderer.render(children, Object.assign({}, options3, {
            slot_scopes
          }));
          slot_scopes.forEach(({ input, output }, name) => {
            slot_fns.push(p`${name}: (${input}) => ${output}`);
          });
        }
        const slots = x`{
		${slot_fns}
	}`;
        if (node2.css_custom_properties.length > 0) {
          renderer.add_string('<div style="display: contents;');
          node2.css_custom_properties.forEach((attr) => {
            renderer.add_string(` ${attr.name}:`);
            renderer.add_expression(get_attribute_value(attr));
            renderer.add_string(";");
          });
          renderer.add_string('">');
        }
        renderer.add_expression(x`@validate_component(${expression2}, "${node2.name}").$$render($$result, ${props}, ${bindings}, ${slots})`);
        if (node2.css_custom_properties.length > 0) {
          renderer.add_string("</div>");
        }
      }
      function KeyBlock(node2, renderer, options3) {
        renderer.render(node2.children, options3);
      }
      function get_slot_scope(lets) {
        if (lets.length === 0)
          return null;
        return {
          type: "ObjectPattern",
          properties: lets.map((l) => {
            return {
              type: "Property",
              kind: "init",
              method: false,
              shorthand: false,
              computed: false,
              key: l.name,
              value: l.value || l.name
            };
          })
        };
      }
      function Slot(node2, renderer, options3) {
        const slot_data = get_slot_data(node2.values);
        const slot = node2.get_static_attribute_value("slot");
        const nearest_inline_component = node2.find_nearest(/InlineComponent/);
        if (slot && nearest_inline_component) {
          renderer.push();
        }
        renderer.push();
        renderer.render(node2.children, options3);
        const result = renderer.pop();
        renderer.add_expression(x`
		#slots.${node2.slot_name}
			? #slots.${node2.slot_name}(${slot_data})
			: ${result}
	`);
        if (slot && nearest_inline_component) {
          const lets = node2.lets;
          const seen = new Set(lets.map((l) => l.name.name));
          nearest_inline_component.lets.forEach((l) => {
            if (!seen.has(l.name.name))
              lets.push(l);
          });
          options3.slot_scopes.set(slot, {
            input: get_slot_scope(node2.lets),
            output: renderer.pop()
          });
        }
      }
      class AbstractBlock extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
        }
        warn_if_empty_block() {
          if (!this.children || this.children.length > 1)
            return;
          const child = this.children[0];
          if (!child || child.type === "Text" && !/[^ \r\n\f\v\t]/.test(child.data)) {
            this.component.warn(this, compiler_warnings.empty_block);
          }
        }
      }
      class PendingBlock extends AbstractBlock {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.children = map_children(component, parent, scope2, info.children);
          if (!info.skip) {
            this.warn_if_empty_block();
          }
        }
      }
      class ThenBlock extends AbstractBlock {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.scope = scope2.child();
          if (parent.then_node) {
            parent.then_contexts.forEach((context) => {
              this.scope.add(context.key.name, parent.expression.dependencies, this);
            });
          }
          this.children = map_children(component, parent, this.scope, info.children);
          if (!info.skip) {
            this.warn_if_empty_block();
          }
        }
      }
      class CatchBlock extends AbstractBlock {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.scope = scope2.child();
          if (parent.catch_node) {
            parent.catch_contexts.forEach((context) => {
              this.scope.add(context.key.name, parent.expression.dependencies, this);
            });
          }
          this.children = map_children(component, parent, this.scope, info.children);
          if (!info.skip) {
            this.warn_if_empty_block();
          }
        }
      }
      function unpack_destructuring(contexts, node2, modifier = (node3) => node3, default_modifier = (node3) => node3) {
        if (!node2)
          return;
        if (node2.type === "Identifier") {
          contexts.push({
            key: node2,
            modifier,
            default_modifier
          });
        } else if (node2.type === "RestElement") {
          contexts.push({
            key: node2.argument,
            modifier,
            default_modifier
          });
        } else if (node2.type === "ArrayPattern") {
          node2.elements.forEach((element, i2) => {
            if (element && element.type === "RestElement") {
              unpack_destructuring(contexts, element, (node3) => x`${modifier(node3)}.slice(${i2})`, default_modifier);
            } else if (element && element.type === "AssignmentPattern") {
              const n2 = contexts.length;
              unpack_destructuring(contexts, element.left, (node3) => x`${modifier(node3)}[${i2}]`, (node3, to_ctx) => x`${node3} !== undefined ? ${node3} : ${update_reference(contexts, n2, element.right, to_ctx)}`);
            } else {
              unpack_destructuring(contexts, element, (node3) => x`${modifier(node3)}[${i2}]`, default_modifier);
            }
          });
        } else if (node2.type === "ObjectPattern") {
          const used_properties = [];
          node2.properties.forEach((property) => {
            if (property.type === "RestElement") {
              unpack_destructuring(contexts, property.argument, (node3) => x`@object_without_properties(${modifier(node3)}, [${used_properties}])`, default_modifier);
            } else {
              const key = property.key;
              const value2 = property.value;
              used_properties.push(x`"${key.name}"`);
              if (value2.type === "AssignmentPattern") {
                const n2 = contexts.length;
                unpack_destructuring(contexts, value2.left, (node3) => x`${modifier(node3)}.${key.name}`, (node3, to_ctx) => x`${node3} !== undefined ? ${node3} : ${update_reference(contexts, n2, value2.right, to_ctx)}`);
              } else {
                unpack_destructuring(contexts, value2, (node3) => x`${modifier(node3)}.${key.name}`, default_modifier);
              }
            }
          });
        }
      }
      function update_reference(contexts, n2, expression2, to_ctx) {
        const find_from_context = (node2) => {
          for (let i2 = n2; i2 < contexts.length; i2++) {
            const { key } = contexts[i2];
            if (node2.name === key.name) {
              throw new Error(`Cannot access '${node2.name}' before initialization`);
            }
          }
          return to_ctx(node2.name);
        };
        if (expression2.type === "Identifier") {
          return find_from_context(expression2);
        }
        expression2 = clone2(expression2);
        walk(expression2, {
          enter(node2, parent) {
            if (is_reference(node2, parent)) {
              this.replace(find_from_context(node2));
              this.skip();
            }
          }
        });
        return expression2;
      }
      class AwaitBlock$1 extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.expression = new Expression(component, this, scope2, info.expression);
          this.then_node = info.value;
          this.catch_node = info.error;
          if (this.then_node) {
            this.then_contexts = [];
            unpack_destructuring(this.then_contexts, info.value);
          }
          if (this.catch_node) {
            this.catch_contexts = [];
            unpack_destructuring(this.catch_contexts, info.error);
          }
          this.pending = new PendingBlock(component, this, scope2, info.pending);
          this.then = new ThenBlock(component, this, scope2, info.then);
          this.catch = new CatchBlock(component, this, scope2, info.catch);
        }
      }
      class EventHandler extends Node$1 {
        constructor(component, parent, template_scope, info) {
          super(component, parent, template_scope, info);
          this.uses_context = false;
          this.can_make_passive = false;
          this.name = info.name;
          this.modifiers = new Set(info.modifiers);
          if (info.expression) {
            this.expression = new Expression(component, this, template_scope, info.expression);
            this.uses_context = this.expression.uses_context;
            if (/FunctionExpression/.test(info.expression.type) && info.expression.params.length === 0) {
              this.can_make_passive = true;
            } else if (info.expression.type === "Identifier") {
              let node2 = component.node_for_declaration.get(info.expression.name);
              if (node2) {
                if (node2.type === "VariableDeclaration") {
                  const declarator = node2.declarations.find((d2) => d2.id.name === info.expression.name);
                  node2 = declarator && declarator.init;
                }
                if (node2 && (node2.type === "FunctionExpression" || node2.type === "FunctionDeclaration" || node2.type === "ArrowFunctionExpression") && node2.params.length === 0) {
                  this.can_make_passive = true;
                }
              }
            }
          } else {
            this.handler_name = component.get_unique_name(`${sanitize(this.name)}_handler`);
          }
        }
        get reassigned() {
          if (!this.expression) {
            return false;
          }
          const node2 = this.expression.node;
          if (/FunctionExpression/.test(node2.type)) {
            return false;
          }
          return this.expression.dynamic_dependencies().length > 0;
        }
      }
      class Body2 extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.handlers = [];
          this.actions = [];
          info.attributes.forEach((node2) => {
            if (node2.type === "EventHandler") {
              this.handlers.push(new EventHandler(component, this, scope2, node2));
            } else if (node2.type === "Action") {
              this.actions.push(new Action(component, this, scope2, node2));
            }
          });
        }
      }
      class Comment$2 extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.data = info.data;
          this.ignores = info.ignores;
        }
      }
      class ElseBlock extends AbstractBlock {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.children = map_children(component, this, scope2, info.children);
          this.warn_if_empty_block();
        }
      }
      class EachBlock$1 extends AbstractBlock {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.has_binding = false;
          this.has_index_binding = false;
          this.expression = new Expression(component, this, scope2, info.expression);
          this.context = info.context.name || "each";
          this.context_node = info.context;
          this.index = info.index;
          this.scope = scope2.child();
          this.contexts = [];
          unpack_destructuring(this.contexts, info.context);
          this.contexts.forEach((context) => {
            this.scope.add(context.key.name, this.expression.dependencies, this);
          });
          if (this.index) {
            const dependencies = info.key ? this.expression.dependencies : new Set([]);
            this.scope.add(this.index, dependencies, this);
          }
          this.key = info.key ? new Expression(component, this, this.scope, info.key) : null;
          this.has_animation = false;
          this.children = map_children(component, this, this.scope, info.children);
          if (this.has_animation) {
            if (this.children.length !== 1) {
              const child = this.children.find((child2) => !!child2.animation);
              component.error(child.animation, compiler_errors.invalid_animation_sole);
              return;
            }
          }
          this.warn_if_empty_block();
          this.else = info.else ? new ElseBlock(component, this, this.scope, info.else) : null;
        }
      }
      class Attribute extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.scope = scope2;
          if (info.type === "Spread") {
            this.name = null;
            this.is_spread = true;
            this.is_true = false;
            this.expression = new Expression(component, this, scope2, info.expression);
            this.dependencies = this.expression.dependencies;
            this.chunks = null;
            this.is_static = false;
          } else {
            this.name = info.name;
            this.is_true = info.value === true;
            this.is_static = true;
            this.dependencies = new Set();
            this.chunks = this.is_true ? [] : info.value.map((node2) => {
              if (node2.type === "Text")
                return node2;
              this.is_static = false;
              const expression2 = new Expression(component, this, scope2, node2.expression);
              add_to_set(this.dependencies, expression2.dependencies);
              return expression2;
            });
          }
        }
        get_dependencies() {
          if (this.is_spread)
            return this.expression.dynamic_dependencies();
          const dependencies = new Set();
          this.chunks.forEach((chunk) => {
            if (chunk.type === "Expression") {
              add_to_set(dependencies, chunk.dynamic_dependencies());
            }
          });
          return Array.from(dependencies);
        }
        get_value(block) {
          if (this.is_true)
            return x`true`;
          if (this.chunks.length === 0)
            return x`""`;
          if (this.chunks.length === 1) {
            return this.chunks[0].type === "Text" ? string_literal(this.chunks[0].data) : this.chunks[0].manipulate(block);
          }
          let expression2 = this.chunks.map((chunk) => chunk.type === "Text" ? string_literal(chunk.data) : chunk.manipulate(block)).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
          if (this.chunks[0].type !== "Text") {
            expression2 = x`"" + ${expression2}`;
          }
          return expression2;
        }
        get_static_value() {
          if (!this.is_static)
            return null;
          return this.is_true ? true : this.chunks[0] ? this.chunks[0].data : "";
        }
        should_cache() {
          return this.is_static ? false : this.chunks.length === 1 ? this.chunks[0].node.type !== "Identifier" || this.scope.names.has(this.chunks[0].node.name) : true;
        }
      }
      const read_only_media_attributes = new Set([
        "duration",
        "buffered",
        "seekable",
        "played",
        "seeking",
        "ended",
        "videoHeight",
        "videoWidth"
      ]);
      class Binding extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          if (info.expression.type !== "Identifier" && info.expression.type !== "MemberExpression") {
            component.error(info, compiler_errors.invalid_directive_value);
            return;
          }
          this.name = info.name;
          this.expression = new Expression(component, this, scope2, info.expression);
          this.raw_expression = clone2(info.expression);
          const { name } = get_object(this.expression.node);
          this.is_contextual = Array.from(this.expression.references).some((name2) => scope2.names.has(name2));
          if (scope2.is_let(name)) {
            component.error(this, compiler_errors.invalid_binding_let);
            return;
          } else if (scope2.names.has(name)) {
            if (scope2.is_await(name)) {
              component.error(this, compiler_errors.invalid_binding_await);
              return;
            }
            scope2.dependencies_for_name.get(name).forEach((name2) => {
              const variable = component.var_lookup.get(name2);
              if (variable) {
                variable.mutated = true;
              }
            });
          } else {
            const variable = component.var_lookup.get(name);
            if (!variable || variable.global) {
              component.error(this.expression.node, compiler_errors.binding_undeclared(name));
              return;
            }
            variable[this.expression.node.type === "MemberExpression" ? "mutated" : "reassigned"] = true;
            if (info.expression.type === "Identifier" && !variable.writable) {
              component.error(this.expression.node, compiler_errors.invalid_binding_writibale);
              return;
            }
          }
          const type = parent.get_static_attribute_value("type");
          this.is_readonly = dimensions.test(this.name) || isElement(parent) && (parent.is_media_node() && read_only_media_attributes.has(this.name) || parent.name === "input" && type === "file");
        }
        is_readonly_media_attribute() {
          return read_only_media_attributes.has(this.name);
        }
      }
      function isElement(node2) {
        return !!node2.is_media_node;
      }
      class Transition extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          component.warn_if_undefined(info.name, info, scope2);
          this.name = info.name;
          component.add_reference(info.name.split(".")[0]);
          this.directive = info.intro && info.outro ? "transition" : info.intro ? "in" : "out";
          this.is_local = info.modifiers.includes("local");
          if (info.intro && parent.intro || info.outro && parent.outro) {
            const parent_transition = parent.intro || parent.outro;
            component.error(info, compiler_errors.duplicate_transition(this.directive, parent_transition.directive));
            return;
          }
          this.expression = info.expression ? new Expression(component, this, scope2, info.expression) : null;
        }
      }
      class Animation extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          component.warn_if_undefined(info.name, info, scope2);
          this.name = info.name;
          component.add_reference(info.name.split(".")[0]);
          if (parent.animation) {
            component.error(this, compiler_errors.duplicate_animation);
            return;
          }
          const block = parent.parent;
          if (!block || block.type !== "EachBlock" || !block.key) {
            component.error(this, compiler_errors.invalid_animation_immediate);
            return;
          }
          block.has_animation = true;
          this.expression = info.expression ? new Expression(component, this, scope2, info.expression, true) : null;
        }
      }
      class Class extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.name = info.name;
          this.expression = info.expression ? new Expression(component, this, scope2, info.expression) : null;
        }
      }
      const elements_without_text = new Set([
        "audio",
        "datalist",
        "dl",
        "optgroup",
        "select",
        "video"
      ]);
      class Text extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.data = info.data;
          this.synthetic = info.synthetic || false;
        }
        should_skip() {
          if (/\S/.test(this.data))
            return false;
          const parent_element = this.find_nearest(/(?:Element|InlineComponent|SlotTemplate|Head)/);
          if (!parent_element)
            return false;
          if (parent_element.type === "Head")
            return true;
          if (parent_element.type === "InlineComponent")
            return parent_element.children.length === 1 && this === parent_element.children[0];
          if (/svg$/.test(parent_element.namespace)) {
            if (this.prev && this.prev.type === "Element" && this.prev.name === "tspan")
              return false;
          }
          return parent_element.namespace || elements_without_text.has(parent_element.name);
        }
      }
      const applicable = new Set(["Identifier", "ObjectExpression", "ArrayExpression", "Property"]);
      class Let extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.names = [];
          this.name = { type: "Identifier", name: info.name };
          const { names: names2 } = this;
          if (info.expression) {
            this.value = info.expression;
            walk(info.expression, {
              enter(node2) {
                if (!applicable.has(node2.type)) {
                  return component.error(node2, compiler_errors.invalid_let);
                }
                if (node2.type === "Identifier") {
                  names2.push(node2.name);
                }
                if (node2.type === "ArrayExpression") {
                  node2.type = "ArrayPattern";
                }
                if (node2.type === "ObjectExpression") {
                  node2.type = "ObjectPattern";
                }
              }
            });
          } else {
            names2.push(this.name.name);
          }
        }
      }
      const svg$1 = /^(?:altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|circle|clipPath|color-profile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|filter|font|font-face|font-face-format|font-face-name|font-face-src|font-face-uri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern|image|line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata|missing-glyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor|stop|svg|switch|symbol|text|textPath|tref|tspan|unknown|use|view|vkern)$/;
      const aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(" ");
      const aria_attribute_set = new Set(aria_attributes);
      const aria_roles = "alert alertdialog application article banner blockquote button caption cell checkbox code columnheader combobox complementary contentinfo definition deletion dialog directory document emphasis feed figure form generic graphics-document graphics-object graphics-symbol grid gridcell group heading img link list listbox listitem log main marquee math meter menu menubar menuitem menuitemcheckbox menuitemradio navigation none note option paragraph presentation progressbar radio radiogroup region row rowgroup rowheader scrollbar search searchbox separator slider spinbutton status strong subscript superscript switch tab table tablist tabpanel term textbox time timer toolbar tooltip tree treegrid treeitem".split(" ");
      const aria_role_set = new Set(aria_roles);
      const a11y_required_attributes = {
        a: ["href"],
        area: ["alt", "aria-label", "aria-labelledby"],
        html: ["lang"],
        iframe: ["title"],
        img: ["alt"],
        object: ["title", "aria-label", "aria-labelledby"]
      };
      const a11y_distracting_elements = new Set([
        "blink",
        "marquee"
      ]);
      const a11y_required_content = new Set([
        "a",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6"
      ]);
      const a11y_labelable = new Set([
        "button",
        "input",
        "keygen",
        "meter",
        "output",
        "progress",
        "select",
        "textarea"
      ]);
      const invisible_elements = new Set(["meta", "html", "script", "style"]);
      const valid_modifiers = new Set([
        "preventDefault",
        "stopPropagation",
        "capture",
        "once",
        "passive",
        "nonpassive",
        "self",
        "trusted"
      ]);
      const passive_events = new Set([
        "wheel",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel"
      ]);
      const react_attributes = new Map([
        ["className", "class"],
        ["htmlFor", "for"]
      ]);
      function get_namespace(parent, element, explicit_namespace) {
        const parent_element = parent.find_nearest(/^Element/);
        if (!parent_element) {
          return explicit_namespace || (svg$1.test(element.name) ? namespaces.svg : null);
        }
        if (parent_element.namespace !== namespaces.foreign) {
          if (svg$1.test(element.name.toLowerCase()))
            return namespaces.svg;
          if (parent_element.name.toLowerCase() === "foreignobject")
            return null;
        }
        return parent_element.namespace;
      }
      class Element$1 extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.attributes = [];
          this.actions = [];
          this.bindings = [];
          this.classes = [];
          this.handlers = [];
          this.lets = [];
          this.intro = null;
          this.outro = null;
          this.animation = null;
          this.name = info.name;
          this.namespace = get_namespace(parent, this, component.namespace);
          if (this.namespace !== namespaces.foreign) {
            if (this.name === "textarea") {
              if (info.children.length > 0) {
                const value_attribute = info.attributes.find((node2) => node2.name === "value");
                if (value_attribute) {
                  component.error(value_attribute, compiler_errors.textarea_duplicate_value);
                  return;
                }
                info.attributes.push({
                  type: "Attribute",
                  name: "value",
                  value: info.children
                });
                info.children = [];
              }
            }
            if (this.name === "option") {
              const value_attribute = info.attributes.find((attribute) => attribute.name === "value");
              if (!value_attribute) {
                info.attributes.push({
                  type: "Attribute",
                  name: "value",
                  value: info.children,
                  synthetic: true
                });
              }
            }
          }
          const has_let = info.attributes.some((node2) => node2.type === "Let");
          if (has_let) {
            scope2 = scope2.child();
          }
          const order = ["Binding"];
          info.attributes.sort((a, b2) => order.indexOf(a.type) - order.indexOf(b2.type));
          info.attributes.forEach((node2) => {
            switch (node2.type) {
              case "Action":
                this.actions.push(new Action(component, this, scope2, node2));
                break;
              case "Attribute":
              case "Spread":
                if (node2.name === "xmlns")
                  this.namespace = node2.value[0].data;
                this.attributes.push(new Attribute(component, this, scope2, node2));
                break;
              case "Binding":
                this.bindings.push(new Binding(component, this, scope2, node2));
                break;
              case "Class":
                this.classes.push(new Class(component, this, scope2, node2));
                break;
              case "EventHandler":
                this.handlers.push(new EventHandler(component, this, scope2, node2));
                break;
              case "Let": {
                const l = new Let(component, this, scope2, node2);
                this.lets.push(l);
                const dependencies = new Set([l.name.name]);
                l.names.forEach((name) => {
                  scope2.add(name, dependencies, this);
                });
                break;
              }
              case "Transition": {
                const transition = new Transition(component, this, scope2, node2);
                if (node2.intro)
                  this.intro = transition;
                if (node2.outro)
                  this.outro = transition;
                break;
              }
              case "Animation":
                this.animation = new Animation(component, this, scope2, node2);
                break;
              default:
                throw new Error(`Not implemented: ${node2.type}`);
            }
          });
          this.scope = scope2;
          this.children = map_children(component, this, this.scope, info.children);
          this.validate();
          component.apply_stylesheet(this);
        }
        validate() {
          if (this.component.var_lookup.has(this.name) && this.component.var_lookup.get(this.name).imported) {
            this.component.warn(this, compiler_warnings.component_name_lowercase(this.name));
          }
          this.validate_attributes();
          this.validate_event_handlers();
          if (this.namespace === namespaces.foreign) {
            this.validate_bindings_foreign();
          } else {
            this.validate_attributes_a11y();
            this.validate_special_cases();
            this.validate_bindings();
            this.validate_content();
          }
        }
        validate_attributes() {
          const { component, parent } = this;
          this.attributes.forEach((attribute) => {
            if (attribute.is_spread)
              return;
            const name = attribute.name.toLowerCase();
            if (/(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/.test(name)) {
              return component.error(attribute, compiler_errors.illegal_attribute(name));
            }
            if (name === "slot") {
              if (!attribute.is_static) {
                return component.error(attribute, compiler_errors.invalid_slot_attribute);
              }
              if (component.slot_outlets.has(name)) {
                return component.error(attribute, compiler_errors.duplicate_slot_attribute(name));
              }
              if (!(parent.type === "SlotTemplate" || within_custom_element(parent))) {
                return component.error(attribute, compiler_errors.invalid_slotted_content);
              }
            }
            if (this.namespace !== namespaces.foreign) {
              if (name === "is") {
                component.warn(attribute, compiler_warnings.avoid_is);
              }
              if (react_attributes.has(attribute.name)) {
                component.warn(attribute, compiler_warnings.invalid_html_attribute(attribute.name, react_attributes.get(attribute.name)));
              }
            }
          });
        }
        validate_attributes_a11y() {
          const { component } = this;
          this.attributes.forEach((attribute) => {
            if (attribute.is_spread)
              return;
            const name = attribute.name.toLowerCase();
            if (name.startsWith("aria-")) {
              if (invisible_elements.has(this.name)) {
                component.warn(attribute, compiler_warnings.a11y_aria_attributes(this.name));
              }
              const type = name.slice(5);
              if (!aria_attribute_set.has(type)) {
                const match = fuzzymatch(type, aria_attributes);
                component.warn(attribute, compiler_warnings.a11y_unknown_aria_attribute(type, match));
              }
              if (name === "aria-hidden" && /^h[1-6]$/.test(this.name)) {
                component.warn(attribute, compiler_warnings.a11y_hidden(this.name));
              }
            }
            if (name === "role") {
              if (invisible_elements.has(this.name)) {
                component.warn(attribute, compiler_warnings.a11y_misplaced_role(this.name));
              }
              const value2 = attribute.get_static_value();
              if (value2 && !aria_role_set.has(value2)) {
                const match = fuzzymatch(value2, aria_roles);
                component.warn(attribute, compiler_warnings.a11y_unknown_role(value2, match));
              }
            }
            if (name === "accesskey") {
              component.warn(attribute, compiler_warnings.a11y_accesskey);
            }
            if (name === "autofocus") {
              component.warn(attribute, compiler_warnings.a11y_autofocus);
            }
            if (name === "scope" && this.name !== "th") {
              component.warn(attribute, compiler_warnings.a11y_misplaced_scope);
            }
            if (name === "tabindex") {
              const value2 = attribute.get_static_value();
              if (!isNaN(value2) && +value2 > 0) {
                component.warn(attribute, compiler_warnings.a11y_positive_tabindex);
              }
            }
          });
        }
        validate_special_cases() {
          const { component, attributes, handlers: handlers2 } = this;
          const attribute_map = new Map();
          const handlers_map = new Map();
          attributes.forEach((attribute) => attribute_map.set(attribute.name, attribute));
          handlers2.forEach((handler2) => handlers_map.set(handler2.name, handler2));
          if (this.name === "a") {
            const href_attribute = attribute_map.get("href") || attribute_map.get("xlink:href");
            const id_attribute = attribute_map.get("id");
            const name_attribute = attribute_map.get("name");
            if (href_attribute) {
              const href_value = href_attribute.get_static_value();
              if (href_value === "" || href_value === "#" || /^\W*javascript:/i.test(href_value)) {
                component.warn(href_attribute, compiler_warnings.a11y_invalid_attribute(href_attribute.name, href_value));
              }
            } else {
              const id_attribute_valid = id_attribute && id_attribute.get_static_value() !== "";
              const name_attribute_valid = name_attribute && name_attribute.get_static_value() !== "";
              if (!id_attribute_valid && !name_attribute_valid) {
                component.warn(this, compiler_warnings.a11y_missing_attribute("a", "an", "href"));
              }
            }
          } else {
            const required_attributes = a11y_required_attributes[this.name];
            if (required_attributes) {
              const has_attribute = required_attributes.some((name) => attribute_map.has(name));
              if (!has_attribute) {
                should_have_attribute(this, required_attributes);
              }
            }
          }
          if (this.name === "input") {
            const type = attribute_map.get("type");
            if (type && type.get_static_value() === "image") {
              const required_attributes = ["alt", "aria-label", "aria-labelledby"];
              const has_attribute = required_attributes.some((name) => attribute_map.has(name));
              if (!has_attribute) {
                should_have_attribute(this, required_attributes, 'input type="image"');
              }
            }
          }
          if (this.name === "img") {
            const alt_attribute = attribute_map.get("alt");
            const aria_hidden_attribute = attribute_map.get("aria-hidden");
            const aria_hidden_exist = aria_hidden_attribute && aria_hidden_attribute.get_static_value();
            if (alt_attribute && !aria_hidden_exist) {
              const alt_value = alt_attribute.get_static_value();
              if (/\b(image|picture|photo)\b/i.test(alt_value)) {
                component.warn(this, compiler_warnings.a11y_img_redundant_alt);
              }
            }
          }
          if (this.name === "label") {
            const has_input_child = this.children.some((i2) => i2 instanceof Element$1 && a11y_labelable.has(i2.name));
            if (!attribute_map.has("for") && !has_input_child) {
              component.warn(this, compiler_warnings.a11y_label_has_associated_control);
            }
          }
          if (this.name === "video") {
            if (attribute_map.has("muted")) {
              return;
            }
            let has_caption;
            const track = this.children.find((i2) => i2.name === "track");
            if (track) {
              has_caption = track.attributes.find((a) => a.name === "kind" && a.get_static_value() === "captions");
            }
            if (!has_caption) {
              component.warn(this, compiler_warnings.a11y_media_has_caption);
            }
          }
          if (a11y_distracting_elements.has(this.name)) {
            component.warn(this, compiler_warnings.a11y_distracting_elements(this.name));
          }
          if (this.name === "figcaption") {
            let { parent } = this;
            let is_figure_parent = false;
            while (parent) {
              if (parent.name === "figure") {
                is_figure_parent = true;
                break;
              }
              if (parent.type === "Element") {
                break;
              }
              parent = parent.parent;
            }
            if (!is_figure_parent) {
              component.warn(this, compiler_warnings.a11y_structure_immediate);
            }
          }
          if (this.name === "figure") {
            const children = this.children.filter((node2) => {
              if (node2.type === "Comment")
                return false;
              if (node2.type === "Text")
                return /\S/.test(node2.data);
              return true;
            });
            const index2 = children.findIndex((child) => child.name === "figcaption");
            if (index2 !== -1 && (index2 !== 0 && index2 !== children.length - 1)) {
              component.warn(children[index2], compiler_warnings.a11y_structure_first_or_last);
            }
          }
          if (handlers_map.has("mouseover") && !handlers_map.has("focus")) {
            component.warn(this, compiler_warnings.a11y_mouse_events_have_key_events("mouseover", "focus"));
          }
          if (handlers_map.has("mouseout") && !handlers_map.has("blur")) {
            component.warn(this, compiler_warnings.a11y_mouse_events_have_key_events("mouseout", "blur"));
          }
        }
        validate_bindings_foreign() {
          this.bindings.forEach((binding) => {
            if (binding.name !== "this") {
              return this.component.error(binding, compiler_errors.invalid_binding_foreign(binding.name));
            }
          });
        }
        validate_bindings() {
          const { component } = this;
          const check_type_attribute = () => {
            const attribute = this.attributes.find((attribute2) => attribute2.name === "type");
            if (!attribute)
              return null;
            if (!attribute.is_static) {
              return component.error(attribute, compiler_errors.invalid_type);
            }
            const value2 = attribute.get_static_value();
            if (value2 === true) {
              return component.error(attribute, compiler_errors.missing_type);
            }
            return value2;
          };
          this.bindings.forEach((binding) => {
            const { name } = binding;
            if (name === "value") {
              if (this.name !== "input" && this.name !== "textarea" && this.name !== "select") {
                return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "value"));
              }
              if (this.name === "select") {
                const attribute = this.attributes.find((attribute2) => attribute2.name === "multiple");
                if (attribute && !attribute.is_static) {
                  return component.error(attribute, compiler_errors.dynamic_multiple_attribute);
                }
              } else {
                check_type_attribute();
              }
            } else if (name === "checked" || name === "indeterminate") {
              if (this.name !== "input") {
                return component.error(binding, compiler_errors.invalid_binding_elements(this.name, name));
              }
              const type = check_type_attribute();
              if (type !== "checkbox") {
                return component.error(binding, compiler_errors.invalid_binding_no_checkbox(name, type === "radio"));
              }
            } else if (name === "group") {
              if (this.name !== "input") {
                return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "group"));
              }
              const type = check_type_attribute();
              if (type !== "checkbox" && type !== "radio") {
                return component.error(binding, compiler_errors.invalid_binding_element_with('<input type="checkbox"> or <input type="radio">', "group"));
              }
            } else if (name === "files") {
              if (this.name !== "input") {
                return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "files"));
              }
              const type = check_type_attribute();
              if (type !== "file") {
                return component.error(binding, compiler_errors.invalid_binding_element_with('<input type="file">', "files"));
              }
            } else if (name === "open") {
              if (this.name !== "details") {
                return component.error(binding, compiler_errors.invalid_binding_element_with("<details>", name));
              }
            } else if (name === "currentTime" || name === "duration" || name === "paused" || name === "buffered" || name === "seekable" || name === "played" || name === "volume" || name === "muted" || name === "playbackRate" || name === "seeking" || name === "ended") {
              if (this.name !== "audio" && this.name !== "video") {
                return component.error(binding, compiler_errors.invalid_binding_element_with("audio> or <video>", name));
              }
            } else if (name === "videoHeight" || name === "videoWidth") {
              if (this.name !== "video") {
                return component.error(binding, compiler_errors.invalid_binding_element_with("<video>", name));
              }
            } else if (dimensions.test(name)) {
              if (this.name === "svg" && (name === "offsetWidth" || name === "offsetHeight")) {
                return component.error(binding, compiler_errors.invalid_binding_on(binding.name, `<svg>. Use '${name.replace("offset", "client")}' instead`));
              } else if (svg$1.test(this.name)) {
                return component.error(binding, compiler_errors.invalid_binding_on(binding.name, "SVG elements"));
              } else if (is_void(this.name)) {
                return component.error(binding, compiler_errors.invalid_binding_on(binding.name, `void elements like <${this.name}>. Use a wrapper element instead`));
              }
            } else if (name === "textContent" || name === "innerHTML") {
              const contenteditable = this.attributes.find((attribute) => attribute.name === "contenteditable");
              if (!contenteditable) {
                return component.error(binding, compiler_errors.missing_contenteditable_attribute);
              } else if (contenteditable && !contenteditable.is_static) {
                return component.error(contenteditable, compiler_errors.dynamic_contenteditable_attribute);
              }
            } else if (name !== "this") {
              return component.error(binding, compiler_errors.invalid_binding(binding.name));
            }
          });
        }
        validate_content() {
          if (!a11y_required_content.has(this.name))
            return;
          if (this.bindings.some((binding) => ["textContent", "innerHTML"].includes(binding.name)))
            return;
          if (this.children.length === 0) {
            this.component.warn(this, compiler_warnings.a11y_missing_content(this.name));
          }
        }
        validate_event_handlers() {
          const { component } = this;
          this.handlers.forEach((handler2) => {
            if (handler2.modifiers.has("passive") && handler2.modifiers.has("preventDefault")) {
              return component.error(handler2, compiler_errors.invalid_event_modifier_combination("passive", "preventDefault"));
            }
            if (handler2.modifiers.has("passive") && handler2.modifiers.has("nonpassive")) {
              return component.error(handler2, compiler_errors.invalid_event_modifier_combination("passive", "nonpassive"));
            }
            handler2.modifiers.forEach((modifier) => {
              if (!valid_modifiers.has(modifier)) {
                return component.error(handler2, compiler_errors.invalid_event_modifier(list(Array.from(valid_modifiers))));
              }
              if (modifier === "passive") {
                if (passive_events.has(handler2.name)) {
                  if (handler2.can_make_passive) {
                    component.warn(handler2, compiler_warnings.redundant_event_modifier_for_touch);
                  }
                } else {
                  component.warn(handler2, compiler_warnings.redundant_event_modifier_passive);
                }
              }
              if (component.compile_options.legacy && (modifier === "once" || modifier === "passive")) {
                return component.error(handler2, compiler_errors.invalid_event_modifier_legacy(modifier));
              }
            });
            if (passive_events.has(handler2.name) && handler2.can_make_passive && !handler2.modifiers.has("preventDefault") && !handler2.modifiers.has("nonpassive")) {
              handler2.modifiers.add("passive");
            }
          });
        }
        is_media_node() {
          return this.name === "audio" || this.name === "video";
        }
        add_css_class() {
          if (this.attributes.some((attr) => attr.is_spread)) {
            this.needs_manual_style_scoping = true;
            return;
          }
          const { id: id2 } = this.component.stylesheet;
          const class_attribute = this.attributes.find((a) => a.name === "class");
          if (class_attribute && !class_attribute.is_true) {
            if (class_attribute.chunks.length === 1 && class_attribute.chunks[0].type === "Text") {
              class_attribute.chunks[0].data += ` ${id2}`;
            } else {
              class_attribute.chunks.push(new Text(this.component, this, this.scope, {
                type: "Text",
                data: ` ${id2}`,
                synthetic: true
              }));
            }
          } else {
            this.attributes.push(new Attribute(this.component, this, this.scope, {
              type: "Attribute",
              name: "class",
              value: [{ type: "Text", data: id2, synthetic: true }]
            }));
          }
        }
        get slot_template_name() {
          return this.attributes.find((attribute) => attribute.name === "slot").get_static_value();
        }
      }
      function should_have_attribute(node2, attributes, name = node2.name) {
        const article = /^[aeiou]/.test(attributes[0]) ? "an" : "a";
        const sequence2 = attributes.length > 1 ? attributes.slice(0, -1).join(", ") + ` or ${attributes[attributes.length - 1]}` : attributes[0];
        node2.component.warn(node2, compiler_warnings.a11y_missing_attribute(name, article, sequence2));
      }
      function within_custom_element(parent) {
        while (parent) {
          if (parent.type === "InlineComponent")
            return false;
          if (parent.type === "Element" && /-/.test(parent.name))
            return true;
          parent = parent.parent;
        }
        return false;
      }
      function hash2(str2) {
        str2 = str2.replace(/\r/g, "");
        let hash3 = 5381;
        let i2 = str2.length;
        while (i2--)
          hash3 = (hash3 << 5) - hash3 ^ str2.charCodeAt(i2);
        return (hash3 >>> 0).toString(36);
      }
      class Head$1 extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          if (info.attributes.length) {
            component.error(info.attributes[0], compiler_errors.invalid_attribute_head);
            return;
          }
          this.children = map_children(component, parent, scope2, info.children.filter((child) => {
            return child.type !== "Text" || /\S/.test(child.data);
          }));
          if (this.children.length > 0) {
            this.id = `svelte-${hash2(this.component.source.slice(this.start, this.end))}`;
          }
        }
      }
      class IfBlock$1 extends AbstractBlock {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.expression = new Expression(component, this, scope2, info.expression);
          this.children = map_children(component, this, scope2, info.children);
          this.else = info.else ? new ElseBlock(component, this, scope2, info.else) : null;
          this.warn_if_empty_block();
        }
      }
      class InlineComponent$1 extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.attributes = [];
          this.bindings = [];
          this.handlers = [];
          this.lets = [];
          this.css_custom_properties = [];
          if (info.name !== "svelte:component" && info.name !== "svelte:self") {
            const name = info.name.split(".")[0];
            component.warn_if_undefined(name, info, scope2);
            component.add_reference(name);
          }
          this.name = info.name;
          this.expression = this.name === "svelte:component" ? new Expression(component, this, scope2, info.expression) : null;
          info.attributes.forEach((node2) => {
            switch (node2.type) {
              case "Action":
                return component.error(node2, compiler_errors.invalid_action);
              case "Attribute":
                if (node2.name.startsWith("--")) {
                  this.css_custom_properties.push(new Attribute(component, this, scope2, node2));
                  break;
                }
              case "Spread":
                this.attributes.push(new Attribute(component, this, scope2, node2));
                break;
              case "Binding":
                this.bindings.push(new Binding(component, this, scope2, node2));
                break;
              case "Class":
                return component.error(node2, compiler_errors.invalid_class);
              case "EventHandler":
                this.handlers.push(new EventHandler(component, this, scope2, node2));
                break;
              case "Let":
                this.lets.push(new Let(component, this, scope2, node2));
                break;
              case "Transition":
                return component.error(node2, compiler_errors.invalid_transition);
              default:
                throw new Error(`Not implemented: ${node2.type}`);
            }
          });
          if (this.lets.length > 0) {
            this.scope = scope2.child();
            this.lets.forEach((l) => {
              const dependencies = new Set([l.name.name]);
              l.names.forEach((name) => {
                this.scope.add(name, dependencies, this);
              });
            });
          } else {
            this.scope = scope2;
          }
          this.handlers.forEach((handler2) => {
            handler2.modifiers.forEach((modifier) => {
              if (modifier !== "once") {
                return component.error(handler2, compiler_errors.invalid_event_modifier_component);
              }
            });
          });
          const children = [];
          for (let i2 = info.children.length - 1; i2 >= 0; i2--) {
            const child = info.children[i2];
            if (child.type === "SlotTemplate") {
              children.push(child);
              info.children.splice(i2, 1);
            } else if ((child.type === "Element" || child.type === "InlineComponent" || child.type === "Slot") && child.attributes.find((attribute) => attribute.name === "slot")) {
              const slot_template = {
                start: child.start,
                end: child.end,
                type: "SlotTemplate",
                name: "svelte:fragment",
                attributes: [],
                children: [child]
              };
              for (let i3 = child.attributes.length - 1; i3 >= 0; i3--) {
                const attribute = child.attributes[i3];
                if (attribute.type === "Let") {
                  slot_template.attributes.push(attribute);
                  child.attributes.splice(i3, 1);
                } else if (attribute.type === "Attribute" && attribute.name === "slot") {
                  slot_template.attributes.push(attribute);
                }
              }
              children.push(slot_template);
              info.children.splice(i2, 1);
            }
          }
          if (info.children.some((node2) => not_whitespace_text(node2))) {
            children.push({
              start: info.start,
              end: info.end,
              type: "SlotTemplate",
              name: "svelte:fragment",
              attributes: [],
              children: info.children
            });
          }
          this.children = map_children(component, this, this.scope, children);
        }
        get slot_template_name() {
          return this.attributes.find((attribute) => attribute.name === "slot").get_static_value();
        }
      }
      function not_whitespace_text(node2) {
        return !(node2.type === "Text" && /^\s+$/.test(node2.data));
      }
      class KeyBlock$1 extends AbstractBlock {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.expression = new Expression(component, this, scope2, info.expression);
          this.children = map_children(component, this, scope2, info.children);
          this.warn_if_empty_block();
        }
      }
      class Tag$1 extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.expression = new Expression(component, this, scope2, info.expression);
          this.should_cache = info.expression.type !== "Identifier" || this.expression.dependencies.size && scope2.names.has(info.expression.name);
        }
      }
      class MustacheTag extends Tag$1 {
      }
      class Options extends Node$1 {
      }
      class RawMustacheTag extends Tag$1 {
      }
      class DebugTag$1 extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.expressions = info.identifiers.map((node2) => {
            return new Expression(component, parent, scope2, node2);
          });
        }
      }
      class Slot$1 extends Element$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.values = new Map();
          info.attributes.forEach((attr) => {
            if (attr.type !== "Attribute" && attr.type !== "Spread") {
              return component.error(attr, compiler_errors.invalid_slot_directive);
            }
            if (attr.name === "name") {
              if (attr.value.length !== 1 || attr.value[0].type !== "Text") {
                return component.error(attr, compiler_errors.dynamic_slot_name);
              }
              this.slot_name = attr.value[0].data;
              if (this.slot_name === "default") {
                return component.error(attr, compiler_errors.invalid_slot_name);
              }
            }
            this.values.set(attr.name, new Attribute(component, this, scope2, attr));
          });
          if (!this.slot_name)
            this.slot_name = "default";
          if (this.slot_name === "default") {
            component.slots.forEach((slot) => {
              this.values.forEach((attribute, name) => {
                if (!slot.values.has(name)) {
                  slot.values.set(name, attribute);
                }
              });
            });
          } else if (component.slots.has("default")) {
            const default_slot = component.slots.get("default");
            default_slot.values.forEach((attribute, name) => {
              if (!this.values.has(name)) {
                this.values.set(name, attribute);
              }
            });
          }
          component.slots.set(this.slot_name, this);
        }
      }
      class Title extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.children = map_children(component, parent, scope2, info.children);
          if (info.attributes.length > 0) {
            component.error(info.attributes[0], compiler_errors.illegal_attribute_title);
            return;
          }
          info.children.forEach((child) => {
            if (child.type !== "Text" && child.type !== "MustacheTag") {
              return component.error(child, compiler_errors.illegal_structure_title);
            }
          });
          this.should_cache = info.children.length === 1 ? info.children[0].type !== "Identifier" || scope2.names.has(info.children[0].name) : true;
        }
      }
      const valid_bindings = [
        "innerWidth",
        "innerHeight",
        "outerWidth",
        "outerHeight",
        "scrollX",
        "scrollY",
        "online"
      ];
      class Window extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.handlers = [];
          this.bindings = [];
          this.actions = [];
          info.attributes.forEach((node2) => {
            if (node2.type === "EventHandler") {
              this.handlers.push(new EventHandler(component, this, scope2, node2));
            } else if (node2.type === "Binding") {
              if (node2.expression.type !== "Identifier") {
                const { parts } = flatten_reference(node2.expression);
                return component.error(node2.expression, compiler_errors.invalid_binding_window(parts));
              }
              if (!~valid_bindings.indexOf(node2.name)) {
                const match = node2.name === "width" ? "innerWidth" : node2.name === "height" ? "innerHeight" : fuzzymatch(node2.name, valid_bindings);
                if (match) {
                  return component.error(node2, compiler_errors.invalid_binding_on(node2.name, "<svelte:window>", ` (did you mean '${match}'?)`));
                } else {
                  return component.error(node2, compiler_errors.invalid_binding_on(node2.name, "<svelte:window>", ` \u2014 valid bindings are ${list(valid_bindings)}`));
                }
              }
              this.bindings.push(new Binding(component, this, scope2, node2));
            } else if (node2.type === "Action") {
              this.actions.push(new Action(component, this, scope2, node2));
            }
          });
        }
      }
      function get_constructor(type) {
        switch (type) {
          case "AwaitBlock":
            return AwaitBlock$1;
          case "Body":
            return Body2;
          case "Comment":
            return Comment$2;
          case "EachBlock":
            return EachBlock$1;
          case "Element":
            return Element$1;
          case "Head":
            return Head$1;
          case "IfBlock":
            return IfBlock$1;
          case "InlineComponent":
            return InlineComponent$1;
          case "KeyBlock":
            return KeyBlock$1;
          case "MustacheTag":
            return MustacheTag;
          case "Options":
            return Options;
          case "RawMustacheTag":
            return RawMustacheTag;
          case "DebugTag":
            return DebugTag$1;
          case "Slot":
            return Slot$1;
          case "SlotTemplate":
            return SlotTemplate;
          case "Text":
            return Text;
          case "Title":
            return Title;
          case "Window":
            return Window;
          default:
            throw new Error(`Not implemented: ${type}`);
        }
      }
      function map_children(component, parent, scope2, children) {
        let last = null;
        let ignores = [];
        return children.map((child) => {
          const constructor = get_constructor(child.type);
          const use_ignores = child.type !== "Text" && child.type !== "Comment" && ignores.length;
          if (use_ignores)
            component.push_ignores(ignores);
          const node2 = new constructor(component, parent, scope2, child);
          if (use_ignores)
            component.pop_ignores(), ignores = [];
          if (node2.type === "Comment" && node2.ignores.length) {
            ignores.push(...node2.ignores);
          }
          if (last)
            last.next = node2;
          node2.prev = last;
          last = node2;
          return node2;
        });
      }
      class SlotTemplate extends Node$1 {
        constructor(component, parent, scope2, info) {
          super(component, parent, scope2, info);
          this.lets = [];
          this.slot_template_name = "default";
          this.validate_slot_template_placement();
          const has_let = info.attributes.some((node2) => node2.type === "Let");
          if (has_let) {
            scope2 = scope2.child();
          }
          info.attributes.forEach((node2) => {
            switch (node2.type) {
              case "Let": {
                const l = new Let(component, this, scope2, node2);
                this.lets.push(l);
                const dependencies = new Set([l.name.name]);
                l.names.forEach((name) => {
                  scope2.add(name, dependencies, this);
                });
                break;
              }
              case "Attribute": {
                if (node2.name === "slot") {
                  this.slot_attribute = new Attribute(component, this, scope2, node2);
                  if (!this.slot_attribute.is_static) {
                    return component.error(node2, compiler_errors.invalid_slot_attribute);
                  }
                  const value2 = this.slot_attribute.get_static_value();
                  if (typeof value2 === "boolean") {
                    return component.error(node2, compiler_errors.invalid_slot_attribute_value_missing);
                  }
                  this.slot_template_name = value2;
                  break;
                }
                throw new Error(`Invalid attribute '${node2.name}' in <svelte:fragment>`);
              }
              default:
                throw new Error(`Not implemented: ${node2.type}`);
            }
          });
          this.scope = scope2;
          this.children = map_children(component, this, this.scope, info.children);
        }
        validate_slot_template_placement() {
          if (this.parent.type !== "InlineComponent") {
            return this.component.error(this, compiler_errors.invalid_slotted_content_fragment);
          }
        }
      }
      function SlotTemplate$1(node2, renderer, options3) {
        const parent_inline_component = node2.parent;
        const children = remove_whitespace_children(node2 instanceof SlotTemplate ? node2.children : [node2], node2.next);
        renderer.push();
        renderer.render(children, options3);
        const lets = node2.lets;
        const seen = new Set(lets.map((l) => l.name.name));
        parent_inline_component.lets.forEach((l) => {
          if (!seen.has(l.name.name))
            lets.push(l);
        });
        const slot_fragment_content = renderer.pop();
        if (!is_empty_template_literal(slot_fragment_content)) {
          if (options3.slot_scopes.has(node2.slot_template_name)) {
            if (node2.slot_template_name === "default") {
              throw new Error('Found elements without slot attribute when using slot="default"');
            }
            throw new Error(`Duplicate slot name "${node2.slot_template_name}" in <${parent_inline_component.name}>`);
          }
          options3.slot_scopes.set(node2.slot_template_name, {
            input: get_slot_scope(node2.lets),
            output: slot_fragment_content
          });
        }
      }
      function is_empty_template_literal(template_literal) {
        return template_literal.expressions.length === 0 && template_literal.quasis.length === 1 && template_literal.quasis[0].value.raw === "";
      }
      function Tag$2(node2, renderer, _options) {
        const snippet = node2.expression.node;
        renderer.add_expression(node2.parent && node2.parent.type === "Element" && node2.parent.name === "style" ? snippet : x`@escape(${snippet})`);
      }
      function Text$1(node2, renderer, _options) {
        let text2 = node2.data;
        if (!node2.parent || node2.parent.type !== "Element" || node2.parent.name !== "script" && node2.parent.name !== "style") {
          text2 = escape_html(text2);
        }
        renderer.add_string(text2);
      }
      function Title$1(node2, renderer, options3) {
        renderer.push();
        renderer.add_string("<title>");
        renderer.render(node2.children, options3);
        renderer.add_string("</title>");
        const result = renderer.pop();
        renderer.add_expression(x`$$result.title = ${result}, ""`);
      }
      function noop$1() {
      }
      const handlers$1 = {
        AwaitBlock,
        Body: noop$1,
        Comment: Comment$1,
        DebugTag,
        EachBlock,
        Element: Element2,
        Head,
        IfBlock,
        InlineComponent,
        KeyBlock,
        MustacheTag: Tag$2,
        Options: noop$1,
        RawMustacheTag: HtmlTag,
        Slot,
        SlotTemplate: SlotTemplate$1,
        Text: Text$1,
        Title: Title$1,
        Window: noop$1
      };
      class Renderer$1 {
        constructor({ name }) {
          this.has_bindings = false;
          this.stack = [];
          this.targets = [];
          this.name = name;
          this.push();
        }
        add_string(str2) {
          this.current.value += escape_template(str2);
        }
        add_expression(node2) {
          this.literal.quasis.push({
            type: "TemplateElement",
            value: { raw: this.current.value, cooked: null },
            tail: false
          });
          this.literal.expressions.push(node2);
          this.current.value = "";
        }
        push() {
          const current = this.current = { value: "" };
          const literal2 = this.literal = {
            type: "TemplateLiteral",
            expressions: [],
            quasis: []
          };
          this.stack.push({ current, literal: literal2 });
        }
        pop() {
          this.literal.quasis.push({
            type: "TemplateElement",
            value: { raw: this.current.value, cooked: null },
            tail: true
          });
          const popped = this.stack.pop();
          const last = this.stack[this.stack.length - 1];
          if (last) {
            this.literal = last.literal;
            this.current = last.current;
          }
          return popped.literal;
        }
        render(nodes, options3) {
          nodes.forEach((node2) => {
            const handler2 = handlers$1[node2.type];
            if (!handler2) {
              throw new Error(`No handler for '${node2.type}' nodes`);
            }
            handler2(node2, this, options3);
          });
        }
      }
      function ssr(component, options3) {
        const renderer = new Renderer$1({
          name: component.name
        });
        const { name } = component;
        renderer.render(trim(component.fragment.children), Object.assign({
          locate: component.locate
        }, options3));
        const literal2 = renderer.pop();
        const css2 = options3.customElement ? { code: null, map: null } : component.stylesheet.render(options3.filename, true);
        const uses_rest = component.var_lookup.has("$$restProps");
        const props = component.vars.filter((variable) => !variable.module && variable.export_name);
        const rest = uses_rest ? b`let $$restProps = @compute_rest_props($$props, [${props.map((prop) => `"${prop.export_name}"`).join(",")}]);` : null;
        const uses_slots = component.var_lookup.has("$$slots");
        const slots = uses_slots ? b`let $$slots = @compute_slots(#slots);` : null;
        const reactive_stores = component.vars.filter((variable) => variable.name[0] === "$" && variable.name[1] !== "$");
        const reactive_store_subscriptions = reactive_stores.filter((store) => {
          const variable = component.var_lookup.get(store.name.slice(1));
          return !variable || variable.hoistable;
        }).map(({ name: name2 }) => {
          const store_name = name2.slice(1);
          return b`
				${component.compile_options.dev && b`@validate_store(${store_name}, '${store_name}');`}
				${`$$unsubscribe_${store_name}`} = @subscribe(${store_name}, #value => ${name2} = #value)
			`;
        });
        const reactive_store_unsubscriptions = reactive_stores.map(({ name: name2 }) => b`${`$$unsubscribe_${name2.slice(1)}`}()`);
        const reactive_store_declarations = reactive_stores.map(({ name: name2 }) => {
          const store_name = name2.slice(1);
          const store = component.var_lookup.get(store_name);
          if (store && store.reassigned) {
            const unsubscribe = `$$unsubscribe_${store_name}`;
            const subscribe = `$$subscribe_${store_name}`;
            return b`let ${name2}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${store_name}, $$value => ${name2} = $$value), ${store_name})`;
          }
          return b`let ${name2}, ${`$$unsubscribe_${store_name}`};`;
        });
        if (component.ast.instance) {
          let scope2 = component.instance_scope;
          const map = component.instance_scope_map;
          walk(component.ast.instance.content, {
            enter(node2) {
              if (map.has(node2)) {
                scope2 = map.get(node2);
              }
            },
            leave(node2) {
              if (map.has(node2)) {
                scope2 = scope2.parent;
              }
              if (node2.type === "AssignmentExpression" || node2.type === "UpdateExpression") {
                const assignee = node2.type === "AssignmentExpression" ? node2.left : node2.argument;
                const names2 = new Set(extract_names(assignee));
                const to_invalidate = new Set();
                for (const name2 of names2) {
                  const variable = component.var_lookup.get(name2);
                  if (variable && !variable.hoistable && !variable.global && !variable.module && (variable.subscribable || variable.name[0] === "$")) {
                    to_invalidate.add(variable.name);
                  }
                }
                if (to_invalidate.size) {
                  this.replace(invalidate({ component }, scope2, node2, to_invalidate, true));
                }
              }
            }
          });
        }
        component.rewrite_props(({ name: name2, reassigned }) => {
          const value2 = `$${name2}`;
          let insert = reassigned ? b`${`$$subscribe_${name2}`}()` : b`${`$$unsubscribe_${name2}`} = @subscribe(${name2}, #value => $${value2} = #value)`;
          if (component.compile_options.dev) {
            insert = b`@validate_store(${name2}, '${name2}'); ${insert}`;
          }
          return insert;
        });
        const instance_javascript = component.extract_javascript(component.ast.instance);
        const parent_bindings = instance_javascript ? component.vars.filter((variable) => !variable.module && variable.export_name).map((prop) => {
          return b`if ($$props.${prop.export_name} === void 0 && $$bindings.${prop.export_name} && ${prop.name} !== void 0) $$bindings.${prop.export_name}(${prop.name});`;
        }) : [];
        const injected = Array.from(component.injected_reactive_declaration_vars).filter((name2) => {
          const variable = component.var_lookup.get(name2);
          return variable.injected;
        });
        const reactive_declarations = component.reactive_declarations.map((d2) => {
          const body = d2.node.body;
          let statement = b`${body}`;
          if (!d2.declaration) {
            statement = b`$: { ${statement} }`;
          }
          return statement;
        });
        const main = renderer.has_bindings ? b`
			let $$settled;
			let $$rendered;

			do {
				$$settled = true;

				${reactive_declarations}

				$$rendered = ${literal2};
			} while (!$$settled);

			${reactive_store_unsubscriptions}

			return $$rendered;
		` : b`
			${reactive_declarations}

			${reactive_store_unsubscriptions}

			return ${literal2};`;
        const blocks = [
          ...injected.map((name2) => b`let ${name2};`),
          rest,
          slots,
          ...reactive_store_declarations,
          ...reactive_store_subscriptions,
          instance_javascript,
          ...parent_bindings,
          css2.code && b`$$result.css.add(#css);`,
          main
        ].filter(Boolean);
        const js = b`
		${css2.code ? b`
		const #css = {
			code: "${css2.code}",
			map: ${css2.map ? string_literal(css2.map.toString()) : "null"}
		};` : null}

		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}

		const ${name} = @create_ssr_component(($$result, $$props, $$bindings, #slots) => {
			${blocks}
		});
	`;
        return { js, css: css2 };
      }
      function trim(nodes) {
        let start = 0;
        for (; start < nodes.length; start += 1) {
          const node2 = nodes[start];
          if (node2.type !== "Text")
            break;
          node2.data = node2.data.replace(/^\s+/, "");
          if (node2.data)
            break;
        }
        let end = nodes.length;
        for (; end > start; end -= 1) {
          const node2 = nodes[end - 1];
          if (node2.type !== "Text")
            break;
          node2.data = node2.data.replace(/\s+$/, "");
          if (node2.data)
            break;
        }
        return nodes.slice(start, end);
      }
      const wrappers$1 = { esm, cjs };
      function create_module(program, format2, name, banner, sveltePath = "svelte", helpers, globals2, imports, module_exports, exports_from) {
        const internal_path = `${sveltePath}/internal`;
        helpers.sort((a, b2) => a.name < b2.name ? -1 : 1);
        globals2.sort((a, b2) => a.name < b2.name ? -1 : 1);
        const formatter = wrappers$1[format2];
        if (!formatter) {
          throw new Error(`options.format is invalid (must be ${list(Object.keys(wrappers$1))})`);
        }
        return formatter(program, name, banner, sveltePath, internal_path, helpers, globals2, imports, module_exports, exports_from);
      }
      function edit_source(source, sveltePath) {
        return source === "svelte" || source.startsWith("svelte/") ? source.replace("svelte", sveltePath) : source;
      }
      function get_internal_globals(globals2, helpers) {
        return globals2.length > 0 && {
          type: "VariableDeclaration",
          kind: "const",
          declarations: [{
            type: "VariableDeclarator",
            id: {
              type: "ObjectPattern",
              properties: globals2.map((g) => ({
                type: "Property",
                method: false,
                shorthand: false,
                computed: false,
                key: { type: "Identifier", name: g.name },
                value: g.alias,
                kind: "init"
              }))
            },
            init: helpers.find(({ name }) => name === "globals").alias
          }]
        };
      }
      function esm(program, name, banner, sveltePath, internal_path, helpers, globals2, imports, module_exports, exports_from) {
        const import_declaration = {
          type: "ImportDeclaration",
          specifiers: helpers.map((h) => ({
            type: "ImportSpecifier",
            local: h.alias,
            imported: { type: "Identifier", name: h.name }
          })),
          source: { type: "Literal", value: internal_path }
        };
        const internal_globals = get_internal_globals(globals2, helpers);
        imports.forEach((node2) => {
          node2.source.value = edit_source(node2.source.value, sveltePath);
        });
        exports_from.forEach((node2) => {
          node2.source.value = edit_source(node2.source.value, sveltePath);
        });
        const exports4 = module_exports.length > 0 && {
          type: "ExportNamedDeclaration",
          specifiers: module_exports.map((x2) => ({
            type: "Specifier",
            local: { type: "Identifier", name: x2.name },
            exported: { type: "Identifier", name: x2.as }
          }))
        };
        program.body = b`
		/* ${banner} */

		${import_declaration}
		${internal_globals}
		${imports}
		${exports_from}

		${program.body}

		export default ${name};
		${exports4}
	`;
      }
      function cjs(program, name, banner, sveltePath, internal_path, helpers, globals2, imports, module_exports, exports_from) {
        const internal_requires = {
          type: "VariableDeclaration",
          kind: "const",
          declarations: [{
            type: "VariableDeclarator",
            id: {
              type: "ObjectPattern",
              properties: helpers.map((h) => ({
                type: "Property",
                method: false,
                shorthand: false,
                computed: false,
                key: { type: "Identifier", name: h.name },
                value: h.alias,
                kind: "init"
              }))
            },
            init: x`require("${internal_path}")`
          }]
        };
        const internal_globals = get_internal_globals(globals2, helpers);
        const user_requires = imports.map((node2) => {
          const init2 = x`require("${edit_source(node2.source.value, sveltePath)}")`;
          if (node2.specifiers.length === 0) {
            return b`${init2};`;
          }
          return {
            type: "VariableDeclaration",
            kind: "const",
            declarations: [{
              type: "VariableDeclarator",
              id: node2.specifiers[0].type === "ImportNamespaceSpecifier" ? { type: "Identifier", name: node2.specifiers[0].local.name } : {
                type: "ObjectPattern",
                properties: node2.specifiers.map((s2) => ({
                  type: "Property",
                  method: false,
                  shorthand: false,
                  computed: false,
                  key: s2.type === "ImportSpecifier" ? s2.imported : { type: "Identifier", name: "default" },
                  value: s2.local,
                  kind: "init"
                }))
              },
              init: init2
            }]
          };
        });
        const exports4 = module_exports.map((x2) => b`exports.${{ type: "Identifier", name: x2.as }} = ${{ type: "Identifier", name: x2.name }};`);
        const user_exports_from = exports_from.map((node2) => {
          const init2 = x`require("${edit_source(node2.source.value, sveltePath)}")`;
          return node2.specifiers.map((specifier) => {
            return b`exports.${specifier.exported} = ${init2}.${specifier.local};`;
          });
        });
        program.body = b`
		/* ${banner} */

		"use strict";
		${internal_requires}
		${internal_globals}
		${user_requires}
		${user_exports_from}

		${program.body}

		exports.default = ${name};
		${exports4}
	`;
      }
      var Chunk = function Chunk2(start, end, content) {
        this.start = start;
        this.end = end;
        this.original = content;
        this.intro = "";
        this.outro = "";
        this.content = content;
        this.storeName = false;
        this.edited = false;
        Object.defineProperties(this, {
          previous: { writable: true, value: null },
          next: { writable: true, value: null }
        });
      };
      Chunk.prototype.appendLeft = function appendLeft(content) {
        this.outro += content;
      };
      Chunk.prototype.appendRight = function appendRight(content) {
        this.intro = this.intro + content;
      };
      Chunk.prototype.clone = function clone3() {
        var chunk = new Chunk(this.start, this.end, this.original);
        chunk.intro = this.intro;
        chunk.outro = this.outro;
        chunk.content = this.content;
        chunk.storeName = this.storeName;
        chunk.edited = this.edited;
        return chunk;
      };
      Chunk.prototype.contains = function contains(index2) {
        return this.start < index2 && index2 < this.end;
      };
      Chunk.prototype.eachNext = function eachNext(fn) {
        var chunk = this;
        while (chunk) {
          fn(chunk);
          chunk = chunk.next;
        }
      };
      Chunk.prototype.eachPrevious = function eachPrevious(fn) {
        var chunk = this;
        while (chunk) {
          fn(chunk);
          chunk = chunk.previous;
        }
      };
      Chunk.prototype.edit = function edit(content, storeName, contentOnly) {
        this.content = content;
        if (!contentOnly) {
          this.intro = "";
          this.outro = "";
        }
        this.storeName = storeName;
        this.edited = true;
        return this;
      };
      Chunk.prototype.prependLeft = function prependLeft(content) {
        this.outro = content + this.outro;
      };
      Chunk.prototype.prependRight = function prependRight(content) {
        this.intro = content + this.intro;
      };
      Chunk.prototype.split = function split(index2) {
        var sliceIndex = index2 - this.start;
        var originalBefore = this.original.slice(0, sliceIndex);
        var originalAfter = this.original.slice(sliceIndex);
        this.original = originalBefore;
        var newChunk = new Chunk(index2, this.end, originalAfter);
        newChunk.outro = this.outro;
        this.outro = "";
        this.end = index2;
        if (this.edited) {
          newChunk.edit("", false);
          this.content = "";
        } else {
          this.content = originalBefore;
        }
        newChunk.next = this.next;
        if (newChunk.next) {
          newChunk.next.previous = newChunk;
        }
        newChunk.previous = this;
        this.next = newChunk;
        return newChunk;
      };
      Chunk.prototype.toString = function toString2() {
        return this.intro + this.content + this.outro;
      };
      Chunk.prototype.trimEnd = function trimEnd(rx) {
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) {
          return true;
        }
        var trimmed = this.content.replace(rx, "");
        if (trimmed.length) {
          if (trimmed !== this.content) {
            this.split(this.start + trimmed.length).edit("", void 0, true);
          }
          return true;
        } else {
          this.edit("", void 0, true);
          this.intro = this.intro.replace(rx, "");
          if (this.intro.length) {
            return true;
          }
        }
      };
      Chunk.prototype.trimStart = function trimStart(rx) {
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) {
          return true;
        }
        var trimmed = this.content.replace(rx, "");
        if (trimmed.length) {
          if (trimmed !== this.content) {
            this.split(this.end - trimmed.length);
            this.edit("", void 0, true);
          }
          return true;
        } else {
          this.edit("", void 0, true);
          this.outro = this.outro.replace(rx, "");
          if (this.outro.length) {
            return true;
          }
        }
      };
      var btoa$2 = function() {
        throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
      };
      if (typeof window !== "undefined" && typeof window.btoa === "function") {
        btoa$2 = function(str2) {
          return window.btoa(unescape(encodeURIComponent(str2)));
        };
      } else if (typeof Buffer === "function") {
        btoa$2 = function(str2) {
          return Buffer.from(str2, "utf-8").toString("base64");
        };
      }
      var SourceMap$1 = function SourceMap2(properties2) {
        this.version = 3;
        this.file = properties2.file;
        this.sources = properties2.sources;
        this.sourcesContent = properties2.sourcesContent;
        this.names = properties2.names;
        this.mappings = encode(properties2.mappings);
      };
      SourceMap$1.prototype.toString = function toString2() {
        return JSON.stringify(this);
      };
      SourceMap$1.prototype.toUrl = function toUrl() {
        return "data:application/json;charset=utf-8;base64," + btoa$2(this.toString());
      };
      function guessIndent(code) {
        var lines = code.split("\n");
        var tabbed = lines.filter(function(line) {
          return /^\t+/.test(line);
        });
        var spaced = lines.filter(function(line) {
          return /^ {2,}/.test(line);
        });
        if (tabbed.length === 0 && spaced.length === 0) {
          return null;
        }
        if (tabbed.length >= spaced.length) {
          return "	";
        }
        var min = spaced.reduce(function(previous, current) {
          var numSpaces = /^ +/.exec(current)[0].length;
          return Math.min(numSpaces, previous);
        }, Infinity);
        return new Array(min + 1).join(" ");
      }
      function getRelativePath(from, to) {
        var fromParts = from.split(/[/\\]/);
        var toParts = to.split(/[/\\]/);
        fromParts.pop();
        while (fromParts[0] === toParts[0]) {
          fromParts.shift();
          toParts.shift();
        }
        if (fromParts.length) {
          var i2 = fromParts.length;
          while (i2--) {
            fromParts[i2] = "..";
          }
        }
        return fromParts.concat(toParts).join("/");
      }
      var toString$1 = Object.prototype.toString;
      function isObject(thing) {
        return toString$1.call(thing) === "[object Object]";
      }
      function getLocator$1(source) {
        var originalLines = source.split("\n");
        var lineOffsets = [];
        for (var i2 = 0, pos = 0; i2 < originalLines.length; i2++) {
          lineOffsets.push(pos);
          pos += originalLines[i2].length + 1;
        }
        return function locate2(index2) {
          var i3 = 0;
          var j = lineOffsets.length;
          while (i3 < j) {
            var m = i3 + j >> 1;
            if (index2 < lineOffsets[m]) {
              j = m;
            } else {
              i3 = m + 1;
            }
          }
          var line = i3 - 1;
          var column = index2 - lineOffsets[line];
          return { line, column };
        };
      }
      var Mappings = function Mappings2(hires) {
        this.hires = hires;
        this.generatedCodeLine = 0;
        this.generatedCodeColumn = 0;
        this.raw = [];
        this.rawSegments = this.raw[this.generatedCodeLine] = [];
        this.pending = null;
      };
      Mappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {
        if (content.length) {
          var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
          if (nameIndex >= 0) {
            segment.push(nameIndex);
          }
          this.rawSegments.push(segment);
        } else if (this.pending) {
          this.rawSegments.push(this.pending);
        }
        this.advance(content);
        this.pending = null;
      };
      Mappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
        var originalCharIndex = chunk.start;
        var first = true;
        while (originalCharIndex < chunk.end) {
          if (this.hires || first || sourcemapLocations[originalCharIndex]) {
            this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
          }
          if (original[originalCharIndex] === "\n") {
            loc.line += 1;
            loc.column = 0;
            this.generatedCodeLine += 1;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
            this.generatedCodeColumn = 0;
          } else {
            loc.column += 1;
            this.generatedCodeColumn += 1;
          }
          originalCharIndex += 1;
          first = false;
        }
        this.pending = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      };
      Mappings.prototype.advance = function advance(str2) {
        if (!str2) {
          return;
        }
        var lines = str2.split("\n");
        if (lines.length > 1) {
          for (var i2 = 0; i2 < lines.length - 1; i2++) {
            this.generatedCodeLine++;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
          }
          this.generatedCodeColumn = 0;
        }
        this.generatedCodeColumn += lines[lines.length - 1].length;
      };
      var n = "\n";
      var warned = {
        insertLeft: false,
        insertRight: false,
        storeName: false
      };
      var MagicString = function MagicString2(string, options3) {
        if (options3 === void 0)
          options3 = {};
        var chunk = new Chunk(0, string.length, string);
        Object.defineProperties(this, {
          original: { writable: true, value: string },
          outro: { writable: true, value: "" },
          intro: { writable: true, value: "" },
          firstChunk: { writable: true, value: chunk },
          lastChunk: { writable: true, value: chunk },
          lastSearchedChunk: { writable: true, value: chunk },
          byStart: { writable: true, value: {} },
          byEnd: { writable: true, value: {} },
          filename: { writable: true, value: options3.filename },
          indentExclusionRanges: { writable: true, value: options3.indentExclusionRanges },
          sourcemapLocations: { writable: true, value: {} },
          storedNames: { writable: true, value: {} },
          indentStr: { writable: true, value: guessIndent(string) }
        });
        this.byStart[0] = chunk;
        this.byEnd[string.length] = chunk;
      };
      MagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
        this.sourcemapLocations[char] = true;
      };
      MagicString.prototype.append = function append(content) {
        if (typeof content !== "string") {
          throw new TypeError("outro content must be a string");
        }
        this.outro += content;
        return this;
      };
      MagicString.prototype.appendLeft = function appendLeft(index2, content) {
        if (typeof content !== "string") {
          throw new TypeError("inserted content must be a string");
        }
        this._split(index2);
        var chunk = this.byEnd[index2];
        if (chunk) {
          chunk.appendLeft(content);
        } else {
          this.intro += content;
        }
        return this;
      };
      MagicString.prototype.appendRight = function appendRight(index2, content) {
        if (typeof content !== "string") {
          throw new TypeError("inserted content must be a string");
        }
        this._split(index2);
        var chunk = this.byStart[index2];
        if (chunk) {
          chunk.appendRight(content);
        } else {
          this.outro += content;
        }
        return this;
      };
      MagicString.prototype.clone = function clone3() {
        var cloned = new MagicString(this.original, { filename: this.filename });
        var originalChunk = this.firstChunk;
        var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
        while (originalChunk) {
          cloned.byStart[clonedChunk.start] = clonedChunk;
          cloned.byEnd[clonedChunk.end] = clonedChunk;
          var nextOriginalChunk = originalChunk.next;
          var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
          if (nextClonedChunk) {
            clonedChunk.next = nextClonedChunk;
            nextClonedChunk.previous = clonedChunk;
            clonedChunk = nextClonedChunk;
          }
          originalChunk = nextOriginalChunk;
        }
        cloned.lastChunk = clonedChunk;
        if (this.indentExclusionRanges) {
          cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
        }
        Object.keys(this.sourcemapLocations).forEach(function(loc) {
          cloned.sourcemapLocations[loc] = true;
        });
        return cloned;
      };
      MagicString.prototype.generateDecodedMap = function generateDecodedMap(options3) {
        var this$1 = this;
        options3 = options3 || {};
        var sourceIndex = 0;
        var names2 = Object.keys(this.storedNames);
        var mappings = new Mappings(options3.hires);
        var locate2 = getLocator$1(this.original);
        if (this.intro) {
          mappings.advance(this.intro);
        }
        this.firstChunk.eachNext(function(chunk) {
          var loc = locate2(chunk.start);
          if (chunk.intro.length) {
            mappings.advance(chunk.intro);
          }
          if (chunk.edited) {
            mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names2.indexOf(chunk.original) : -1);
          } else {
            mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);
          }
          if (chunk.outro.length) {
            mappings.advance(chunk.outro);
          }
        });
        return {
          file: options3.file ? options3.file.split(/[/\\]/).pop() : null,
          sources: [options3.source ? getRelativePath(options3.file || "", options3.source) : null],
          sourcesContent: options3.includeContent ? [this.original] : [null],
          names: names2,
          mappings: mappings.raw
        };
      };
      MagicString.prototype.generateMap = function generateMap(options3) {
        return new SourceMap$1(this.generateDecodedMap(options3));
      };
      MagicString.prototype.getIndentString = function getIndentString() {
        return this.indentStr === null ? "	" : this.indentStr;
      };
      MagicString.prototype.indent = function indent(indentStr, options3) {
        var pattern2 = /^[^\r\n]/gm;
        if (isObject(indentStr)) {
          options3 = indentStr;
          indentStr = void 0;
        }
        indentStr = indentStr !== void 0 ? indentStr : this.indentStr || "	";
        if (indentStr === "") {
          return this;
        }
        options3 = options3 || {};
        var isExcluded = {};
        if (options3.exclude) {
          var exclusions = typeof options3.exclude[0] === "number" ? [options3.exclude] : options3.exclude;
          exclusions.forEach(function(exclusion) {
            for (var i2 = exclusion[0]; i2 < exclusion[1]; i2 += 1) {
              isExcluded[i2] = true;
            }
          });
        }
        var shouldIndentNextCharacter = options3.indentStart !== false;
        var replacer = function(match) {
          if (shouldIndentNextCharacter) {
            return "" + indentStr + match;
          }
          shouldIndentNextCharacter = true;
          return match;
        };
        this.intro = this.intro.replace(pattern2, replacer);
        var charIndex = 0;
        var chunk = this.firstChunk;
        while (chunk) {
          var end = chunk.end;
          if (chunk.edited) {
            if (!isExcluded[charIndex]) {
              chunk.content = chunk.content.replace(pattern2, replacer);
              if (chunk.content.length) {
                shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
              }
            }
          } else {
            charIndex = chunk.start;
            while (charIndex < end) {
              if (!isExcluded[charIndex]) {
                var char = this.original[charIndex];
                if (char === "\n") {
                  shouldIndentNextCharacter = true;
                } else if (char !== "\r" && shouldIndentNextCharacter) {
                  shouldIndentNextCharacter = false;
                  if (charIndex === chunk.start) {
                    chunk.prependRight(indentStr);
                  } else {
                    this._splitChunk(chunk, charIndex);
                    chunk = chunk.next;
                    chunk.prependRight(indentStr);
                  }
                }
              }
              charIndex += 1;
            }
          }
          charIndex = chunk.end;
          chunk = chunk.next;
        }
        this.outro = this.outro.replace(pattern2, replacer);
        return this;
      };
      MagicString.prototype.insert = function insert() {
        throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
      };
      MagicString.prototype.insertLeft = function insertLeft(index2, content) {
        if (!warned.insertLeft) {
          console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
          warned.insertLeft = true;
        }
        return this.appendLeft(index2, content);
      };
      MagicString.prototype.insertRight = function insertRight(index2, content) {
        if (!warned.insertRight) {
          console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
          warned.insertRight = true;
        }
        return this.prependRight(index2, content);
      };
      MagicString.prototype.move = function move(start, end, index2) {
        if (index2 >= start && index2 <= end) {
          throw new Error("Cannot move a selection inside itself");
        }
        this._split(start);
        this._split(end);
        this._split(index2);
        var first = this.byStart[start];
        var last = this.byEnd[end];
        var oldLeft = first.previous;
        var oldRight = last.next;
        var newRight = this.byStart[index2];
        if (!newRight && last === this.lastChunk) {
          return this;
        }
        var newLeft = newRight ? newRight.previous : this.lastChunk;
        if (oldLeft) {
          oldLeft.next = oldRight;
        }
        if (oldRight) {
          oldRight.previous = oldLeft;
        }
        if (newLeft) {
          newLeft.next = first;
        }
        if (newRight) {
          newRight.previous = last;
        }
        if (!first.previous) {
          this.firstChunk = last.next;
        }
        if (!last.next) {
          this.lastChunk = first.previous;
          this.lastChunk.next = null;
        }
        first.previous = newLeft;
        last.next = newRight || null;
        if (!newLeft) {
          this.firstChunk = first;
        }
        if (!newRight) {
          this.lastChunk = last;
        }
        return this;
      };
      MagicString.prototype.overwrite = function overwrite(start, end, content, options3) {
        if (typeof content !== "string") {
          throw new TypeError("replacement content must be a string");
        }
        while (start < 0) {
          start += this.original.length;
        }
        while (end < 0) {
          end += this.original.length;
        }
        if (end > this.original.length) {
          throw new Error("end is out of bounds");
        }
        if (start === end) {
          throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
        }
        this._split(start);
        this._split(end);
        if (options3 === true) {
          if (!warned.storeName) {
            console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
            warned.storeName = true;
          }
          options3 = { storeName: true };
        }
        var storeName = options3 !== void 0 ? options3.storeName : false;
        var contentOnly = options3 !== void 0 ? options3.contentOnly : false;
        if (storeName) {
          var original = this.original.slice(start, end);
          this.storedNames[original] = true;
        }
        var first = this.byStart[start];
        var last = this.byEnd[end];
        if (first) {
          if (end > first.end && first.next !== this.byStart[first.end]) {
            throw new Error("Cannot overwrite across a split point");
          }
          first.edit(content, storeName, contentOnly);
          if (first !== last) {
            var chunk = first.next;
            while (chunk !== last) {
              chunk.edit("", false);
              chunk = chunk.next;
            }
            chunk.edit("", false);
          }
        } else {
          var newChunk = new Chunk(start, end, "").edit(content, storeName);
          last.next = newChunk;
          newChunk.previous = last;
        }
        return this;
      };
      MagicString.prototype.prepend = function prepend(content) {
        if (typeof content !== "string") {
          throw new TypeError("outro content must be a string");
        }
        this.intro = content + this.intro;
        return this;
      };
      MagicString.prototype.prependLeft = function prependLeft(index2, content) {
        if (typeof content !== "string") {
          throw new TypeError("inserted content must be a string");
        }
        this._split(index2);
        var chunk = this.byEnd[index2];
        if (chunk) {
          chunk.prependLeft(content);
        } else {
          this.intro = content + this.intro;
        }
        return this;
      };
      MagicString.prototype.prependRight = function prependRight(index2, content) {
        if (typeof content !== "string") {
          throw new TypeError("inserted content must be a string");
        }
        this._split(index2);
        var chunk = this.byStart[index2];
        if (chunk) {
          chunk.prependRight(content);
        } else {
          this.outro = content + this.outro;
        }
        return this;
      };
      MagicString.prototype.remove = function remove(start, end) {
        while (start < 0) {
          start += this.original.length;
        }
        while (end < 0) {
          end += this.original.length;
        }
        if (start === end) {
          return this;
        }
        if (start < 0 || end > this.original.length) {
          throw new Error("Character is out of bounds");
        }
        if (start > end) {
          throw new Error("end must be greater than start");
        }
        this._split(start);
        this._split(end);
        var chunk = this.byStart[start];
        while (chunk) {
          chunk.intro = "";
          chunk.outro = "";
          chunk.edit("");
          chunk = end > chunk.end ? this.byStart[chunk.end] : null;
        }
        return this;
      };
      MagicString.prototype.lastChar = function lastChar() {
        if (this.outro.length) {
          return this.outro[this.outro.length - 1];
        }
        var chunk = this.lastChunk;
        do {
          if (chunk.outro.length) {
            return chunk.outro[chunk.outro.length - 1];
          }
          if (chunk.content.length) {
            return chunk.content[chunk.content.length - 1];
          }
          if (chunk.intro.length) {
            return chunk.intro[chunk.intro.length - 1];
          }
        } while (chunk = chunk.previous);
        if (this.intro.length) {
          return this.intro[this.intro.length - 1];
        }
        return "";
      };
      MagicString.prototype.lastLine = function lastLine() {
        var lineIndex = this.outro.lastIndexOf(n);
        if (lineIndex !== -1) {
          return this.outro.substr(lineIndex + 1);
        }
        var lineStr = this.outro;
        var chunk = this.lastChunk;
        do {
          if (chunk.outro.length > 0) {
            lineIndex = chunk.outro.lastIndexOf(n);
            if (lineIndex !== -1) {
              return chunk.outro.substr(lineIndex + 1) + lineStr;
            }
            lineStr = chunk.outro + lineStr;
          }
          if (chunk.content.length > 0) {
            lineIndex = chunk.content.lastIndexOf(n);
            if (lineIndex !== -1) {
              return chunk.content.substr(lineIndex + 1) + lineStr;
            }
            lineStr = chunk.content + lineStr;
          }
          if (chunk.intro.length > 0) {
            lineIndex = chunk.intro.lastIndexOf(n);
            if (lineIndex !== -1) {
              return chunk.intro.substr(lineIndex + 1) + lineStr;
            }
            lineStr = chunk.intro + lineStr;
          }
        } while (chunk = chunk.previous);
        lineIndex = this.intro.lastIndexOf(n);
        if (lineIndex !== -1) {
          return this.intro.substr(lineIndex + 1) + lineStr;
        }
        return this.intro + lineStr;
      };
      MagicString.prototype.slice = function slice(start, end) {
        if (start === void 0)
          start = 0;
        if (end === void 0)
          end = this.original.length;
        while (start < 0) {
          start += this.original.length;
        }
        while (end < 0) {
          end += this.original.length;
        }
        var result = "";
        var chunk = this.firstChunk;
        while (chunk && (chunk.start > start || chunk.end <= start)) {
          if (chunk.start < end && chunk.end >= end) {
            return result;
          }
          chunk = chunk.next;
        }
        if (chunk && chunk.edited && chunk.start !== start) {
          throw new Error("Cannot use replaced character " + start + " as slice start anchor.");
        }
        var startChunk = chunk;
        while (chunk) {
          if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
            result += chunk.intro;
          }
          var containsEnd = chunk.start < end && chunk.end >= end;
          if (containsEnd && chunk.edited && chunk.end !== end) {
            throw new Error("Cannot use replaced character " + end + " as slice end anchor.");
          }
          var sliceStart = startChunk === chunk ? start - chunk.start : 0;
          var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
          result += chunk.content.slice(sliceStart, sliceEnd);
          if (chunk.outro && (!containsEnd || chunk.end === end)) {
            result += chunk.outro;
          }
          if (containsEnd) {
            break;
          }
          chunk = chunk.next;
        }
        return result;
      };
      MagicString.prototype.snip = function snip(start, end) {
        var clone3 = this.clone();
        clone3.remove(0, start);
        clone3.remove(end, clone3.original.length);
        return clone3;
      };
      MagicString.prototype._split = function _split(index2) {
        if (this.byStart[index2] || this.byEnd[index2]) {
          return;
        }
        var chunk = this.lastSearchedChunk;
        var searchForward = index2 > chunk.end;
        while (chunk) {
          if (chunk.contains(index2)) {
            return this._splitChunk(chunk, index2);
          }
          chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
        }
      };
      MagicString.prototype._splitChunk = function _splitChunk(chunk, index2) {
        if (chunk.edited && chunk.content.length) {
          var loc = getLocator$1(this.original)(index2);
          throw new Error("Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + ' \u2013 "' + chunk.original + '")');
        }
        var newChunk = chunk.split(index2);
        this.byEnd[index2] = chunk;
        this.byStart[index2] = newChunk;
        this.byEnd[newChunk.end] = newChunk;
        if (chunk === this.lastChunk) {
          this.lastChunk = newChunk;
        }
        this.lastSearchedChunk = chunk;
        return true;
      };
      MagicString.prototype.toString = function toString2() {
        var str2 = this.intro;
        var chunk = this.firstChunk;
        while (chunk) {
          str2 += chunk.toString();
          chunk = chunk.next;
        }
        return str2 + this.outro;
      };
      MagicString.prototype.isEmpty = function isEmpty() {
        var chunk = this.firstChunk;
        do {
          if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {
            return false;
          }
        } while (chunk = chunk.next);
        return true;
      };
      MagicString.prototype.length = function length() {
        var chunk = this.firstChunk;
        var length2 = 0;
        do {
          length2 += chunk.intro.length + chunk.content.length + chunk.outro.length;
        } while (chunk = chunk.next);
        return length2;
      };
      MagicString.prototype.trimLines = function trimLines() {
        return this.trim("[\\r\\n]");
      };
      MagicString.prototype.trim = function trim2(charType) {
        return this.trimStart(charType).trimEnd(charType);
      };
      MagicString.prototype.trimEndAborted = function trimEndAborted(charType) {
        var rx = new RegExp((charType || "\\s") + "+$");
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) {
          return true;
        }
        var chunk = this.lastChunk;
        do {
          var end = chunk.end;
          var aborted = chunk.trimEnd(rx);
          if (chunk.end !== end) {
            if (this.lastChunk === chunk) {
              this.lastChunk = chunk.next;
            }
            this.byEnd[chunk.end] = chunk;
            this.byStart[chunk.next.start] = chunk.next;
            this.byEnd[chunk.next.end] = chunk.next;
          }
          if (aborted) {
            return true;
          }
          chunk = chunk.previous;
        } while (chunk);
        return false;
      };
      MagicString.prototype.trimEnd = function trimEnd(charType) {
        this.trimEndAborted(charType);
        return this;
      };
      MagicString.prototype.trimStartAborted = function trimStartAborted(charType) {
        var rx = new RegExp("^" + (charType || "\\s") + "+");
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) {
          return true;
        }
        var chunk = this.firstChunk;
        do {
          var end = chunk.end;
          var aborted = chunk.trimStart(rx);
          if (chunk.end !== end) {
            if (chunk === this.lastChunk) {
              this.lastChunk = chunk.next;
            }
            this.byEnd[chunk.end] = chunk;
            this.byStart[chunk.next.start] = chunk.next;
            this.byEnd[chunk.next.end] = chunk.next;
          }
          if (aborted) {
            return true;
          }
          chunk = chunk.next;
        } while (chunk);
        return false;
      };
      MagicString.prototype.trimStart = function trimStart(charType) {
        this.trimStartAborted(charType);
        return this;
      };
      const UNKNOWN = {};
      function gather_possible_values(node2, set) {
        if (node2.type === "Literal") {
          set.add(node2.value);
        } else if (node2.type === "ConditionalExpression") {
          gather_possible_values(node2.consequent, set);
          gather_possible_values(node2.alternate, set);
        } else {
          set.add(UNKNOWN);
        }
      }
      var BlockAppliesToNode;
      (function(BlockAppliesToNode2) {
        BlockAppliesToNode2[BlockAppliesToNode2["NotPossible"] = 0] = "NotPossible";
        BlockAppliesToNode2[BlockAppliesToNode2["Possible"] = 1] = "Possible";
        BlockAppliesToNode2[BlockAppliesToNode2["UnknownSelectorType"] = 2] = "UnknownSelectorType";
      })(BlockAppliesToNode || (BlockAppliesToNode = {}));
      var NodeExist;
      (function(NodeExist2) {
        NodeExist2[NodeExist2["Probably"] = 1] = "Probably";
        NodeExist2[NodeExist2["Definitely"] = 2] = "Definitely";
      })(NodeExist || (NodeExist = {}));
      const whitelist_attribute_selector = new Map([
        ["details", new Set(["open"])]
      ]);
      class Selector$1 {
        constructor(node2, stylesheet) {
          this.node = node2;
          this.stylesheet = stylesheet;
          this.blocks = group_selectors(node2);
          let i2 = this.blocks.length;
          while (i2 > 0) {
            if (!this.blocks[i2 - 1].global)
              break;
            i2 -= 1;
          }
          this.local_blocks = this.blocks.slice(0, i2);
          const host_only = this.blocks.length === 1 && this.blocks[0].host;
          const root_only = this.blocks.length === 1 && this.blocks[0].root;
          this.used = this.local_blocks.length === 0 || host_only || root_only;
        }
        apply(node2) {
          const to_encapsulate = [];
          apply_selector(this.local_blocks.slice(), node2, to_encapsulate);
          if (to_encapsulate.length > 0) {
            to_encapsulate.forEach(({ node: node3, block }) => {
              this.stylesheet.nodes_with_css_class.add(node3);
              block.should_encapsulate = true;
            });
            this.used = true;
          }
        }
        minify(code) {
          let c2 = null;
          this.blocks.forEach((block, i2) => {
            if (i2 > 0) {
              if (block.start - c2 > 1) {
                code.overwrite(c2, block.start, block.combinator.name || " ");
              }
            }
            c2 = block.end;
          });
        }
        transform(code, attr, max_amount_class_specificity_increased) {
          const amount_class_specificity_to_increase = max_amount_class_specificity_increased - this.blocks.filter((block) => block.should_encapsulate).length;
          function remove_global_pseudo_class(selector2) {
            const first = selector2.children[0];
            const last = selector2.children[selector2.children.length - 1];
            code.remove(selector2.start, first.start).remove(last.end, selector2.end);
          }
          function encapsulate_block(block, attr2) {
            for (const selector2 of block.selectors) {
              if (selector2.type === "PseudoClassSelector" && selector2.name === "global") {
                remove_global_pseudo_class(selector2);
              }
            }
            let i2 = block.selectors.length;
            while (i2--) {
              const selector2 = block.selectors[i2];
              if (selector2.type === "PseudoElementSelector" || selector2.type === "PseudoClassSelector") {
                if (selector2.name !== "root" && selector2.name !== "host") {
                  if (i2 === 0)
                    code.prependRight(selector2.start, attr2);
                }
                continue;
              }
              if (selector2.type === "TypeSelector" && selector2.name === "*") {
                code.overwrite(selector2.start, selector2.end, attr2);
              } else {
                code.appendLeft(selector2.end, attr2);
              }
              break;
            }
          }
          this.blocks.forEach((block, index2) => {
            if (block.global) {
              remove_global_pseudo_class(block.selectors[0]);
            }
            if (block.should_encapsulate)
              encapsulate_block(block, index2 === this.blocks.length - 1 ? attr.repeat(amount_class_specificity_to_increase + 1) : attr);
          });
        }
        validate(component) {
          let start = 0;
          let end = this.blocks.length;
          for (; start < end; start += 1) {
            if (!this.blocks[start].global)
              break;
          }
          for (; end > start; end -= 1) {
            if (!this.blocks[end - 1].global)
              break;
          }
          for (let i2 = start; i2 < end; i2 += 1) {
            if (this.blocks[i2].global) {
              return component.error(this.blocks[i2].selectors[0], compiler_errors.css_invalid_global);
            }
          }
          this.validate_global_with_multiple_selectors(component);
        }
        validate_global_with_multiple_selectors(component) {
          if (this.blocks.length === 1 && this.blocks[0].selectors.length === 1) {
            return;
          }
          for (const block of this.blocks) {
            for (const selector2 of block.selectors) {
              if (selector2.type === "PseudoClassSelector" && selector2.name === "global") {
                if (/[^\\],(?!([^([]+[^\\]|[^([\\])[)\]])/.test(selector2.children[0].value)) {
                  component.error(selector2, compiler_errors.css_invalid_global_selector);
                }
              }
            }
          }
        }
        get_amount_class_specificity_increased() {
          let count = 0;
          for (const block of this.blocks) {
            if (block.should_encapsulate) {
              count++;
            }
          }
          return count;
        }
      }
      function apply_selector(blocks, node2, to_encapsulate) {
        const block = blocks.pop();
        if (!block)
          return false;
        if (!node2) {
          return block.global && blocks.every((block2) => block2.global) || block.host && blocks.length === 0;
        }
        switch (block_might_apply_to_node(block, node2)) {
          case BlockAppliesToNode.NotPossible:
            return false;
          case BlockAppliesToNode.UnknownSelectorType:
            to_encapsulate.push({ node: node2, block });
            return true;
        }
        if (block.combinator) {
          if (block.combinator.type === "WhiteSpace") {
            for (const ancestor_block of blocks) {
              if (ancestor_block.global) {
                continue;
              }
              if (ancestor_block.host) {
                to_encapsulate.push({ node: node2, block });
                return true;
              }
              let parent = node2;
              while (parent = get_element_parent(parent)) {
                if (block_might_apply_to_node(ancestor_block, parent) !== BlockAppliesToNode.NotPossible) {
                  to_encapsulate.push({ node: parent, block: ancestor_block });
                }
              }
              if (to_encapsulate.length) {
                to_encapsulate.push({ node: node2, block });
                return true;
              }
            }
            if (blocks.every((block2) => block2.global)) {
              to_encapsulate.push({ node: node2, block });
              return true;
            }
            return false;
          } else if (block.combinator.name === ">") {
            const has_global_parent = blocks.every((block2) => block2.global);
            if (has_global_parent || apply_selector(blocks, get_element_parent(node2), to_encapsulate)) {
              to_encapsulate.push({ node: node2, block });
              return true;
            }
            return false;
          } else if (block.combinator.name === "+" || block.combinator.name === "~") {
            const siblings = get_possible_element_siblings(node2, block.combinator.name === "+");
            let has_match = false;
            const has_global = blocks.some((block2) => block2.global);
            if (has_global) {
              if (siblings.size === 0 && get_element_parent(node2) !== null) {
                return false;
              }
              to_encapsulate.push({ node: node2, block });
              return true;
            }
            for (const possible_sibling of siblings.keys()) {
              if (apply_selector(blocks.slice(), possible_sibling, to_encapsulate)) {
                to_encapsulate.push({ node: node2, block });
                has_match = true;
              }
            }
            return has_match;
          }
          to_encapsulate.push({ node: node2, block });
          return true;
        }
        to_encapsulate.push({ node: node2, block });
        return true;
      }
      function block_might_apply_to_node(block, node2) {
        let i2 = block.selectors.length;
        while (i2--) {
          const selector2 = block.selectors[i2];
          const name = typeof selector2.name === "string" && selector2.name.replace(/\\(.)/g, "$1");
          if (selector2.type === "PseudoClassSelector" && (name === "host" || name === "root")) {
            return BlockAppliesToNode.NotPossible;
          }
          if (block.selectors.length === 1 && selector2.type === "PseudoClassSelector" && name === "global") {
            return BlockAppliesToNode.NotPossible;
          }
          if (selector2.type === "PseudoClassSelector" || selector2.type === "PseudoElementSelector") {
            continue;
          }
          if (selector2.type === "ClassSelector") {
            if (!attribute_matches(node2, "class", name, "~=", false) && !node2.classes.some((c2) => c2.name === name))
              return BlockAppliesToNode.NotPossible;
          } else if (selector2.type === "IdSelector") {
            if (!attribute_matches(node2, "id", name, "=", false))
              return BlockAppliesToNode.NotPossible;
          } else if (selector2.type === "AttributeSelector") {
            if (!(whitelist_attribute_selector.has(node2.name.toLowerCase()) && whitelist_attribute_selector.get(node2.name.toLowerCase()).has(selector2.name.name.toLowerCase())) && !attribute_matches(node2, selector2.name.name, selector2.value && unquote(selector2.value), selector2.matcher, selector2.flags)) {
              return BlockAppliesToNode.NotPossible;
            }
          } else if (selector2.type === "TypeSelector") {
            if (node2.name.toLowerCase() !== name.toLowerCase() && name !== "*")
              return BlockAppliesToNode.NotPossible;
          } else {
            return BlockAppliesToNode.UnknownSelectorType;
          }
        }
        return BlockAppliesToNode.Possible;
      }
      function test_attribute(operator, expected_value, case_insensitive, value2) {
        if (case_insensitive) {
          expected_value = expected_value.toLowerCase();
          value2 = value2.toLowerCase();
        }
        switch (operator) {
          case "=":
            return value2 === expected_value;
          case "~=":
            return value2.split(/\s/).includes(expected_value);
          case "|=":
            return `${value2}-`.startsWith(`${expected_value}-`);
          case "^=":
            return value2.startsWith(expected_value);
          case "$=":
            return value2.endsWith(expected_value);
          case "*=":
            return value2.includes(expected_value);
          default:
            throw new Error("this shouldn't happen");
        }
      }
      function attribute_matches(node2, name, expected_value, operator, case_insensitive) {
        const spread = node2.attributes.find((attr2) => attr2.type === "Spread");
        if (spread)
          return true;
        if (node2.bindings.some((binding) => binding.name === name))
          return true;
        const attr = node2.attributes.find((attr2) => attr2.name === name);
        if (!attr)
          return false;
        if (attr.is_true)
          return operator === null;
        if (!expected_value)
          return true;
        if (attr.chunks.length === 1) {
          const value2 = attr.chunks[0];
          if (!value2)
            return false;
          if (value2.type === "Text")
            return test_attribute(operator, expected_value, case_insensitive, value2.data);
        }
        const possible_values = new Set();
        let prev_values = [];
        for (const chunk of attr.chunks) {
          const current_possible_values = new Set();
          if (chunk.type === "Text") {
            current_possible_values.add(chunk.data);
          } else {
            gather_possible_values(chunk.node, current_possible_values);
          }
          if (current_possible_values.has(UNKNOWN))
            return true;
          if (prev_values.length > 0) {
            const start_with_space = [];
            const remaining = [];
            current_possible_values.forEach((current_possible_value) => {
              if (/^\s/.test(current_possible_value)) {
                start_with_space.push(current_possible_value);
              } else {
                remaining.push(current_possible_value);
              }
            });
            if (remaining.length > 0) {
              if (start_with_space.length > 0) {
                prev_values.forEach((prev_value) => possible_values.add(prev_value));
              }
              const combined = [];
              prev_values.forEach((prev_value) => {
                remaining.forEach((value2) => {
                  combined.push(prev_value + value2);
                });
              });
              prev_values = combined;
              start_with_space.forEach((value2) => {
                if (/\s$/.test(value2)) {
                  possible_values.add(value2);
                } else {
                  prev_values.push(value2);
                }
              });
              continue;
            } else {
              prev_values.forEach((prev_value) => possible_values.add(prev_value));
              prev_values = [];
            }
          }
          current_possible_values.forEach((current_possible_value) => {
            if (/\s$/.test(current_possible_value)) {
              possible_values.add(current_possible_value);
            } else {
              prev_values.push(current_possible_value);
            }
          });
          if (prev_values.length < current_possible_values.size) {
            prev_values.push(" ");
          }
          if (prev_values.length > 20) {
            return true;
          }
        }
        prev_values.forEach((prev_value) => possible_values.add(prev_value));
        if (possible_values.has(UNKNOWN))
          return true;
        for (const value2 of possible_values) {
          if (test_attribute(operator, expected_value, case_insensitive, value2))
            return true;
        }
        return false;
      }
      function unquote(value2) {
        if (value2.type === "Identifier")
          return value2.name;
        const str2 = value2.value;
        if (str2[0] === str2[str2.length - 1] && str2[0] === "'" || str2[0] === '"') {
          return str2.slice(1, str2.length - 1);
        }
        return str2;
      }
      function get_element_parent(node2) {
        let parent = node2;
        while ((parent = parent.parent) && parent.type !== "Element")
          ;
        return parent;
      }
      function get_possible_element_siblings(node2, adjacent_only) {
        const result = new Map();
        let prev = node2;
        while (prev = prev.prev) {
          if (prev.type === "Element") {
            if (!prev.attributes.find((attr) => attr.type === "Attribute" && attr.name.toLowerCase() === "slot")) {
              result.set(prev, NodeExist.Definitely);
            }
            if (adjacent_only) {
              break;
            }
          } else if (prev.type === "EachBlock" || prev.type === "IfBlock" || prev.type === "AwaitBlock") {
            const possible_last_child = get_possible_last_child(prev, adjacent_only);
            add_to_map(possible_last_child, result);
            if (adjacent_only && has_definite_elements(possible_last_child)) {
              return result;
            }
          }
        }
        if (!prev || !adjacent_only) {
          let parent = node2;
          let skip_each_for_last_child = node2.type === "ElseBlock";
          while ((parent = parent.parent) && (parent.type === "EachBlock" || parent.type === "IfBlock" || parent.type === "ElseBlock" || parent.type === "AwaitBlock")) {
            const possible_siblings = get_possible_element_siblings(parent, adjacent_only);
            add_to_map(possible_siblings, result);
            if (parent.type === "EachBlock") {
              if (skip_each_for_last_child) {
                skip_each_for_last_child = false;
              } else {
                add_to_map(get_possible_last_child(parent, adjacent_only), result);
              }
            } else if (parent.type === "ElseBlock") {
              skip_each_for_last_child = true;
              parent = parent.parent;
            }
            if (adjacent_only && has_definite_elements(possible_siblings)) {
              break;
            }
          }
        }
        return result;
      }
      function get_possible_last_child(block, adjacent_only) {
        const result = new Map();
        if (block.type === "EachBlock") {
          const each_result = loop_child(block.children, adjacent_only);
          const else_result = block.else ? loop_child(block.else.children, adjacent_only) : new Map();
          const not_exhaustive = !has_definite_elements(else_result);
          if (not_exhaustive) {
            mark_as_probably(each_result);
            mark_as_probably(else_result);
          }
          add_to_map(each_result, result);
          add_to_map(else_result, result);
        } else if (block.type === "IfBlock") {
          const if_result = loop_child(block.children, adjacent_only);
          const else_result = block.else ? loop_child(block.else.children, adjacent_only) : new Map();
          const not_exhaustive = !has_definite_elements(if_result) || !has_definite_elements(else_result);
          if (not_exhaustive) {
            mark_as_probably(if_result);
            mark_as_probably(else_result);
          }
          add_to_map(if_result, result);
          add_to_map(else_result, result);
        } else if (block.type === "AwaitBlock") {
          const pending_result = block.pending ? loop_child(block.pending.children, adjacent_only) : new Map();
          const then_result = block.then ? loop_child(block.then.children, adjacent_only) : new Map();
          const catch_result = block.catch ? loop_child(block.catch.children, adjacent_only) : new Map();
          const not_exhaustive = !has_definite_elements(pending_result) || !has_definite_elements(then_result) || !has_definite_elements(catch_result);
          if (not_exhaustive) {
            mark_as_probably(pending_result);
            mark_as_probably(then_result);
            mark_as_probably(catch_result);
          }
          add_to_map(pending_result, result);
          add_to_map(then_result, result);
          add_to_map(catch_result, result);
        }
        return result;
      }
      function has_definite_elements(result) {
        if (result.size === 0)
          return false;
        for (const exist of result.values()) {
          if (exist === NodeExist.Definitely) {
            return true;
          }
        }
        return false;
      }
      function add_to_map(from, to) {
        from.forEach((exist, element) => {
          to.set(element, higher_existence(exist, to.get(element)));
        });
      }
      function higher_existence(exist1, exist2) {
        if (exist1 === void 0 || exist2 === void 0)
          return exist1 || exist2;
        return exist1 > exist2 ? exist1 : exist2;
      }
      function mark_as_probably(result) {
        for (const key of result.keys()) {
          result.set(key, NodeExist.Probably);
        }
      }
      function loop_child(children, adjacent_only) {
        const result = new Map();
        for (let i2 = children.length - 1; i2 >= 0; i2--) {
          const child = children[i2];
          if (child.type === "Element") {
            result.set(child, NodeExist.Definitely);
            if (adjacent_only) {
              break;
            }
          } else if (child.type === "EachBlock" || child.type === "IfBlock" || child.type === "AwaitBlock") {
            const child_result = get_possible_last_child(child, adjacent_only);
            add_to_map(child_result, result);
            if (adjacent_only && has_definite_elements(child_result)) {
              break;
            }
          }
        }
        return result;
      }
      class Block$2 {
        constructor(combinator) {
          this.combinator = combinator;
          this.host = false;
          this.root = false;
          this.selectors = [];
          this.start = null;
          this.end = null;
          this.should_encapsulate = false;
        }
        add(selector2) {
          if (this.selectors.length === 0) {
            this.start = selector2.start;
            this.host = selector2.type === "PseudoClassSelector" && selector2.name === "host";
          }
          this.root = this.root || selector2.type === "PseudoClassSelector" && selector2.name === "root";
          this.selectors.push(selector2);
          this.end = selector2.end;
        }
        get global() {
          return this.selectors.length >= 1 && this.selectors[0].type === "PseudoClassSelector" && this.selectors[0].name === "global" && this.selectors.every((selector2) => selector2.type === "PseudoClassSelector" || selector2.type === "PseudoElementSelector");
        }
      }
      function group_selectors(selector2) {
        let block = new Block$2(null);
        const blocks = [block];
        selector2.children.forEach((child) => {
          if (child.type === "WhiteSpace" || child.type === "Combinator") {
            block = new Block$2(child);
            blocks.push(block);
          } else {
            block.add(child);
          }
        });
        return blocks;
      }
      function remove_css_prefix(name) {
        return name.replace(/^-((webkit)|(moz)|(o)|(ms))-/, "");
      }
      const is_keyframes_node = (node2) => remove_css_prefix(node2.name) === "keyframes";
      const at_rule_has_declaration = ({ block }) => block && block.children && block.children.find((node2) => node2.type === "Declaration");
      function minify_declarations(code, start, declarations) {
        let c2 = start;
        declarations.forEach((declaration, i2) => {
          const separator = i2 > 0 ? ";" : "";
          if (declaration.node.start - c2 > separator.length) {
            code.overwrite(c2, declaration.node.start, separator);
          }
          declaration.minify(code);
          c2 = declaration.node.end;
        });
        return c2;
      }
      class Rule$1 {
        constructor(node2, stylesheet, parent) {
          this.node = node2;
          this.parent = parent;
          this.selectors = node2.prelude.children.map((node3) => new Selector$1(node3, stylesheet));
          this.declarations = node2.block.children.map((node3) => new Declaration$1(node3));
        }
        apply(node2) {
          this.selectors.forEach((selector2) => selector2.apply(node2));
        }
        is_used(dev) {
          if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node))
            return true;
          if (this.declarations.length === 0)
            return dev;
          return this.selectors.some((s2) => s2.used);
        }
        minify(code, _dev) {
          let c2 = this.node.start;
          let started = false;
          this.selectors.forEach((selector2) => {
            if (selector2.used) {
              const separator = started ? "," : "";
              if (selector2.node.start - c2 > separator.length) {
                code.overwrite(c2, selector2.node.start, separator);
              }
              selector2.minify(code);
              c2 = selector2.node.end;
              started = true;
            }
          });
          code.remove(c2, this.node.block.start);
          c2 = this.node.block.start + 1;
          c2 = minify_declarations(code, c2, this.declarations);
          code.remove(c2, this.node.block.end - 1);
        }
        transform(code, id2, keyframes, max_amount_class_specificity_increased) {
          if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node))
            return true;
          const attr = `.${id2}`;
          this.selectors.forEach((selector2) => selector2.transform(code, attr, max_amount_class_specificity_increased));
          this.declarations.forEach((declaration) => declaration.transform(code, keyframes));
        }
        validate(component) {
          this.selectors.forEach((selector2) => {
            selector2.validate(component);
          });
        }
        warn_on_unused_selector(handler2) {
          this.selectors.forEach((selector2) => {
            if (!selector2.used)
              handler2(selector2);
          });
        }
        get_max_amount_class_specificity_increased() {
          return Math.max(...this.selectors.map((selector2) => selector2.get_amount_class_specificity_increased()));
        }
      }
      class Declaration$1 {
        constructor(node2) {
          this.node = node2;
        }
        transform(code, keyframes) {
          const property = this.node.property && remove_css_prefix(this.node.property.toLowerCase());
          if (property === "animation" || property === "animation-name") {
            this.node.value.children.forEach((block) => {
              if (block.type === "Identifier") {
                const name = block.name;
                if (keyframes.has(name)) {
                  code.overwrite(block.start, block.end, keyframes.get(name));
                }
              }
            });
          }
        }
        minify(code) {
          if (!this.node.property)
            return;
          const c2 = this.node.start + this.node.property.length;
          const first = this.node.value.children ? this.node.value.children[0] : this.node.value;
          let start = first.start;
          while (/\s/.test(code.original[start]))
            start += 1;
          if (start - c2 > 1) {
            code.overwrite(c2, start, ":");
          }
        }
      }
      class Atrule$1 {
        constructor(node2) {
          this.node = node2;
          this.children = [];
          this.declarations = [];
        }
        apply(node2) {
          if (this.node.name === "media" || this.node.name === "supports") {
            this.children.forEach((child) => {
              child.apply(node2);
            });
          } else if (is_keyframes_node(this.node)) {
            this.children.forEach((rule) => {
              rule.selectors.forEach((selector2) => {
                selector2.used = true;
              });
            });
          }
        }
        is_used(_dev) {
          return true;
        }
        minify(code, dev) {
          if (this.node.name === "media") {
            const expression_char = code.original[this.node.prelude.start];
            let c2 = this.node.start + (expression_char === "(" ? 6 : 7);
            if (this.node.prelude.start > c2)
              code.remove(c2, this.node.prelude.start);
            this.node.prelude.children.forEach((query) => {
              c2 = query.end;
            });
            code.remove(c2, this.node.block.start);
          } else if (this.node.name === "supports") {
            let c2 = this.node.start + 9;
            if (this.node.prelude.start - c2 > 1)
              code.overwrite(c2, this.node.prelude.start, " ");
            this.node.prelude.children.forEach((query) => {
              c2 = query.end;
            });
            code.remove(c2, this.node.block.start);
          } else {
            let c2 = this.node.start + this.node.name.length + 1;
            if (this.node.prelude) {
              if (this.node.prelude.start - c2 > 1)
                code.overwrite(c2, this.node.prelude.start, " ");
              c2 = this.node.prelude.end;
            }
            if (this.node.block && this.node.block.start - c2 > 0) {
              code.remove(c2, this.node.block.start);
            }
          }
          if (this.node.block) {
            let c2 = this.node.block.start + 1;
            if (this.declarations.length) {
              c2 = minify_declarations(code, c2, this.declarations);
              if (this.children.length)
                c2++;
            }
            this.children.forEach((child) => {
              if (child.is_used(dev)) {
                code.remove(c2, child.node.start);
                child.minify(code, dev);
                c2 = child.node.end;
              }
            });
            code.remove(c2, this.node.block.end - 1);
          }
        }
        transform(code, id2, keyframes, max_amount_class_specificity_increased) {
          if (is_keyframes_node(this.node)) {
            this.node.prelude.children.forEach(({ type, name, start, end }) => {
              if (type === "Identifier") {
                if (name.startsWith("-global-")) {
                  code.remove(start, start + 8);
                  this.children.forEach((rule) => {
                    rule.selectors.forEach((selector2) => {
                      selector2.used = true;
                    });
                  });
                } else {
                  code.overwrite(start, end, keyframes.get(name));
                }
              }
            });
          }
          this.children.forEach((child) => {
            child.transform(code, id2, keyframes, max_amount_class_specificity_increased);
          });
        }
        validate(component) {
          this.children.forEach((child) => {
            child.validate(component);
          });
        }
        warn_on_unused_selector(handler2) {
          if (this.node.name !== "media")
            return;
          this.children.forEach((child) => {
            child.warn_on_unused_selector(handler2);
          });
        }
        get_max_amount_class_specificity_increased() {
          return Math.max(...this.children.map((rule) => rule.get_max_amount_class_specificity_increased()));
        }
      }
      const get_default_css_hash = ({ css: css2, hash: hash3 }) => {
        return `svelte-${hash3(css2)}`;
      };
      class Stylesheet {
        constructor({ source, ast, component_name, filename, dev, get_css_hash = get_default_css_hash }) {
          this.children = [];
          this.keyframes = new Map();
          this.nodes_with_css_class = new Set();
          this.source = source;
          this.ast = ast;
          this.filename = filename;
          this.dev = dev;
          if (ast.css && ast.css.children.length) {
            this.id = get_css_hash({
              filename,
              name: component_name,
              css: ast.css.content.styles,
              hash: hash2
            });
            this.has_styles = true;
            const stack = [];
            let depth = 0;
            let current_atrule = null;
            walk(ast.css, {
              enter: (node2) => {
                if (node2.type === "Atrule") {
                  const atrule2 = new Atrule$1(node2);
                  stack.push(atrule2);
                  if (current_atrule) {
                    current_atrule.children.push(atrule2);
                  } else if (depth <= 1) {
                    this.children.push(atrule2);
                  }
                  if (is_keyframes_node(node2)) {
                    node2.prelude.children.forEach((expression2) => {
                      if (expression2.type === "Identifier" && !expression2.name.startsWith("-global-")) {
                        this.keyframes.set(expression2.name, `${this.id}-${expression2.name}`);
                      }
                    });
                  } else if (at_rule_has_declaration(node2)) {
                    const at_rule_declarations = node2.block.children.filter((node3) => node3.type === "Declaration").map((node3) => new Declaration$1(node3));
                    atrule2.declarations.push(...at_rule_declarations);
                  }
                  current_atrule = atrule2;
                }
                if (node2.type === "Rule") {
                  const rule = new Rule$1(node2, this, current_atrule);
                  if (current_atrule) {
                    current_atrule.children.push(rule);
                  } else if (depth <= 1) {
                    this.children.push(rule);
                  }
                }
                depth += 1;
              },
              leave: (node2) => {
                if (node2.type === "Atrule") {
                  stack.pop();
                  current_atrule = stack[stack.length - 1];
                }
                depth -= 1;
              }
            });
          } else {
            this.has_styles = false;
          }
        }
        apply(node2) {
          if (!this.has_styles)
            return;
          for (let i2 = 0; i2 < this.children.length; i2 += 1) {
            const child = this.children[i2];
            child.apply(node2);
          }
        }
        reify() {
          this.nodes_with_css_class.forEach((node2) => {
            node2.add_css_class();
          });
        }
        render(file, should_transform_selectors) {
          if (!this.has_styles) {
            return { code: null, map: null };
          }
          const code = new MagicString(this.source);
          walk(this.ast.css, {
            enter: (node2) => {
              code.addSourcemapLocation(node2.start);
              code.addSourcemapLocation(node2.end);
            }
          });
          if (should_transform_selectors) {
            const max = Math.max(...this.children.map((rule) => rule.get_max_amount_class_specificity_increased()));
            this.children.forEach((child) => {
              child.transform(code, this.id, this.keyframes, max);
            });
          }
          let c2 = 0;
          this.children.forEach((child) => {
            if (child.is_used(this.dev)) {
              code.remove(c2, child.node.start);
              child.minify(code, this.dev);
              c2 = child.node.end;
            }
          });
          code.remove(c2, this.source.length);
          return {
            code: code.toString(),
            map: code.generateMap({
              includeContent: true,
              source: this.filename,
              file
            })
          };
        }
        validate(component) {
          this.children.forEach((child) => {
            child.validate(component);
          });
        }
        warn_on_unused_selectors(component) {
          const ignores = !this.ast.css ? [] : extract_ignores_above_position(this.ast.css.start, this.ast.html.children);
          component.push_ignores(ignores);
          this.children.forEach((child) => {
            child.warn_on_unused_selector((selector2) => {
              component.warn(selector2.node, compiler_warnings.css_unused_selector(this.source.slice(selector2.node.start, selector2.node.end)));
            });
          });
          component.pop_ignores();
        }
      }
      const test = typeof process !== "undefined" && process.env.TEST;
      class TemplateScope {
        constructor(parent) {
          this.owners = new Map();
          this.parent = parent;
          this.names = new Set(parent ? parent.names : []);
          this.dependencies_for_name = new Map(parent ? parent.dependencies_for_name : []);
        }
        add(name, dependencies, owner) {
          this.names.add(name);
          this.dependencies_for_name.set(name, dependencies);
          this.owners.set(name, owner);
          return this;
        }
        child() {
          const child = new TemplateScope(this);
          return child;
        }
        is_top_level(name) {
          return !this.parent || !this.names.has(name) && this.parent.is_top_level(name);
        }
        get_owner(name) {
          return this.owners.get(name) || this.parent && this.parent.get_owner(name);
        }
        is_let(name) {
          const owner = this.get_owner(name);
          return owner && (owner.type === "Element" || owner.type === "InlineComponent" || owner.type === "SlotTemplate");
        }
        is_await(name) {
          const owner = this.get_owner(name);
          return owner && (owner.type === "ThenBlock" || owner.type === "CatchBlock");
        }
      }
      class Fragment extends Node$1 {
        constructor(component, info) {
          const scope2 = new TemplateScope();
          super(component, null, scope2, info);
          this.scope = scope2;
          this.children = map_children(component, this, scope2, info.children);
        }
      }
      var internal_exports = new Set(["HtmlTag", "HtmlTagHydration", "SvelteComponent", "SvelteComponentDev", "SvelteComponentTyped", "SvelteElement", "action_destroyer", "add_attribute", "add_classes", "add_flush_callback", "add_location", "add_render_callback", "add_resize_listener", "add_transform", "afterUpdate", "append", "append_dev", "append_empty_stylesheet", "append_hydration", "append_hydration_dev", "append_styles", "assign", "attr", "attr_dev", "attribute_to_object", "beforeUpdate", "bind", "binding_callbacks", "blank_object", "bubble", "check_outros", "children", "claim_component", "claim_element", "claim_html_tag", "claim_space", "claim_text", "clear_loops", "component_subscribe", "compute_rest_props", "compute_slots", "createEventDispatcher", "create_animation", "create_bidirectional_transition", "create_component", "create_in_transition", "create_out_transition", "create_slot", "create_ssr_component", "current_component", "custom_event", "dataset_dev", "debug", "destroy_block", "destroy_component", "destroy_each", "detach", "detach_after_dev", "detach_before_dev", "detach_between_dev", "detach_dev", "dirty_components", "dispatch_dev", "each", "element", "element_is", "empty", "end_hydrating", "escape", "escape_attribute_value", "escape_object", "escaped", "exclude_internal_props", "fix_and_destroy_block", "fix_and_outro_and_destroy_block", "fix_position", "flush", "getAllContexts", "getContext", "get_all_dirty_from_scope", "get_binding_group_value", "get_current_component", "get_custom_elements_slots", "get_root_for_style", "get_slot_changes", "get_spread_object", "get_spread_update", "get_store_value", "globals", "group_outros", "handle_promise", "hasContext", "has_prop", "identity", "init", "insert", "insert_dev", "insert_hydration", "insert_hydration_dev", "intros", "invalid_attribute_name_character", "is_client", "is_crossorigin", "is_empty", "is_function", "is_promise", "listen", "listen_dev", "loop", "loop_guard", "missing_component", "mount_component", "noop", "not_equal", "now", "null_to_empty", "object_without_properties", "onDestroy", "onMount", "once", "outro_and_destroy_block", "prevent_default", "prop_dev", "query_selector_all", "raf", "run", "run_all", "safe_not_equal", "schedule_update", "select_multiple_value", "select_option", "select_options", "select_value", "self", "setContext", "set_attributes", "set_current_component", "set_custom_element_data", "set_data", "set_data_dev", "set_input_type", "set_input_value", "set_now", "set_raf", "set_store_value", "set_style", "set_svg_attributes", "space", "spread", "src_url_equal", "start_hydrating", "stop_propagation", "subscribe", "svg_element", "text", "tick", "time_ranges_to_array", "to_number", "toggle_class", "transition_in", "transition_out", "trusted", "update_await_block_branch", "update_keyed_each", "update_slot", "update_slot_base", "validate_component", "validate_each_argument", "validate_each_keys", "validate_slots", "validate_store", "xlink_attr"]);
      function is_used_as_reference(node2, parent) {
        if (!is_reference(node2, parent)) {
          return false;
        }
        if (!parent) {
          return true;
        }
        switch (parent.type) {
          case "VariableDeclarator":
            return node2 !== parent.id;
          case "FunctionDeclaration":
          case "ImportSpecifier":
          case "ImportDefaultSpecifier":
          case "ImportNamespaceSpecifier":
          case "ExportSpecifier":
            return false;
          default:
            return true;
        }
      }
      function check_graph_for_cycles(edges) {
        const graph = edges.reduce((g, edge) => {
          const [u, v] = edge;
          if (!g.has(u))
            g.set(u, []);
          if (!g.has(v))
            g.set(v, []);
          g.get(u).push(v);
          return g;
        }, new Map());
        const visited = new Set();
        const on_stack = new Set();
        const cycles = [];
        function visit(v) {
          visited.add(v);
          on_stack.add(v);
          graph.get(v).forEach((w) => {
            if (!visited.has(w)) {
              visit(w);
            } else if (on_stack.has(w)) {
              cycles.push([...on_stack, w]);
            }
          });
          on_stack.delete(v);
        }
        graph.forEach((_, v) => {
          if (!visited.has(v)) {
            visit(v);
          }
        });
        return cycles[0];
      }
      class Component {
        constructor(ast, source, name, compile_options, stats, warnings) {
          this.ignore_stack = [];
          this.vars = [];
          this.var_lookup = new Map();
          this.imports = [];
          this.exports_from = [];
          this.instance_exports_from = [];
          this.hoistable_nodes = new Set();
          this.node_for_declaration = new Map();
          this.partly_hoisted = [];
          this.fully_hoisted = [];
          this.reactive_declarations = [];
          this.reactive_declaration_nodes = new Set();
          this.has_reactive_assignments = false;
          this.injected_reactive_declaration_vars = new Set();
          this.helpers = new Map();
          this.globals = new Map();
          this.indirect_dependencies = new Map();
          this.elements = [];
          this.aliases = new Map();
          this.used_names = new Set();
          this.globally_used_names = new Set();
          this.slots = new Map();
          this.slot_outlets = new Set();
          this.name = { type: "Identifier", name };
          this.stats = stats;
          this.warnings = warnings;
          this.ast = ast;
          this.source = source;
          this.compile_options = compile_options;
          this.original_ast = clone2({
            html: ast.html,
            css: ast.css,
            instance: ast.instance,
            module: ast.module
          });
          this.file = compile_options.filename && (typeof process !== "undefined" ? compile_options.filename.replace(process.cwd(), "").replace(/^[/\\]/, "") : compile_options.filename);
          this.locate = getLocator(this.source, { offsetLine: 1 });
          this.stylesheet = new Stylesheet({
            source,
            ast,
            filename: compile_options.filename,
            component_name: name,
            dev: compile_options.dev,
            get_css_hash: compile_options.cssHash
          });
          this.stylesheet.validate(this);
          this.component_options = process_component_options(this, this.ast.html.children);
          this.namespace = namespaces[this.component_options.namespace] || this.component_options.namespace;
          if (compile_options.customElement) {
            if (this.component_options.tag === void 0 && compile_options.tag === void 0) {
              const svelteOptions = ast.html.children.find((child) => child.name === "svelte:options") || { start: 0, end: 0 };
              this.warn(svelteOptions, compiler_warnings.custom_element_no_tag);
            }
            this.tag = this.component_options.tag || compile_options.tag;
          } else {
            this.tag = this.name.name;
          }
          this.walk_module_js();
          this.push_ignores(this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []);
          this.walk_instance_js_pre_template();
          this.pop_ignores();
          this.fragment = new Fragment(this, ast.html);
          this.name = this.get_unique_name(name);
          this.push_ignores(this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []);
          this.walk_instance_js_post_template();
          this.pop_ignores();
          this.elements.forEach((element) => this.stylesheet.apply(element));
          if (!compile_options.customElement)
            this.stylesheet.reify();
          this.stylesheet.warn_on_unused_selectors(this);
        }
        add_var(variable, add_to_lookup = true) {
          this.vars.push(variable);
          if (add_to_lookup) {
            this.var_lookup.set(variable.name, variable);
          }
        }
        add_reference(name) {
          const variable = this.var_lookup.get(name);
          if (variable) {
            variable.referenced = true;
          } else if (is_reserved_keyword(name)) {
            this.add_var({
              name,
              injected: true,
              referenced: true
            });
          } else if (name[0] === "$") {
            this.add_var({
              name,
              injected: true,
              referenced: true,
              mutated: true,
              writable: true
            });
            const subscribable_name = name.slice(1);
            const variable2 = this.var_lookup.get(subscribable_name);
            if (variable2) {
              variable2.referenced = true;
              variable2.subscribable = true;
            }
          } else {
            if (this.compile_options.varsReport === "full") {
              this.add_var({ name, referenced: true }, false);
            }
            this.used_names.add(name);
          }
        }
        alias(name) {
          if (!this.aliases.has(name)) {
            this.aliases.set(name, this.get_unique_name(name));
          }
          return this.aliases.get(name);
        }
        apply_stylesheet(element) {
          this.elements.push(element);
        }
        global(name) {
          const alias = this.alias(name);
          this.globals.set(name, alias);
          return alias;
        }
        generate(result) {
          let js = null;
          let css2 = null;
          if (result) {
            const { compile_options, name } = this;
            const { format: format2 = "esm" } = compile_options;
            const banner = `${this.file ? `${this.file} ` : ""}generated by Svelte v${"3.42.1"}`;
            const program = { type: "Program", body: result.js };
            walk(program, {
              enter: (node2, parent, key) => {
                if (node2.type === "Identifier") {
                  if (node2.name[0] === "@") {
                    if (node2.name[1] === "_") {
                      const alias = this.global(node2.name.slice(2));
                      node2.name = alias.name;
                    } else {
                      let name2 = node2.name.slice(1);
                      if (compile_options.hydratable) {
                        if (internal_exports.has(`${name2}_hydration`)) {
                          name2 += "_hydration";
                        } else if (internal_exports.has(`${name2}Hydration`)) {
                          name2 += "Hydration";
                        }
                      }
                      if (compile_options.dev) {
                        if (internal_exports.has(`${name2}_dev`)) {
                          name2 += "_dev";
                        } else if (internal_exports.has(`${name2}Dev`)) {
                          name2 += "Dev";
                        }
                      }
                      const alias = this.alias(name2);
                      this.helpers.set(name2, alias);
                      node2.name = alias.name;
                    }
                  } else if (node2.name[0] !== "#" && !is_valid(node2.name)) {
                    const literal2 = { type: "Literal", value: node2.name };
                    if (parent.type === "Property" && key === "key") {
                      parent.key = literal2;
                    } else if (parent.type === "MemberExpression" && key === "property") {
                      parent.property = literal2;
                      parent.computed = true;
                    }
                  }
                }
              }
            });
            const referenced_globals = Array.from(this.globals, ([name2, alias]) => name2 !== alias.name && { name: name2, alias }).filter(Boolean);
            if (referenced_globals.length) {
              this.helpers.set("globals", this.alias("globals"));
            }
            const imported_helpers = Array.from(this.helpers, ([name2, alias]) => ({
              name: name2,
              alias
            }));
            create_module(program, format2, name, banner, compile_options.sveltePath, imported_helpers, referenced_globals, this.imports, this.vars.filter((variable) => variable.module && variable.export_name).map((variable) => ({
              name: variable.name,
              as: variable.export_name
            })), this.exports_from);
            css2 = compile_options.customElement ? { code: null, map: null } : result.css;
            const sourcemap_source_filename = get_sourcemap_source_filename(compile_options);
            js = print(program, {
              sourceMapSource: sourcemap_source_filename
            });
            js.map.sources = [
              sourcemap_source_filename
            ];
            js.map.sourcesContent = [
              this.source
            ];
            js.map = apply_preprocessor_sourcemap(sourcemap_source_filename, js.map, compile_options.sourcemap);
          }
          return {
            js,
            css: css2,
            ast: this.original_ast,
            warnings: this.warnings,
            vars: this.get_vars_report(),
            stats: this.stats.render()
          };
        }
        get_unique_name(name, scope2) {
          if (test)
            name = `${name}$`;
          let alias = name;
          for (let i2 = 1; reserved2.has(alias) || this.var_lookup.has(alias) || this.used_names.has(alias) || this.globally_used_names.has(alias) || scope2 && scope2.has(alias); alias = `${name}_${i2++}`)
            ;
          this.used_names.add(alias);
          return { type: "Identifier", name: alias };
        }
        get_unique_name_maker() {
          const local_used_names = new Set();
          function add(name) {
            local_used_names.add(name);
          }
          reserved2.forEach(add);
          internal_exports.forEach(add);
          this.var_lookup.forEach((_value, key) => add(key));
          return (name) => {
            if (test)
              name = `${name}$`;
            let alias = name;
            for (let i2 = 1; this.used_names.has(alias) || local_used_names.has(alias); alias = `${name}_${i2++}`)
              ;
            local_used_names.add(alias);
            this.globally_used_names.add(alias);
            return {
              type: "Identifier",
              name: alias
            };
          };
        }
        get_vars_report() {
          const { compile_options, vars } = this;
          const vars_report = compile_options.varsReport === false ? [] : compile_options.varsReport === "full" ? vars : vars.filter((v) => !v.global && !v.internal);
          return vars_report.map((v) => ({
            name: v.name,
            export_name: v.export_name || null,
            injected: v.injected || false,
            module: v.module || false,
            mutated: v.mutated || false,
            reassigned: v.reassigned || false,
            referenced: v.referenced || false,
            writable: v.writable || false,
            referenced_from_script: v.referenced_from_script || false
          }));
        }
        error(pos, e) {
          if (this.compile_options.errorMode === "warn") {
            this.warn(pos, e);
          } else {
            error3(e.message, {
              name: "ValidationError",
              code: e.code,
              source: this.source,
              start: pos.start,
              end: pos.end,
              filename: this.compile_options.filename
            });
          }
        }
        warn(pos, warning) {
          if (this.ignores && this.ignores.has(warning.code)) {
            return;
          }
          const start = this.locate(pos.start);
          const end = this.locate(pos.end);
          const frame = get_code_frame(this.source, start.line - 1, start.column);
          this.warnings.push({
            code: warning.code,
            message: warning.message,
            frame,
            start,
            end,
            pos: pos.start,
            filename: this.compile_options.filename,
            toString: () => `${warning.message} (${start.line}:${start.column})
${frame}`
          });
        }
        extract_imports(node2) {
          this.imports.push(node2);
        }
        extract_exports(node2, module_script = false) {
          const ignores = extract_svelte_ignore_from_comments(node2);
          if (ignores.length)
            this.push_ignores(ignores);
          const result = this._extract_exports(node2, module_script);
          if (ignores.length)
            this.pop_ignores();
          return result;
        }
        _extract_exports(node2, module_script) {
          if (node2.type === "ExportDefaultDeclaration") {
            return this.error(node2, compiler_errors.default_export);
          }
          if (node2.type === "ExportNamedDeclaration") {
            if (node2.source) {
              if (module_script) {
                this.exports_from.push(node2);
              } else {
                this.instance_exports_from.push(node2);
              }
              return null;
            }
            if (node2.declaration) {
              if (node2.declaration.type === "VariableDeclaration") {
                node2.declaration.declarations.forEach((declarator) => {
                  extract_names(declarator.id).forEach((name) => {
                    const variable = this.var_lookup.get(name);
                    variable.export_name = name;
                    if (variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) {
                      this.warn(declarator, compiler_warnings.unused_export_let(this.name.name, name));
                    }
                  });
                });
              } else {
                const { name } = node2.declaration.id;
                const variable = this.var_lookup.get(name);
                variable.export_name = name;
              }
              return node2.declaration;
            } else {
              node2.specifiers.forEach((specifier) => {
                const variable = this.var_lookup.get(specifier.local.name);
                if (variable) {
                  variable.export_name = specifier.exported.name;
                  if (variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) {
                    this.warn(specifier, compiler_warnings.unused_export_let(this.name.name, specifier.exported.name));
                  }
                }
              });
              return null;
            }
          }
        }
        extract_javascript(script) {
          if (!script)
            return null;
          return script.content.body.filter((node2) => {
            if (!node2)
              return false;
            if (this.hoistable_nodes.has(node2))
              return false;
            if (this.reactive_declaration_nodes.has(node2))
              return false;
            if (node2.type === "ImportDeclaration")
              return false;
            if (node2.type === "ExportDeclaration" && node2.specifiers.length > 0)
              return false;
            return true;
          });
        }
        walk_module_js() {
          const component = this;
          const script = this.ast.module;
          if (!script)
            return;
          walk(script.content, {
            enter(node2) {
              if (node2.type === "LabeledStatement" && node2.label.name === "$") {
                component.warn(node2, compiler_warnings.module_script_reactive_declaration);
              }
            }
          });
          const { scope: scope2, globals: globals2 } = create_scopes(script.content);
          this.module_scope = scope2;
          scope2.declarations.forEach((node2, name) => {
            if (name[0] === "$") {
              return this.error(node2, compiler_errors.illegal_declaration);
            }
            const writable2 = node2.type === "VariableDeclaration" && (node2.kind === "var" || node2.kind === "let");
            this.add_var({
              name,
              module: true,
              hoistable: true,
              writable: writable2
            });
          });
          globals2.forEach((node2, name) => {
            if (name[0] === "$") {
              return this.error(node2, compiler_errors.illegal_subscription);
            } else {
              this.add_var({
                name,
                global: true,
                hoistable: true
              });
            }
          });
          const { body } = script.content;
          let i2 = body.length;
          while (--i2 >= 0) {
            const node2 = body[i2];
            if (node2.type === "ImportDeclaration") {
              this.extract_imports(node2);
              body.splice(i2, 1);
            }
            if (/^Export/.test(node2.type)) {
              const replacement = this.extract_exports(node2, true);
              if (replacement) {
                body[i2] = replacement;
              } else {
                body.splice(i2, 1);
              }
            }
          }
        }
        walk_instance_js_pre_template() {
          const script = this.ast.instance;
          if (!script)
            return;
          script.content.body.forEach((node2) => {
            if (node2.type !== "LabeledStatement")
              return;
            if (node2.body.type !== "ExpressionStatement")
              return;
            const { expression: expression2 } = node2.body;
            if (expression2.type !== "AssignmentExpression")
              return;
            if (expression2.left.type === "MemberExpression")
              return;
            extract_names(expression2.left).forEach((name) => {
              if (!this.var_lookup.has(name) && name[0] !== "$") {
                this.injected_reactive_declaration_vars.add(name);
              }
            });
          });
          const { scope: instance_scope, map, globals: globals2 } = create_scopes(script.content);
          this.instance_scope = instance_scope;
          this.instance_scope_map = map;
          instance_scope.declarations.forEach((node2, name) => {
            if (name[0] === "$") {
              return this.error(node2, compiler_errors.illegal_declaration);
            }
            const writable2 = node2.type === "VariableDeclaration" && (node2.kind === "var" || node2.kind === "let");
            const imported = node2.type.startsWith("Import");
            this.add_var({
              name,
              initialised: instance_scope.initialised_declarations.has(name),
              writable: writable2,
              imported
            });
            this.node_for_declaration.set(name, node2);
          });
          const global_keys = Array.from(globals2.keys());
          const sorted_globals = [
            ...global_keys.filter((key) => key[0] !== "$"),
            ...global_keys.filter((key) => key[0] === "$")
          ];
          sorted_globals.forEach((name) => {
            if (this.var_lookup.has(name))
              return;
            const node2 = globals2.get(name);
            if (this.injected_reactive_declaration_vars.has(name)) {
              this.add_var({
                name,
                injected: true,
                writable: true,
                reassigned: true,
                initialised: true
              });
            } else if (is_reserved_keyword(name)) {
              this.add_var({
                name,
                injected: true
              });
            } else if (name[0] === "$") {
              if (name === "$" || name[1] === "$") {
                return this.error(node2, compiler_errors.illegal_global(name));
              }
              this.add_var({
                name,
                injected: true,
                mutated: true,
                writable: true
              });
              this.add_reference(name.slice(1));
              const variable = this.var_lookup.get(name.slice(1));
              if (variable) {
                variable.subscribable = true;
                variable.referenced_from_script = true;
              }
            } else {
              this.add_var({
                name,
                global: true,
                hoistable: true
              });
            }
          });
          this.track_references_and_mutations();
        }
        walk_instance_js_post_template() {
          const script = this.ast.instance;
          if (!script)
            return;
          this.post_template_walk();
          this.hoist_instance_declarations();
          this.extract_reactive_declarations();
        }
        post_template_walk() {
          const script = this.ast.instance;
          if (!script)
            return;
          const component = this;
          const { content } = script;
          const { instance_scope, instance_scope_map: map } = this;
          let scope2 = instance_scope;
          const to_remove = [];
          const remove = (parent, prop, index2) => {
            to_remove.unshift([parent, prop, index2]);
          };
          let scope_updated = false;
          let generator_count = 0;
          walk(content, {
            enter(node2, parent, prop, index2) {
              if ((node2.type === "FunctionDeclaration" || node2.type === "FunctionExpression") && node2.generator === true) {
                generator_count++;
              }
              if (map.has(node2)) {
                scope2 = map.get(node2);
              }
              if (node2.type === "ImportDeclaration") {
                component.extract_imports(node2);
                remove(parent, prop, index2);
                return this.skip();
              }
              if (/^Export/.test(node2.type)) {
                const replacement = component.extract_exports(node2);
                if (replacement) {
                  this.replace(replacement);
                } else {
                  remove(parent, prop, index2);
                }
                return this.skip();
              }
              component.warn_on_undefined_store_value_references(node2, parent, prop, scope2);
            },
            leave(node2) {
              if ((node2.type === "FunctionDeclaration" || node2.type === "FunctionExpression") && node2.generator === true) {
                generator_count--;
              }
              if (component.compile_options.dev && component.compile_options.loopGuardTimeout > 0 && generator_count <= 0) {
                const to_replace_for_loop_protect = component.loop_protect(node2, scope2, component.compile_options.loopGuardTimeout);
                if (to_replace_for_loop_protect) {
                  this.replace(to_replace_for_loop_protect);
                  scope_updated = true;
                }
              }
              if (map.has(node2)) {
                scope2 = scope2.parent;
              }
            }
          });
          for (const [parent, prop, index2] of to_remove) {
            if (parent) {
              if (index2 !== null) {
                parent[prop].splice(index2, 1);
              } else {
                delete parent[prop];
              }
            }
          }
          if (scope_updated) {
            const { scope: scope3, map: map2 } = create_scopes(script.content);
            this.instance_scope = scope3;
            this.instance_scope_map = map2;
          }
        }
        track_references_and_mutations() {
          const script = this.ast.instance;
          if (!script)
            return;
          const component = this;
          const { content } = script;
          const { instance_scope, module_scope, instance_scope_map: map } = this;
          let scope2 = instance_scope;
          walk(content, {
            enter(node2, parent) {
              if (map.has(node2)) {
                scope2 = map.get(node2);
              }
              if (node2.type === "AssignmentExpression" || node2.type === "UpdateExpression") {
                const assignee = node2.type === "AssignmentExpression" ? node2.left : node2.argument;
                const names2 = extract_names(assignee);
                const deep = assignee.type === "MemberExpression";
                names2.forEach((name) => {
                  const scope_owner = scope2.find_owner(name);
                  if (scope_owner !== null ? scope_owner === instance_scope : module_scope && module_scope.has(name)) {
                    const variable = component.var_lookup.get(name);
                    variable[deep ? "mutated" : "reassigned"] = true;
                  }
                });
              }
              if (is_used_as_reference(node2, parent)) {
                const object = get_object(node2);
                if (scope2.find_owner(object.name) === instance_scope) {
                  const variable = component.var_lookup.get(object.name);
                  variable.referenced_from_script = true;
                }
              }
            },
            leave(node2) {
              if (map.has(node2)) {
                scope2 = scope2.parent;
              }
            }
          });
        }
        warn_on_undefined_store_value_references(node2, parent, prop, scope2) {
          if (node2.type === "LabeledStatement" && node2.label.name === "$" && parent.type !== "Program") {
            this.warn(node2, compiler_warnings.non_top_level_reactive_declaration);
          }
          if (is_reference(node2, parent)) {
            const object = get_object(node2);
            const { name } = object;
            if (name[0] === "$") {
              if (!scope2.has(name)) {
                this.warn_if_undefined(name, object, null);
              }
              if (name[1] !== "$" && scope2.has(name.slice(1)) && scope2.find_owner(name.slice(1)) !== this.instance_scope) {
                if (!(/Function/.test(parent.type) && prop === "params" || parent.type === "VariableDeclarator" && prop === "id")) {
                  return this.error(node2, compiler_errors.contextual_store);
                }
              }
            }
          }
        }
        loop_protect(node2, scope2, timeout) {
          if (node2.type === "WhileStatement" || node2.type === "ForStatement" || node2.type === "DoWhileStatement") {
            const guard = this.get_unique_name("guard", scope2);
            this.used_names.add(guard.name);
            const before = b`const ${guard} = @loop_guard(${timeout})`;
            const inside = b`${guard}();`;
            if (node2.body.type !== "BlockStatement") {
              node2.body = {
                type: "BlockStatement",
                body: [node2.body]
              };
            }
            node2.body.body.push(inside[0]);
            return {
              type: "BlockStatement",
              body: [
                before[0],
                node2
              ]
            };
          }
          return null;
        }
        rewrite_props(get_insert) {
          if (!this.ast.instance)
            return;
          const component = this;
          const { instance_scope, instance_scope_map: map } = this;
          let scope2 = instance_scope;
          walk(this.ast.instance.content, {
            enter(node2) {
              if (/Function/.test(node2.type)) {
                return this.skip();
              }
              if (map.has(node2)) {
                scope2 = map.get(node2);
              }
              if (node2.type === "ExportNamedDeclaration" && node2.declaration) {
                return this.replace(node2.declaration);
              }
              if (node2.type === "VariableDeclaration") {
                if (node2.kind === "var" || scope2 === instance_scope) {
                  let add_new_props = function(exported, local, default_value) {
                    props.push({
                      type: "Property",
                      method: false,
                      shorthand: false,
                      computed: false,
                      kind: "init",
                      key: exported,
                      value: default_value ? {
                        type: "AssignmentPattern",
                        left: local,
                        right: default_value
                      } : local
                    });
                  };
                  const inserts = [];
                  const props = [];
                  for (let index2 = 0; index2 < node2.declarations.length; index2++) {
                    const declarator = node2.declarations[index2];
                    if (declarator.id.type !== "Identifier") {
                      let get_new_name = function(local) {
                        const variable = component.var_lookup.get(local.name);
                        if (variable.subscribable) {
                          inserts.push(get_insert(variable));
                        }
                        if (variable.export_name && variable.writable) {
                          const alias_name = component.get_unique_name(local.name);
                          add_new_props({ type: "Identifier", name: variable.export_name }, local, alias_name);
                          return alias_name;
                        }
                        return local;
                      }, rename_identifiers = function(param) {
                        switch (param.type) {
                          case "ObjectPattern": {
                            const handle_prop = (prop) => {
                              if (prop.type === "RestElement") {
                                rename_identifiers(prop);
                              } else if (prop.value.type === "Identifier") {
                                prop.value = get_new_name(prop.value);
                              } else {
                                rename_identifiers(prop.value);
                              }
                            };
                            param.properties.forEach(handle_prop);
                            break;
                          }
                          case "ArrayPattern": {
                            const handle_element = (element, index3, array) => {
                              if (element) {
                                if (element.type === "Identifier") {
                                  array[index3] = get_new_name(element);
                                } else {
                                  rename_identifiers(element);
                                }
                              }
                            };
                            param.elements.forEach(handle_element);
                            break;
                          }
                          case "RestElement":
                            param.argument = get_new_name(param.argument);
                            break;
                          case "AssignmentPattern":
                            param.left = get_new_name(param.left);
                            break;
                        }
                      };
                      rename_identifiers(declarator.id);
                    } else {
                      const { name } = declarator.id;
                      const variable = component.var_lookup.get(name);
                      const is_props = variable.export_name && variable.writable;
                      if (is_props) {
                        add_new_props({ type: "Identifier", name: variable.export_name }, declarator.id, declarator.init);
                        node2.declarations.splice(index2--, 1);
                      }
                      if (variable.subscribable && (is_props || declarator.init)) {
                        inserts.push(get_insert(variable));
                      }
                    }
                  }
                  this.replace(b`
							${node2.declarations.length ? node2 : null}
							${props.length > 0 && b`let { ${props} } = $$props;`}
							${inserts}
						`);
                  return this.skip();
                }
              }
            },
            leave(node2) {
              if (map.has(node2)) {
                scope2 = scope2.parent;
              }
            }
          });
        }
        hoist_instance_declarations() {
          const { hoistable_nodes, var_lookup, injected_reactive_declaration_vars, imports } = this;
          const top_level_function_declarations = new Map();
          const { body } = this.ast.instance.content;
          for (let i2 = 0; i2 < body.length; i2 += 1) {
            const node2 = body[i2];
            if (node2.type === "VariableDeclaration") {
              const all_hoistable = node2.declarations.every((d2) => {
                if (!d2.init)
                  return false;
                if (d2.init.type !== "Literal")
                  return false;
                if (node2.kind !== "const" && this.compile_options.dev)
                  return false;
                const { name } = d2.id;
                const v = this.var_lookup.get(name);
                if (v.reassigned)
                  return false;
                if (v.export_name)
                  return false;
                if (this.var_lookup.get(name).reassigned)
                  return false;
                if (this.vars.find((variable) => variable.name === name && variable.module)) {
                  return false;
                }
                return true;
              });
              if (all_hoistable) {
                node2.declarations.forEach((d2) => {
                  const variable = this.var_lookup.get(d2.id.name);
                  variable.hoistable = true;
                });
                hoistable_nodes.add(node2);
                body.splice(i2--, 1);
                this.fully_hoisted.push(node2);
              }
            }
            if (node2.type === "ExportNamedDeclaration" && node2.declaration && node2.declaration.type === "FunctionDeclaration") {
              top_level_function_declarations.set(node2.declaration.id.name, node2);
            }
            if (node2.type === "FunctionDeclaration") {
              top_level_function_declarations.set(node2.id.name, node2);
            }
          }
          const checked = new Set();
          const walking = new Set();
          const is_hoistable = (fn_declaration) => {
            if (fn_declaration.type === "ExportNamedDeclaration") {
              fn_declaration = fn_declaration.declaration;
            }
            const instance_scope = this.instance_scope;
            let scope2 = this.instance_scope;
            const map = this.instance_scope_map;
            let hoistable = true;
            walking.add(fn_declaration);
            walk(fn_declaration, {
              enter(node2, parent) {
                if (!hoistable)
                  return this.skip();
                if (map.has(node2)) {
                  scope2 = map.get(node2);
                }
                if (is_reference(node2, parent)) {
                  const { name } = flatten_reference(node2);
                  const owner = scope2.find_owner(name);
                  if (injected_reactive_declaration_vars.has(name)) {
                    hoistable = false;
                  } else if (name[0] === "$" && !owner) {
                    hoistable = false;
                  } else if (owner === instance_scope) {
                    const variable = var_lookup.get(name);
                    if (variable.reassigned || variable.mutated)
                      hoistable = false;
                    if (name === fn_declaration.id.name)
                      return;
                    if (variable.hoistable)
                      return;
                    if (top_level_function_declarations.has(name)) {
                      const other_declaration = top_level_function_declarations.get(name);
                      if (walking.has(other_declaration)) {
                        hoistable = false;
                      } else if (other_declaration.type === "ExportNamedDeclaration" && walking.has(other_declaration.declaration)) {
                        hoistable = false;
                      } else if (!is_hoistable(other_declaration)) {
                        hoistable = false;
                      }
                    } else {
                      hoistable = false;
                    }
                  }
                  this.skip();
                }
              },
              leave(node2) {
                if (map.has(node2)) {
                  scope2 = scope2.parent;
                }
              }
            });
            checked.add(fn_declaration);
            walking.delete(fn_declaration);
            return hoistable;
          };
          for (const [name, node2] of top_level_function_declarations) {
            if (is_hoistable(node2)) {
              const variable = this.var_lookup.get(name);
              variable.hoistable = true;
              hoistable_nodes.add(node2);
              const i2 = body.indexOf(node2);
              body.splice(i2, 1);
              this.fully_hoisted.push(node2);
            }
          }
          for (const { specifiers } of imports) {
            for (const specifier of specifiers) {
              const variable = var_lookup.get(specifier.local.name);
              if (!variable.mutated || variable.subscribable) {
                variable.hoistable = true;
              }
            }
          }
        }
        extract_reactive_declarations() {
          const component = this;
          const unsorted_reactive_declarations = [];
          this.ast.instance.content.body.forEach((node2) => {
            const ignores = extract_svelte_ignore_from_comments(node2);
            if (ignores.length)
              this.push_ignores(ignores);
            if (node2.type === "LabeledStatement" && node2.label.name === "$") {
              this.reactive_declaration_nodes.add(node2);
              const assignees = new Set();
              const assignee_nodes = new Set();
              const dependencies = new Set();
              const module_dependencies = new Set();
              let scope2 = this.instance_scope;
              const map = this.instance_scope_map;
              walk(node2.body, {
                enter(node3, parent) {
                  if (map.has(node3)) {
                    scope2 = map.get(node3);
                  }
                  if (node3.type === "AssignmentExpression") {
                    const left = get_object(node3.left);
                    extract_identifiers(left).forEach((node4) => {
                      assignee_nodes.add(node4);
                      assignees.add(node4.name);
                    });
                    if (node3.operator !== "=") {
                      dependencies.add(left.name);
                    }
                  } else if (node3.type === "UpdateExpression") {
                    const identifier = get_object(node3.argument);
                    assignees.add(identifier.name);
                  } else if (is_reference(node3, parent)) {
                    const identifier = get_object(node3);
                    if (!assignee_nodes.has(identifier)) {
                      const { name } = identifier;
                      const owner = scope2.find_owner(name);
                      const variable = component.var_lookup.get(name);
                      let should_add_as_dependency = true;
                      if (variable) {
                        variable.is_reactive_dependency = true;
                        if (variable.module && variable.writable) {
                          should_add_as_dependency = false;
                          module_dependencies.add(name);
                        }
                      }
                      const is_writable_or_mutated = variable && (variable.writable || variable.mutated);
                      if (should_add_as_dependency && (!owner || owner === component.instance_scope) && (name[0] === "$" || is_writable_or_mutated)) {
                        dependencies.add(name);
                      }
                    }
                    this.skip();
                  }
                },
                leave(node3) {
                  if (map.has(node3)) {
                    scope2 = scope2.parent;
                  }
                }
              });
              if (module_dependencies.size > 0 && dependencies.size === 0) {
                component.warn(node2.body, compiler_warnings.module_script_variable_reactive_declaration(Array.from(module_dependencies)));
              }
              const { expression: expression2 } = node2.body;
              const declaration = expression2 && expression2.left;
              unsorted_reactive_declarations.push({
                assignees,
                dependencies,
                node: node2,
                declaration
              });
            }
            if (ignores.length)
              this.pop_ignores();
          });
          const lookup = new Map();
          unsorted_reactive_declarations.forEach((declaration) => {
            declaration.assignees.forEach((name) => {
              if (!lookup.has(name)) {
                lookup.set(name, []);
              }
              lookup.get(name).push(declaration);
            });
          });
          const cycle = check_graph_for_cycles(unsorted_reactive_declarations.reduce((acc, declaration) => {
            declaration.assignees.forEach((v) => {
              declaration.dependencies.forEach((w) => {
                if (!declaration.assignees.has(w)) {
                  acc.push([v, w]);
                }
              });
            });
            return acc;
          }, []));
          if (cycle && cycle.length) {
            const declarationList = lookup.get(cycle[0]);
            const declaration = declarationList[0];
            return this.error(declaration.node, compiler_errors.cyclical_reactive_declaration(cycle));
          }
          const add_declaration = (declaration) => {
            if (this.reactive_declarations.includes(declaration))
              return;
            declaration.dependencies.forEach((name) => {
              if (declaration.assignees.has(name))
                return;
              const earlier_declarations = lookup.get(name);
              if (earlier_declarations) {
                earlier_declarations.forEach(add_declaration);
              }
            });
            this.reactive_declarations.push(declaration);
          };
          unsorted_reactive_declarations.forEach(add_declaration);
        }
        warn_if_undefined(name, node2, template_scope) {
          if (name[0] === "$") {
            if (name === "$" || name[1] === "$" && !is_reserved_keyword(name)) {
              return this.error(node2, compiler_errors.illegal_global(name));
            }
            this.has_reactive_assignments = true;
            if (is_reserved_keyword(name))
              return;
            name = name.slice(1);
          }
          if (this.var_lookup.has(name) && !this.var_lookup.get(name).global)
            return;
          if (template_scope && template_scope.names.has(name))
            return;
          if (globals.has(name) && node2.type !== "InlineComponent")
            return;
          this.warn(node2, compiler_warnings.missing_declaration(name, !!this.ast.instance));
        }
        push_ignores(ignores) {
          this.ignores = new Set(this.ignores || []);
          add_to_set(this.ignores, ignores);
          this.ignore_stack.push(this.ignores);
        }
        pop_ignores() {
          this.ignore_stack.pop();
          this.ignores = this.ignore_stack[this.ignore_stack.length - 1];
        }
      }
      function process_component_options(component, nodes) {
        const component_options = {
          immutable: component.compile_options.immutable || false,
          accessors: "accessors" in component.compile_options ? component.compile_options.accessors : !!component.compile_options.customElement,
          preserveWhitespace: !!component.compile_options.preserveWhitespace,
          namespace: component.compile_options.namespace
        };
        const node2 = nodes.find((node3) => node3.name === "svelte:options");
        function get_value2(attribute, { code, message }) {
          const { value: value2 } = attribute;
          const chunk = value2[0];
          if (!chunk)
            return true;
          if (value2.length > 1) {
            return component.error(attribute, { code, message });
          }
          if (chunk.type === "Text")
            return chunk.data;
          if (chunk.expression.type !== "Literal") {
            return component.error(attribute, { code, message });
          }
          return chunk.expression.value;
        }
        if (node2) {
          node2.attributes.forEach((attribute) => {
            if (attribute.type === "Attribute") {
              const { name } = attribute;
              switch (name) {
                case "tag": {
                  const tag2 = get_value2(attribute, compiler_errors.invalid_tag_attribute);
                  if (typeof tag2 !== "string" && tag2 !== null) {
                    return component.error(attribute, compiler_errors.invalid_tag_attribute);
                  }
                  if (tag2 && !/^[a-zA-Z][a-zA-Z0-9]*-[a-zA-Z0-9-]+$/.test(tag2)) {
                    return component.error(attribute, compiler_errors.invalid_tag_property);
                  }
                  if (tag2 && !component.compile_options.customElement) {
                    component.warn(attribute, compiler_warnings.missing_custom_element_compile_options);
                  }
                  component_options.tag = tag2;
                  break;
                }
                case "namespace": {
                  const ns = get_value2(attribute, compiler_errors.invalid_namespace_attribute);
                  if (typeof ns !== "string") {
                    return component.error(attribute, compiler_errors.invalid_namespace_attribute);
                  }
                  if (valid_namespaces.indexOf(ns) === -1) {
                    const match = fuzzymatch(ns, valid_namespaces);
                    return component.error(attribute, compiler_errors.invalid_namespace_property(ns, match));
                  }
                  component_options.namespace = ns;
                  break;
                }
                case "accessors":
                case "immutable":
                case "preserveWhitespace": {
                  const value2 = get_value2(attribute, compiler_errors.invalid_attribute_value(name));
                  if (typeof value2 !== "boolean") {
                    return component.error(attribute, compiler_errors.invalid_attribute_value(name));
                  }
                  component_options[name] = value2;
                  break;
                }
                default:
                  return component.error(attribute, compiler_errors.invalid_options_attribute_unknown);
              }
            } else {
              return component.error(attribute, compiler_errors.invalid_options_attribute);
            }
          });
        }
        return component_options;
      }
      function get_relative_path(from, to) {
        const from_parts = from.split(/[/\\]/);
        const to_parts = to.split(/[/\\]/);
        from_parts.pop();
        while (from_parts[0] === to_parts[0]) {
          from_parts.shift();
          to_parts.shift();
        }
        if (from_parts.length) {
          let i2 = from_parts.length;
          while (i2--)
            from_parts[i2] = "..";
        }
        return from_parts.concat(to_parts).join("/");
      }
      function get_basename(filename) {
        return filename.split(/[/\\]/).pop();
      }
      function get_sourcemap_source_filename(compile_options) {
        if (!compile_options.filename)
          return null;
        return compile_options.outputFilename ? get_relative_path(compile_options.outputFilename, compile_options.filename) : get_basename(compile_options.filename);
      }
      function get_name_from_filename(filename) {
        if (!filename)
          return null;
        const parts = filename.split(/[/\\]/).map(encodeURI);
        if (parts.length > 1) {
          const index_match = parts[parts.length - 1].match(/^index(\.\w+)/);
          if (index_match) {
            parts.pop();
            parts[parts.length - 1] += index_match[1];
          }
        }
        const base2 = parts.pop().replace(/%/g, "u").replace(/\.[^.]+$/, "").replace(/[^a-zA-Z_$0-9]+/g, "_").replace(/^_/, "").replace(/_$/, "").replace(/^(\d)/, "_$1");
        if (!base2) {
          throw new Error(`Could not derive component name from file ${filename}`);
        }
        return base2[0].toUpperCase() + base2.slice(1);
      }
      const valid_options = [
        "format",
        "name",
        "filename",
        "sourcemap",
        "generate",
        "errorMode",
        "varsReport",
        "outputFilename",
        "cssOutputFilename",
        "sveltePath",
        "dev",
        "accessors",
        "immutable",
        "hydratable",
        "legacy",
        "customElement",
        "namespace",
        "tag",
        "css",
        "loopGuardTimeout",
        "preserveComments",
        "preserveWhitespace",
        "cssHash"
      ];
      function validate_options(options3, warnings) {
        const { name, filename, loopGuardTimeout, dev, namespace } = options3;
        Object.keys(options3).forEach((key) => {
          if (!valid_options.includes(key)) {
            const match = fuzzymatch(key, valid_options);
            let message = `Unrecognized option '${key}'`;
            if (match)
              message += ` (did you mean '${match}'?)`;
            throw new Error(message);
          }
        });
        if (name && !/^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name)) {
          throw new Error(`options.name must be a valid identifier (got '${name}')`);
        }
        if (name && /^[a-z]/.test(name)) {
          const message = "options.name should be capitalised";
          warnings.push({
            code: "options-lowercase-name",
            message,
            filename,
            toString: () => message
          });
        }
        if (loopGuardTimeout && !dev) {
          const message = "options.loopGuardTimeout is for options.dev = true only";
          warnings.push({
            code: "options-loop-guard-timeout",
            message,
            filename,
            toString: () => message
          });
        }
        if (namespace && valid_namespaces.indexOf(namespace) === -1) {
          const match = fuzzymatch(namespace, valid_namespaces);
          if (match) {
            throw new Error(`Invalid namespace '${namespace}' (did you mean '${match}'?)`);
          } else {
            throw new Error(`Invalid namespace '${namespace}'`);
          }
        }
      }
      function compile2(source, options3 = {}) {
        options3 = Object.assign({ generate: "dom", dev: false }, options3);
        const stats = new Stats();
        const warnings = [];
        validate_options(options3, warnings);
        stats.start("parse");
        const ast = parse$3(source, options3);
        stats.stop("parse");
        stats.start("create component");
        const component = new Component(ast, source, options3.name || get_name_from_filename(options3.filename) || "Component", options3, stats, warnings);
        stats.stop("create component");
        const result = options3.generate === false ? null : options3.generate === "ssr" ? ssr(component, options3) : dom(component, options3);
        return component.generate(result);
      }
      function decoded_sourcemap_from_generator(generator) {
        let previous_generated_line = 1;
        const converted_mappings = [[]];
        let result_line;
        let result_segment;
        let mapping;
        const source_idx = generator._sources.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
        const name_idx = generator._names.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
        const mappings = generator._mappings.toArray();
        result_line = converted_mappings[0];
        for (let i2 = 0, len = mappings.length; i2 < len; i2++) {
          mapping = mappings[i2];
          if (mapping.generatedLine > previous_generated_line) {
            while (mapping.generatedLine > previous_generated_line) {
              converted_mappings.push([]);
              previous_generated_line++;
            }
            result_line = converted_mappings[mapping.generatedLine - 1];
          } else if (i2 > 0) {
            const previous_mapping = mappings[i2 - 1];
            if (mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source) {
              continue;
            }
          }
          result_line.push([mapping.generatedColumn]);
          result_segment = result_line[result_line.length - 1];
          if (mapping.source != null) {
            result_segment.push(...[
              source_idx[mapping.source],
              mapping.originalLine - 1,
              mapping.originalColumn
            ]);
            if (mapping.name != null) {
              result_segment.push(name_idx[mapping.name]);
            }
          }
        }
        const map = {
          version: generator._version,
          sources: generator._sources.toArray(),
          names: generator._names.toArray(),
          mappings: converted_mappings
        };
        if (generator._file != null) {
          map.file = generator._file;
        }
        return map;
      }
      function decode_map(processed) {
        let decoded_map = typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map;
        if (typeof decoded_map.mappings === "string") {
          decoded_map.mappings = decode(decoded_map.mappings);
        }
        if (decoded_map._mappings && decoded_map.constructor.name === "SourceMapGenerator") {
          decoded_map = decoded_sourcemap_from_generator(decoded_map);
        }
        return decoded_map;
      }
      function slice_source(code_slice, offset, { file_basename, filename, get_location }) {
        return {
          source: code_slice,
          get_location: (index2) => get_location(index2 + offset),
          file_basename,
          filename
        };
      }
      function calculate_replacements(re2, get_replacement, source) {
        const replacements = [];
        source.replace(re2, (...match) => {
          replacements.push(get_replacement(...match).then((replacement) => {
            const matched_string = match[0];
            const offset = match[match.length - 2];
            return { offset, length: matched_string.length, replacement };
          }));
          return "";
        });
        return Promise.all(replacements);
      }
      function perform_replacements(replacements, source) {
        const out = new MappedCode();
        let last_end = 0;
        for (const { offset, length, replacement } of replacements) {
          const unchanged_prefix = MappedCode.from_source(slice_source(source.source.slice(last_end, offset), last_end, source));
          out.concat(unchanged_prefix).concat(replacement);
          last_end = offset + length;
        }
        const unchanged_suffix = MappedCode.from_source(slice_source(source.source.slice(last_end), last_end, source));
        return out.concat(unchanged_suffix);
      }
      async function replace_in_code(regex, get_replacement, location) {
        const replacements = await calculate_replacements(regex, get_replacement, location.source);
        return perform_replacements(replacements, location);
      }
      function get_file_basename(filename) {
        return filename.split(/[/\\]/).pop();
      }
      class PreprocessResult {
        constructor(source, filename) {
          this.source = source;
          this.filename = filename;
          this.sourcemap_list = [];
          this.dependencies = [];
          this.update_source({ string: source });
          this.file_basename = filename == null ? null : get_file_basename(filename);
        }
        update_source({ string: source, map, dependencies }) {
          if (source != null) {
            this.source = source;
            this.get_location = getLocator(source);
          }
          if (map) {
            this.sourcemap_list.unshift(map);
          }
          if (dependencies) {
            this.dependencies.push(...dependencies);
          }
        }
        to_processed() {
          const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
          return {
            code: this.source,
            dependencies: [...new Set(this.dependencies)],
            map,
            toString: () => this.source
          };
        }
      }
      function processed_content_to_code(processed, location, file_basename) {
        let decoded_map;
        if (processed.map) {
          decoded_map = decode_map(processed);
          const source_index = decoded_map.sources.indexOf(file_basename);
          if (source_index !== -1) {
            sourcemap_add_offset(decoded_map, location, source_index);
          }
        }
        return MappedCode.from_processed(processed.code, decoded_map);
      }
      function processed_tag_to_code(processed, tag_name, attributes, source) {
        const { file_basename, get_location } = source;
        const build_mapped_code = (code, offset) => MappedCode.from_source(slice_source(code, offset, source));
        const tag_open = `<${tag_name}${attributes || ""}>`;
        const tag_close = `</${tag_name}>`;
        const tag_open_code = build_mapped_code(tag_open, 0);
        const tag_close_code = build_mapped_code(tag_close, tag_open.length + source.source.length);
        parse_attached_sourcemap(processed, tag_name);
        const content_code = processed_content_to_code(processed, get_location(tag_open.length), file_basename);
        return tag_open_code.concat(content_code).concat(tag_close_code);
      }
      function parse_tag_attributes(str2) {
        return str2.split(/\s+/).filter(Boolean).reduce((attrs, attr) => {
          var _a;
          const i2 = attr.indexOf("=");
          const [key, value2] = i2 > 0 ? [attr.slice(0, i2), attr.slice(i2 + 1)] : [attr];
          const [, unquoted] = value2 && value2.match(/^['"](.*)['"]$/) || [];
          return Object.assign(Object.assign({}, attrs), { [key]: (_a = unquoted !== null && unquoted !== void 0 ? unquoted : value2, _a !== null && _a !== void 0 ? _a : true) });
        }, {});
      }
      async function process_tag(tag_name, preprocessor, source) {
        const { filename, source: markup } = source;
        const tag_regex = tag_name === "style" ? /<!--[^]*?-->|<style(\s[^]*?)?(?:>([^]*?)<\/style>|\/>)/gi : /<!--[^]*?-->|<script(\s[^]*?)?(?:>([^]*?)<\/script>|\/>)/gi;
        const dependencies = [];
        async function process_single_tag(tag_with_content, attributes = "", content = "", tag_offset) {
          const no_change = () => MappedCode.from_source(slice_source(tag_with_content, tag_offset, source));
          if (!attributes && !content)
            return no_change();
          const processed = await preprocessor({
            content: content || "",
            attributes: parse_tag_attributes(attributes || ""),
            markup,
            filename
          });
          if (!processed)
            return no_change();
          if (processed.dependencies)
            dependencies.push(...processed.dependencies);
          if (!processed.map && processed.code === content)
            return no_change();
          return processed_tag_to_code(processed, tag_name, attributes, slice_source(content, tag_offset, source));
        }
        const { string, map } = await replace_in_code(tag_regex, process_single_tag, source);
        return { string, map, dependencies };
      }
      async function process_markup(filename, process2, source) {
        const processed = await process2({
          content: source.source,
          filename
        });
        if (processed) {
          return {
            string: processed.code,
            map: processed.map ? typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map : void 0,
            dependencies: processed.dependencies
          };
        } else {
          return {};
        }
      }
      async function preprocess(source, preprocessor, options3) {
        const filename = options3 && options3.filename || preprocessor.filename;
        const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [preprocessor] : [];
        const markup = preprocessors.map((p2) => p2.markup).filter(Boolean);
        const script = preprocessors.map((p2) => p2.script).filter(Boolean);
        const style = preprocessors.map((p2) => p2.style).filter(Boolean);
        const result = new PreprocessResult(source, filename);
        for (const process2 of markup) {
          result.update_source(await process_markup(filename, process2, result));
        }
        for (const process2 of script) {
          result.update_source(await process_tag("script", process2, result));
        }
        for (const preprocess2 of style) {
          result.update_source(await process_tag("style", preprocess2, result));
        }
        return result.to_processed();
      }
      const VERSION = "3.42.1";
      exports3.VERSION = VERSION;
      exports3.compile = compile2;
      exports3.parse = parse$3;
      exports3.preprocess = preprocess;
      exports3.walk = walk;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/prismjs/components.json
var require_components = __commonJS({
  "node_modules/prismjs/components.json"(exports2, module2) {
    module2.exports = {
      core: {
        meta: {
          path: "components/prism-core.js",
          option: "mandatory"
        },
        core: "Core"
      },
      themes: {
        meta: {
          path: "themes/{id}.css",
          link: "index.html?theme={id}",
          exclusive: true
        },
        prism: {
          title: "Default",
          option: "default"
        },
        "prism-dark": "Dark",
        "prism-funky": "Funky",
        "prism-okaidia": {
          title: "Okaidia",
          owner: "ocodia"
        },
        "prism-twilight": {
          title: "Twilight",
          owner: "remybach"
        },
        "prism-coy": {
          title: "Coy",
          owner: "tshedor"
        },
        "prism-solarizedlight": {
          title: "Solarized Light",
          owner: "hectormatos2011 "
        },
        "prism-tomorrow": {
          title: "Tomorrow Night",
          owner: "Rosey"
        }
      },
      languages: {
        meta: {
          path: "components/prism-{id}",
          noCSS: true,
          examplesPath: "examples/prism-{id}",
          addCheckAll: true
        },
        markup: {
          title: "Markup",
          alias: ["html", "xml", "svg", "mathml", "ssml", "atom", "rss"],
          aliasTitles: {
            html: "HTML",
            xml: "XML",
            svg: "SVG",
            mathml: "MathML",
            ssml: "SSML",
            atom: "Atom",
            rss: "RSS"
          },
          option: "default"
        },
        css: {
          title: "CSS",
          option: "default",
          modify: "markup"
        },
        clike: {
          title: "C-like",
          option: "default"
        },
        javascript: {
          title: "JavaScript",
          require: "clike",
          modify: "markup",
          optional: "regex",
          alias: "js",
          option: "default"
        },
        abap: {
          title: "ABAP",
          owner: "dellagustin"
        },
        abnf: {
          title: "ABNF",
          owner: "RunDevelopment"
        },
        actionscript: {
          title: "ActionScript",
          require: "javascript",
          modify: "markup",
          owner: "Golmote"
        },
        ada: {
          title: "Ada",
          owner: "Lucretia"
        },
        agda: {
          title: "Agda",
          owner: "xy-ren"
        },
        al: {
          title: "AL",
          owner: "RunDevelopment"
        },
        antlr4: {
          title: "ANTLR4",
          alias: "g4",
          owner: "RunDevelopment"
        },
        apacheconf: {
          title: "Apache Configuration",
          owner: "GuiTeK"
        },
        apex: {
          title: "Apex",
          require: ["clike", "sql"],
          owner: "RunDevelopment"
        },
        apl: {
          title: "APL",
          owner: "ngn"
        },
        applescript: {
          title: "AppleScript",
          owner: "Golmote"
        },
        aql: {
          title: "AQL",
          owner: "RunDevelopment"
        },
        arduino: {
          title: "Arduino",
          require: "cpp",
          owner: "dkern"
        },
        arff: {
          title: "ARFF",
          owner: "Golmote"
        },
        asciidoc: {
          alias: "adoc",
          title: "AsciiDoc",
          owner: "Golmote"
        },
        aspnet: {
          title: "ASP.NET (C#)",
          require: ["markup", "csharp"],
          owner: "nauzilus"
        },
        asm6502: {
          title: "6502 Assembly",
          owner: "kzurawel"
        },
        autohotkey: {
          title: "AutoHotkey",
          owner: "aviaryan"
        },
        autoit: {
          title: "AutoIt",
          owner: "Golmote"
        },
        bash: {
          title: "Bash",
          alias: "shell",
          aliasTitles: {
            shell: "Shell"
          },
          owner: "zeitgeist87"
        },
        basic: {
          title: "BASIC",
          owner: "Golmote"
        },
        batch: {
          title: "Batch",
          owner: "Golmote"
        },
        bbcode: {
          title: "BBcode",
          alias: "shortcode",
          aliasTitles: {
            shortcode: "Shortcode"
          },
          owner: "RunDevelopment"
        },
        birb: {
          title: "Birb",
          require: "clike",
          owner: "Calamity210"
        },
        bison: {
          title: "Bison",
          require: "c",
          owner: "Golmote"
        },
        bnf: {
          title: "BNF",
          alias: "rbnf",
          aliasTitles: {
            rbnf: "RBNF"
          },
          owner: "RunDevelopment"
        },
        brainfuck: {
          title: "Brainfuck",
          owner: "Golmote"
        },
        brightscript: {
          title: "BrightScript",
          owner: "RunDevelopment"
        },
        bro: {
          title: "Bro",
          owner: "wayward710"
        },
        bsl: {
          title: "BSL (1C:Enterprise)",
          alias: "oscript",
          aliasTitles: {
            oscript: "OneScript"
          },
          owner: "Diversus23"
        },
        c: {
          title: "C",
          require: "clike",
          owner: "zeitgeist87"
        },
        csharp: {
          title: "C#",
          require: "clike",
          alias: ["cs", "dotnet"],
          owner: "mvalipour"
        },
        cpp: {
          title: "C++",
          require: "c",
          owner: "zeitgeist87"
        },
        cfscript: {
          title: "CFScript",
          require: "clike",
          alias: "cfc",
          owner: "mjclemente"
        },
        chaiscript: {
          title: "ChaiScript",
          require: ["clike", "cpp"],
          owner: "RunDevelopment"
        },
        cil: {
          title: "CIL",
          owner: "sbrl"
        },
        clojure: {
          title: "Clojure",
          owner: "troglotit"
        },
        cmake: {
          title: "CMake",
          owner: "mjrogozinski"
        },
        cobol: {
          title: "COBOL",
          owner: "RunDevelopment"
        },
        coffeescript: {
          title: "CoffeeScript",
          require: "javascript",
          alias: "coffee",
          owner: "R-osey"
        },
        concurnas: {
          title: "Concurnas",
          alias: "conc",
          owner: "jasontatton"
        },
        csp: {
          title: "Content-Security-Policy",
          owner: "ScottHelme"
        },
        coq: {
          title: "Coq",
          owner: "RunDevelopment"
        },
        crystal: {
          title: "Crystal",
          require: "ruby",
          owner: "MakeNowJust"
        },
        "css-extras": {
          title: "CSS Extras",
          require: "css",
          modify: "css",
          owner: "milesj"
        },
        csv: {
          title: "CSV",
          owner: "RunDevelopment"
        },
        cypher: {
          title: "Cypher",
          owner: "RunDevelopment"
        },
        d: {
          title: "D",
          require: "clike",
          owner: "Golmote"
        },
        dart: {
          title: "Dart",
          require: "clike",
          owner: "Golmote"
        },
        dataweave: {
          title: "DataWeave",
          owner: "machaval"
        },
        dax: {
          title: "DAX",
          owner: "peterbud"
        },
        dhall: {
          title: "Dhall",
          owner: "RunDevelopment"
        },
        diff: {
          title: "Diff",
          owner: "uranusjr"
        },
        django: {
          title: "Django/Jinja2",
          require: "markup-templating",
          alias: "jinja2",
          owner: "romanvm"
        },
        "dns-zone-file": {
          title: "DNS zone file",
          owner: "RunDevelopment",
          alias: "dns-zone"
        },
        docker: {
          title: "Docker",
          alias: "dockerfile",
          owner: "JustinBeckwith"
        },
        dot: {
          title: "DOT (Graphviz)",
          alias: "gv",
          optional: "markup",
          owner: "RunDevelopment"
        },
        ebnf: {
          title: "EBNF",
          owner: "RunDevelopment"
        },
        editorconfig: {
          title: "EditorConfig",
          owner: "osipxd"
        },
        eiffel: {
          title: "Eiffel",
          owner: "Conaclos"
        },
        ejs: {
          title: "EJS",
          require: ["javascript", "markup-templating"],
          owner: "RunDevelopment",
          alias: "eta",
          aliasTitles: {
            eta: "Eta"
          }
        },
        elixir: {
          title: "Elixir",
          owner: "Golmote"
        },
        elm: {
          title: "Elm",
          owner: "zwilias"
        },
        etlua: {
          title: "Embedded Lua templating",
          require: ["lua", "markup-templating"],
          owner: "RunDevelopment"
        },
        erb: {
          title: "ERB",
          require: ["ruby", "markup-templating"],
          owner: "Golmote"
        },
        erlang: {
          title: "Erlang",
          owner: "Golmote"
        },
        "excel-formula": {
          title: "Excel Formula",
          alias: ["xlsx", "xls"],
          owner: "RunDevelopment"
        },
        fsharp: {
          title: "F#",
          require: "clike",
          owner: "simonreynolds7"
        },
        factor: {
          title: "Factor",
          owner: "catb0t"
        },
        false: {
          title: "False",
          owner: "edukisto"
        },
        "firestore-security-rules": {
          title: "Firestore security rules",
          require: "clike",
          owner: "RunDevelopment"
        },
        flow: {
          title: "Flow",
          require: "javascript",
          owner: "Golmote"
        },
        fortran: {
          title: "Fortran",
          owner: "Golmote"
        },
        ftl: {
          title: "FreeMarker Template Language",
          require: "markup-templating",
          owner: "RunDevelopment"
        },
        gml: {
          title: "GameMaker Language",
          alias: "gamemakerlanguage",
          require: "clike",
          owner: "LiarOnce"
        },
        gcode: {
          title: "G-code",
          owner: "RunDevelopment"
        },
        gdscript: {
          title: "GDScript",
          owner: "RunDevelopment"
        },
        gedcom: {
          title: "GEDCOM",
          owner: "Golmote"
        },
        gherkin: {
          title: "Gherkin",
          owner: "hason"
        },
        git: {
          title: "Git",
          owner: "lgiraudel"
        },
        glsl: {
          title: "GLSL",
          require: "c",
          owner: "Golmote"
        },
        go: {
          title: "Go",
          require: "clike",
          owner: "arnehormann"
        },
        graphql: {
          title: "GraphQL",
          optional: "markdown",
          owner: "Golmote"
        },
        groovy: {
          title: "Groovy",
          require: "clike",
          owner: "robfletcher"
        },
        haml: {
          title: "Haml",
          require: "ruby",
          optional: [
            "css",
            "css-extras",
            "coffeescript",
            "erb",
            "javascript",
            "less",
            "markdown",
            "scss",
            "textile"
          ],
          owner: "Golmote"
        },
        handlebars: {
          title: "Handlebars",
          require: "markup-templating",
          alias: "hbs",
          owner: "Golmote"
        },
        haskell: {
          title: "Haskell",
          alias: "hs",
          owner: "bholst"
        },
        haxe: {
          title: "Haxe",
          require: "clike",
          owner: "Golmote"
        },
        hcl: {
          title: "HCL",
          owner: "outsideris"
        },
        hlsl: {
          title: "HLSL",
          require: "c",
          owner: "RunDevelopment"
        },
        http: {
          title: "HTTP",
          optional: [
            "css",
            "javascript",
            "json",
            "markup",
            "uri"
          ],
          owner: "danielgtaylor"
        },
        hpkp: {
          title: "HTTP Public-Key-Pins",
          owner: "ScottHelme"
        },
        hsts: {
          title: "HTTP Strict-Transport-Security",
          owner: "ScottHelme"
        },
        ichigojam: {
          title: "IchigoJam",
          owner: "BlueCocoa"
        },
        icon: {
          title: "Icon",
          owner: "Golmote"
        },
        "icu-message-format": {
          title: "ICU Message Format",
          owner: "RunDevelopment"
        },
        idris: {
          title: "Idris",
          alias: "idr",
          owner: "KeenS",
          require: "haskell"
        },
        ignore: {
          title: ".ignore",
          owner: "osipxd",
          alias: [
            "gitignore",
            "hgignore",
            "npmignore"
          ],
          aliasTitles: {
            gitignore: ".gitignore",
            hgignore: ".hgignore",
            npmignore: ".npmignore"
          }
        },
        inform7: {
          title: "Inform 7",
          owner: "Golmote"
        },
        ini: {
          title: "Ini",
          owner: "aviaryan"
        },
        io: {
          title: "Io",
          owner: "AlesTsurko"
        },
        j: {
          title: "J",
          owner: "Golmote"
        },
        java: {
          title: "Java",
          require: "clike",
          owner: "sherblot"
        },
        javadoc: {
          title: "JavaDoc",
          require: ["markup", "java", "javadoclike"],
          modify: "java",
          optional: "scala",
          owner: "RunDevelopment"
        },
        javadoclike: {
          title: "JavaDoc-like",
          modify: [
            "java",
            "javascript",
            "php"
          ],
          owner: "RunDevelopment"
        },
        javastacktrace: {
          title: "Java stack trace",
          owner: "RunDevelopment"
        },
        jexl: {
          title: "Jexl",
          owner: "czosel"
        },
        jolie: {
          title: "Jolie",
          require: "clike",
          owner: "thesave"
        },
        jq: {
          title: "JQ",
          owner: "RunDevelopment"
        },
        jsdoc: {
          title: "JSDoc",
          require: ["javascript", "javadoclike", "typescript"],
          modify: "javascript",
          optional: [
            "actionscript",
            "coffeescript"
          ],
          owner: "RunDevelopment"
        },
        "js-extras": {
          title: "JS Extras",
          require: "javascript",
          modify: "javascript",
          optional: [
            "actionscript",
            "coffeescript",
            "flow",
            "n4js",
            "typescript"
          ],
          owner: "RunDevelopment"
        },
        json: {
          title: "JSON",
          alias: "webmanifest",
          aliasTitles: {
            webmanifest: "Web App Manifest"
          },
          owner: "CupOfTea696"
        },
        json5: {
          title: "JSON5",
          require: "json",
          owner: "RunDevelopment"
        },
        jsonp: {
          title: "JSONP",
          require: "json",
          owner: "RunDevelopment"
        },
        jsstacktrace: {
          title: "JS stack trace",
          owner: "sbrl"
        },
        "js-templates": {
          title: "JS Templates",
          require: "javascript",
          modify: "javascript",
          optional: [
            "css",
            "css-extras",
            "graphql",
            "markdown",
            "markup",
            "sql"
          ],
          owner: "RunDevelopment"
        },
        julia: {
          title: "Julia",
          owner: "cdagnino"
        },
        keyman: {
          title: "Keyman",
          owner: "mcdurdin"
        },
        kotlin: {
          title: "Kotlin",
          alias: ["kt", "kts"],
          aliasTitles: {
            kts: "Kotlin Script"
          },
          require: "clike",
          owner: "Golmote"
        },
        kumir: {
          title: "KuMir (\u041A\u0443\u041C\u0438\u0440)",
          alias: "kum",
          owner: "edukisto"
        },
        latex: {
          title: "LaTeX",
          alias: ["tex", "context"],
          aliasTitles: {
            tex: "TeX",
            context: "ConTeXt"
          },
          owner: "japborst"
        },
        latte: {
          title: "Latte",
          require: ["clike", "markup-templating", "php"],
          owner: "nette"
        },
        less: {
          title: "Less",
          require: "css",
          optional: "css-extras",
          owner: "Golmote"
        },
        lilypond: {
          title: "LilyPond",
          require: "scheme",
          alias: "ly",
          owner: "RunDevelopment"
        },
        liquid: {
          title: "Liquid",
          require: "markup-templating",
          owner: "cinhtau"
        },
        lisp: {
          title: "Lisp",
          alias: ["emacs", "elisp", "emacs-lisp"],
          owner: "JuanCaicedo"
        },
        livescript: {
          title: "LiveScript",
          owner: "Golmote"
        },
        llvm: {
          title: "LLVM IR",
          owner: "porglezomp"
        },
        log: {
          title: "Log file",
          owner: "RunDevelopment"
        },
        lolcode: {
          title: "LOLCODE",
          owner: "Golmote"
        },
        lua: {
          title: "Lua",
          owner: "Golmote"
        },
        makefile: {
          title: "Makefile",
          owner: "Golmote"
        },
        markdown: {
          title: "Markdown",
          require: "markup",
          optional: "yaml",
          alias: "md",
          owner: "Golmote"
        },
        "markup-templating": {
          title: "Markup templating",
          require: "markup",
          owner: "Golmote"
        },
        matlab: {
          title: "MATLAB",
          owner: "Golmote"
        },
        mel: {
          title: "MEL",
          owner: "Golmote"
        },
        mizar: {
          title: "Mizar",
          owner: "Golmote"
        },
        mongodb: {
          title: "MongoDB",
          owner: "airs0urce",
          require: "javascript"
        },
        monkey: {
          title: "Monkey",
          owner: "Golmote"
        },
        moonscript: {
          title: "MoonScript",
          alias: "moon",
          owner: "RunDevelopment"
        },
        n1ql: {
          title: "N1QL",
          owner: "TMWilds"
        },
        n4js: {
          title: "N4JS",
          require: "javascript",
          optional: "jsdoc",
          alias: "n4jsd",
          owner: "bsmith-n4"
        },
        "nand2tetris-hdl": {
          title: "Nand To Tetris HDL",
          owner: "stephanmax"
        },
        naniscript: {
          title: "Naninovel Script",
          owner: "Elringus",
          alias: "nani"
        },
        nasm: {
          title: "NASM",
          owner: "rbmj"
        },
        neon: {
          title: "NEON",
          owner: "nette"
        },
        nevod: {
          title: "Nevod",
          owner: "nezaboodka"
        },
        nginx: {
          title: "nginx",
          owner: "volado"
        },
        nim: {
          title: "Nim",
          owner: "Golmote"
        },
        nix: {
          title: "Nix",
          owner: "Golmote"
        },
        nsis: {
          title: "NSIS",
          owner: "idleberg"
        },
        objectivec: {
          title: "Objective-C",
          require: "c",
          alias: "objc",
          owner: "uranusjr"
        },
        ocaml: {
          title: "OCaml",
          owner: "Golmote"
        },
        opencl: {
          title: "OpenCL",
          require: "c",
          modify: [
            "c",
            "cpp"
          ],
          owner: "Milania1"
        },
        openqasm: {
          title: "OpenQasm",
          alias: "qasm",
          owner: "RunDevelopment"
        },
        oz: {
          title: "Oz",
          owner: "Golmote"
        },
        parigp: {
          title: "PARI/GP",
          owner: "Golmote"
        },
        parser: {
          title: "Parser",
          require: "markup",
          owner: "Golmote"
        },
        pascal: {
          title: "Pascal",
          alias: "objectpascal",
          aliasTitles: {
            objectpascal: "Object Pascal"
          },
          owner: "Golmote"
        },
        pascaligo: {
          title: "Pascaligo",
          owner: "DefinitelyNotAGoat"
        },
        psl: {
          title: "PATROL Scripting Language",
          owner: "bertysentry"
        },
        pcaxis: {
          title: "PC-Axis",
          alias: "px",
          owner: "RunDevelopment"
        },
        peoplecode: {
          title: "PeopleCode",
          alias: "pcode",
          owner: "RunDevelopment"
        },
        perl: {
          title: "Perl",
          owner: "Golmote"
        },
        php: {
          title: "PHP",
          require: "markup-templating",
          owner: "milesj"
        },
        phpdoc: {
          title: "PHPDoc",
          require: ["php", "javadoclike"],
          modify: "php",
          owner: "RunDevelopment"
        },
        "php-extras": {
          title: "PHP Extras",
          require: "php",
          modify: "php",
          owner: "milesj"
        },
        plsql: {
          title: "PL/SQL",
          require: "sql",
          owner: "Golmote"
        },
        powerquery: {
          title: "PowerQuery",
          alias: ["pq", "mscript"],
          owner: "peterbud"
        },
        powershell: {
          title: "PowerShell",
          owner: "nauzilus"
        },
        processing: {
          title: "Processing",
          require: "clike",
          owner: "Golmote"
        },
        prolog: {
          title: "Prolog",
          owner: "Golmote"
        },
        promql: {
          title: "PromQL",
          owner: "arendjr"
        },
        properties: {
          title: ".properties",
          owner: "Golmote"
        },
        protobuf: {
          title: "Protocol Buffers",
          require: "clike",
          owner: "just-boris"
        },
        pug: {
          title: "Pug",
          require: ["markup", "javascript"],
          optional: [
            "coffeescript",
            "ejs",
            "handlebars",
            "less",
            "livescript",
            "markdown",
            "scss",
            "stylus",
            "twig"
          ],
          owner: "Golmote"
        },
        puppet: {
          title: "Puppet",
          owner: "Golmote"
        },
        pure: {
          title: "Pure",
          optional: [
            "c",
            "cpp",
            "fortran"
          ],
          owner: "Golmote"
        },
        purebasic: {
          title: "PureBasic",
          require: "clike",
          alias: "pbfasm",
          owner: "HeX0R101"
        },
        purescript: {
          title: "PureScript",
          require: "haskell",
          alias: "purs",
          owner: "sriharshachilakapati"
        },
        python: {
          title: "Python",
          alias: "py",
          owner: "multipetros"
        },
        qsharp: {
          title: "Q#",
          require: "clike",
          alias: "qs",
          owner: "fedonman"
        },
        q: {
          title: "Q (kdb+ database)",
          owner: "Golmote"
        },
        qml: {
          title: "QML",
          require: "javascript",
          owner: "RunDevelopment"
        },
        qore: {
          title: "Qore",
          require: "clike",
          owner: "temnroegg"
        },
        r: {
          title: "R",
          owner: "Golmote"
        },
        racket: {
          title: "Racket",
          require: "scheme",
          alias: "rkt",
          owner: "RunDevelopment"
        },
        jsx: {
          title: "React JSX",
          require: ["markup", "javascript"],
          optional: [
            "jsdoc",
            "js-extras",
            "js-templates"
          ],
          owner: "vkbansal"
        },
        tsx: {
          title: "React TSX",
          require: ["jsx", "typescript"]
        },
        reason: {
          title: "Reason",
          require: "clike",
          owner: "Golmote"
        },
        regex: {
          title: "Regex",
          owner: "RunDevelopment"
        },
        rego: {
          title: "Rego",
          owner: "JordanSh"
        },
        renpy: {
          title: "Ren'py",
          alias: "rpy",
          owner: "HyuchiaDiego"
        },
        rest: {
          title: "reST (reStructuredText)",
          owner: "Golmote"
        },
        rip: {
          title: "Rip",
          owner: "ravinggenius"
        },
        roboconf: {
          title: "Roboconf",
          owner: "Golmote"
        },
        robotframework: {
          title: "Robot Framework",
          alias: "robot",
          owner: "RunDevelopment"
        },
        ruby: {
          title: "Ruby",
          require: "clike",
          alias: "rb",
          owner: "samflores"
        },
        rust: {
          title: "Rust",
          owner: "Golmote"
        },
        sas: {
          title: "SAS",
          optional: ["groovy", "lua", "sql"],
          owner: "Golmote"
        },
        sass: {
          title: "Sass (Sass)",
          require: "css",
          owner: "Golmote"
        },
        scss: {
          title: "Sass (Scss)",
          require: "css",
          optional: "css-extras",
          owner: "MoOx"
        },
        scala: {
          title: "Scala",
          require: "java",
          owner: "jozic"
        },
        scheme: {
          title: "Scheme",
          owner: "bacchus123"
        },
        "shell-session": {
          title: "Shell session",
          require: "bash",
          alias: ["sh-session", "shellsession"],
          owner: "RunDevelopment"
        },
        smali: {
          title: "Smali",
          owner: "RunDevelopment"
        },
        smalltalk: {
          title: "Smalltalk",
          owner: "Golmote"
        },
        smarty: {
          title: "Smarty",
          require: "markup-templating",
          owner: "Golmote"
        },
        sml: {
          title: "SML",
          alias: "smlnj",
          aliasTitles: {
            smlnj: "SML/NJ"
          },
          owner: "RunDevelopment"
        },
        solidity: {
          title: "Solidity (Ethereum)",
          alias: "sol",
          require: "clike",
          owner: "glachaud"
        },
        "solution-file": {
          title: "Solution file",
          alias: "sln",
          owner: "RunDevelopment"
        },
        soy: {
          title: "Soy (Closure Template)",
          require: "markup-templating",
          owner: "Golmote"
        },
        sparql: {
          title: "SPARQL",
          require: "turtle",
          owner: "Triply-Dev",
          alias: "rq"
        },
        "splunk-spl": {
          title: "Splunk SPL",
          owner: "RunDevelopment"
        },
        sqf: {
          title: "SQF: Status Quo Function (Arma 3)",
          require: "clike",
          owner: "RunDevelopment"
        },
        sql: {
          title: "SQL",
          owner: "multipetros"
        },
        squirrel: {
          title: "Squirrel",
          require: "clike",
          owner: "RunDevelopment"
        },
        stan: {
          title: "Stan",
          owner: "RunDevelopment"
        },
        iecst: {
          title: "Structured Text (IEC 61131-3)",
          owner: "serhioromano"
        },
        stylus: {
          title: "Stylus",
          owner: "vkbansal"
        },
        swift: {
          title: "Swift",
          require: "clike",
          owner: "chrischares"
        },
        "t4-templating": {
          title: "T4 templating",
          owner: "RunDevelopment"
        },
        "t4-cs": {
          title: "T4 Text Templates (C#)",
          require: ["t4-templating", "csharp"],
          alias: "t4",
          owner: "RunDevelopment"
        },
        "t4-vb": {
          title: "T4 Text Templates (VB)",
          require: ["t4-templating", "vbnet"],
          owner: "RunDevelopment"
        },
        tap: {
          title: "TAP",
          owner: "isaacs",
          require: "yaml"
        },
        tcl: {
          title: "Tcl",
          owner: "PeterChaplin"
        },
        tt2: {
          title: "Template Toolkit 2",
          require: ["clike", "markup-templating"],
          owner: "gflohr"
        },
        textile: {
          title: "Textile",
          require: "markup",
          optional: "css",
          owner: "Golmote"
        },
        toml: {
          title: "TOML",
          owner: "RunDevelopment"
        },
        turtle: {
          title: "Turtle",
          alias: "trig",
          aliasTitles: {
            trig: "TriG"
          },
          owner: "jakubklimek"
        },
        twig: {
          title: "Twig",
          require: "markup",
          owner: "brandonkelly"
        },
        typescript: {
          title: "TypeScript",
          require: "javascript",
          optional: "js-templates",
          alias: "ts",
          owner: "vkbansal"
        },
        typoscript: {
          title: "TypoScript",
          alias: "tsconfig",
          aliasTitles: {
            tsconfig: "TSConfig"
          },
          owner: "dkern"
        },
        unrealscript: {
          title: "UnrealScript",
          alias: ["uscript", "uc"],
          owner: "RunDevelopment"
        },
        uri: {
          title: "URI",
          alias: "url",
          aliasTitles: {
            url: "URL"
          },
          owner: "RunDevelopment"
        },
        v: {
          title: "V",
          require: "clike",
          owner: "taggon"
        },
        vala: {
          title: "Vala",
          require: "clike",
          optional: "regex",
          owner: "TemplarVolk"
        },
        vbnet: {
          title: "VB.Net",
          require: "basic",
          owner: "Bigsby"
        },
        velocity: {
          title: "Velocity",
          require: "markup",
          owner: "Golmote"
        },
        verilog: {
          title: "Verilog",
          owner: "a-rey"
        },
        vhdl: {
          title: "VHDL",
          owner: "a-rey"
        },
        vim: {
          title: "vim",
          owner: "westonganger"
        },
        "visual-basic": {
          title: "Visual Basic",
          alias: ["vb", "vba"],
          aliasTitles: {
            vba: "VBA"
          },
          owner: "Golmote"
        },
        warpscript: {
          title: "WarpScript",
          owner: "RunDevelopment"
        },
        wasm: {
          title: "WebAssembly",
          owner: "Golmote"
        },
        wiki: {
          title: "Wiki markup",
          require: "markup",
          owner: "Golmote"
        },
        wolfram: {
          title: "Wolfram language",
          alias: ["mathematica", "nb", "wl"],
          aliasTitles: {
            mathematica: "Mathematica",
            nb: "Mathematica Notebook"
          },
          owner: "msollami"
        },
        xeora: {
          title: "Xeora",
          require: "markup",
          alias: "xeoracube",
          aliasTitles: {
            xeoracube: "XeoraCube"
          },
          owner: "freakmaxi"
        },
        "xml-doc": {
          title: "XML doc (.net)",
          require: "markup",
          modify: ["csharp", "fsharp", "vbnet"],
          owner: "RunDevelopment"
        },
        xojo: {
          title: "Xojo (REALbasic)",
          owner: "Golmote"
        },
        xquery: {
          title: "XQuery",
          require: "markup",
          owner: "Golmote"
        },
        yaml: {
          title: "YAML",
          alias: "yml",
          owner: "hason"
        },
        yang: {
          title: "YANG",
          owner: "RunDevelopment"
        },
        zig: {
          title: "Zig",
          owner: "RunDevelopment"
        }
      },
      plugins: {
        meta: {
          path: "plugins/{id}/prism-{id}",
          link: "plugins/{id}/"
        },
        "line-highlight": {
          title: "Line Highlight",
          description: "Highlights specific lines and/or line ranges."
        },
        "line-numbers": {
          title: "Line Numbers",
          description: "Line number at the beginning of code lines.",
          owner: "kuba-kubula"
        },
        "show-invisibles": {
          title: "Show Invisibles",
          description: "Show hidden characters such as tabs and line breaks.",
          optional: [
            "autolinker",
            "data-uri-highlight"
          ]
        },
        autolinker: {
          title: "Autolinker",
          description: "Converts URLs and emails in code to clickable links. Parses Markdown links in comments."
        },
        wpd: {
          title: "WebPlatform Docs",
          description: 'Makes tokens link to <a href="https://webplatform.github.io/docs/">WebPlatform.org documentation</a>. The links open in a new tab.'
        },
        "custom-class": {
          title: "Custom Class",
          description: "This plugin allows you to prefix Prism's default classes (<code>.comment</code> can become <code>.namespace--comment</code>) or replace them with your defined ones (like <code>.editor__comment</code>). You can even add new classes.",
          owner: "dvkndn",
          noCSS: true
        },
        "file-highlight": {
          title: "File Highlight",
          description: "Fetch external files and highlight them with Prism. Used on the Prism website itself.",
          noCSS: true
        },
        "show-language": {
          title: "Show Language",
          description: "Display the highlighted language in code blocks (inline code does not show the label).",
          owner: "nauzilus",
          noCSS: true,
          require: "toolbar"
        },
        "jsonp-highlight": {
          title: "JSONP Highlight",
          description: "Fetch content with JSONP and highlight some interesting content (e.g. GitHub/Gists or Bitbucket API).",
          noCSS: true,
          owner: "nauzilus"
        },
        "highlight-keywords": {
          title: "Highlight Keywords",
          description: "Adds special CSS classes for each keyword matched in the code. For example, the keyword <code>if</code> will have the class <code>keyword-if</code> as well. You can have fine grained control over the appearance of each keyword by providing your own CSS rules.",
          owner: "vkbansal",
          noCSS: true
        },
        "remove-initial-line-feed": {
          title: "Remove initial line feed",
          description: "Removes the initial line feed in code blocks.",
          owner: "Golmote",
          noCSS: true
        },
        "inline-color": {
          title: "Inline color",
          description: "Adds a small inline preview for colors in style sheets.",
          require: "css-extras",
          owner: "RunDevelopment"
        },
        previewers: {
          title: "Previewers",
          description: "Previewers for angles, colors, gradients, easing and time.",
          require: "css-extras",
          owner: "Golmote"
        },
        autoloader: {
          title: "Autoloader",
          description: "Automatically loads the needed languages to highlight the code blocks.",
          owner: "Golmote",
          noCSS: true
        },
        "keep-markup": {
          title: "Keep Markup",
          description: "Prevents custom markup from being dropped out during highlighting.",
          owner: "Golmote",
          optional: "normalize-whitespace",
          noCSS: true
        },
        "command-line": {
          title: "Command Line",
          description: "Display a command line with a prompt and, optionally, the output/response from the commands.",
          owner: "chriswells0"
        },
        "unescaped-markup": {
          title: "Unescaped Markup",
          description: "Write markup without having to escape anything."
        },
        "normalize-whitespace": {
          title: "Normalize Whitespace",
          description: "Supports multiple operations to normalize whitespace in code blocks.",
          owner: "zeitgeist87",
          optional: "unescaped-markup",
          noCSS: true
        },
        "data-uri-highlight": {
          title: "Data-URI Highlight",
          description: "Highlights data-URI contents.",
          owner: "Golmote",
          noCSS: true
        },
        toolbar: {
          title: "Toolbar",
          description: "Attach a toolbar for plugins to easily register buttons on the top of a code block.",
          owner: "mAAdhaTTah"
        },
        "copy-to-clipboard": {
          title: "Copy to Clipboard Button",
          description: "Add a button that copies the code block to the clipboard when clicked.",
          owner: "mAAdhaTTah",
          require: "toolbar",
          noCSS: true
        },
        "download-button": {
          title: "Download Button",
          description: "A button in the toolbar of a code block adding a convenient way to download a code file.",
          owner: "Golmote",
          require: "toolbar",
          noCSS: true
        },
        "match-braces": {
          title: "Match braces",
          description: "Highlights matching braces.",
          owner: "RunDevelopment"
        },
        "diff-highlight": {
          title: "Diff Highlight",
          description: "Highlights the code inside diff blocks.",
          owner: "RunDevelopment",
          require: "diff"
        },
        "filter-highlight-all": {
          title: "Filter highlightAll",
          description: "Filters the elements the <code>highlightAll</code> and <code>highlightAllUnder</code> methods actually highlight.",
          owner: "RunDevelopment",
          noCSS: true
        },
        treeview: {
          title: "Treeview",
          description: "A language with special styles to highlight file system tree structures.",
          owner: "Golmote"
        }
      }
    };
  }
});

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports2, module2) {
    init_shims();
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism = function(_self2) {
      var lang = /\blang(?:uage)?-([\w-]+)\b/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        manual: _self2.Prism && _self2.Prism.manual,
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone2;
            var id;
            switch (_.util.type(o)) {
              case "Object":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone2 = {};
                visited[id] = clone2;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone2[key] = deepClone(o[key], visited);
                  }
                }
                return clone2;
              case "Array":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone2 = [];
                visited[id] = clone2;
                o.forEach(function(v, i) {
                  clone2[i] = deepClone(v, visited);
                });
                return clone2;
              default:
                return o;
            }
          },
          getLanguage: function(element) {
            while (element && !lang.test(element.className)) {
              element = element.parentElement;
            }
            if (element) {
              return (element.className.match(lang) || [, "none"])[1].toLowerCase();
            }
            return "none";
          },
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return document.currentScript;
            }
            try {
              throw new Error();
            } catch (err) {
              var src2 = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(err.stack) || [])[1];
              if (src2) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src2) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        languages: {
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          extend: function(id, redef) {
            var lang2 = _.util.clone(_.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          insertBefore: function(inside, before, insert, root) {
            root = root || _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        },
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _.highlightElement(element, async === true, env.callback);
          }
        },
        highlightElement: function(element, async, callback) {
          var language = _.util.getLanguage(element);
          var grammar = _.languages[language];
          element.className = element.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language;
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            parent.className = parent.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language;
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _.hooks.run("after-highlight", env);
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
          }
        },
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        hooks: {
          all: {},
          add: function(name, callback) {
            var hooks = _.hooks.all;
            hooks[name] = hooks[name] || [];
            hooks[name].push(callback);
          },
          run: function(name, env) {
            var callbacks = _.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s2 = "";
          o.forEach(function(e) {
            s2 += stringify(e, language);
          });
          return s2;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str2 = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str2 instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p += k.value.length;
                }
                removeCount--;
                str2 = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str2, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str2.slice(0, from);
              var after = str2.slice(from + matchStr.length);
              var reach = pos + str2.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _;
        }
        if (!_.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _;
      }
      var script = _.util.currentScript();
      if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_.manual) {
          _.highlightAll();
        }
      }
      if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _;
    }(_self);
    if (typeof module2 !== "undefined" && module2.exports) {
      module2.exports = Prism;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism;
    }
    Prism.languages.markup = {
      "comment": /<!--[\s\S]*?-->/,
      "prolog": /<\?[\s\S]+?\?>/,
      "doctype": {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": /<!\[CDATA\[[\s\S]*?\]\]>/i,
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
    Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
    Prism.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
      value: function(attrName, lang) {
        Prism.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism.languages.html = Prism.languages.markup;
    Prism.languages.mathml = Prism.languages.markup;
    Prism.languages.svg = Prism.languages.markup;
    Prism.languages.xml = Prism.languages.extend("markup", {});
    Prism.languages.ssml = Prism.languages.xml;
    Prism.languages.atom = Prism.languages.xml;
    Prism.languages.rss = Prism.languages.xml;
    (function(Prism2) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism2.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
          }
        },
        "url": {
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
      var markup = Prism2.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism);
    Prism.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
      "boolean": /\b(?:true|false)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism.languages.javascript = Prism.languages.extend("clike", {
      "class-name": [
        Prism.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    Prism.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      }
    });
    if (Prism.languages.markup) {
      Prism.languages.markup.tag.addInlined("script", "javascript");
      Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
    }
    Prism.languages.js = Prism.languages.javascript;
    (function() {
      if (typeof Prism === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading\u2026";
      var FAILURE_MESSAGE = function(status, message) {
        return "\u2716 Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      var lang = /\blang(?:uage)?-([\w-]+)\b/i;
      function setLanguageClass(element, language) {
        var className = element.className;
        className = className.replace(lang, " ") + " language-" + language;
        element.className = className.replace(/\s+/g, " ").trim();
      }
      Prism.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism.hooks.add("before-sanity-check", function(env) {
        var pre = env.element;
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src2 = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src2) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          setLanguageClass(code, language);
          setLanguageClass(pre, language);
          var autoloader = Prism.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          var xhr = new XMLHttpRequest();
          xhr.open("GET", src2, true);
          xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
              if (xhr.status < 400 && xhr.responseText) {
                pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
                code.textContent = xhr.responseText;
                Prism.highlightElement(code);
              } else {
                pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
                if (xhr.status >= 400) {
                  code.textContent = FAILURE_MESSAGE(xhr.status, xhr.statusText);
                } else {
                  code.textContent = FAILURE_EMPTY_MESSAGE;
                }
              }
            }
          };
          xhr.send(null);
        }
      });
      Prism.plugins.fileHighlight = {
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/mdsvex/dist/main.cjs.js
var require_main_cjs = __commonJS({
  "node_modules/mdsvex/dist/main.cjs.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path2 = require("path");
    var fs2 = require("fs");
    var compiler$1 = require_compiler();
    var util = require("util");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d2 = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d2.get ? d2 : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var path__default = /* @__PURE__ */ _interopDefaultLegacy(path2);
    var path__namespace = /* @__PURE__ */ _interopNamespace(path2);
    var fs__default = /* @__PURE__ */ _interopDefaultLegacy(fs2);
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
    var bail_1 = bail;
    function bail(err) {
      if (err) {
        throw err;
      }
    }
    var isBuffer = function isBuffer2(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target2, options4) {
      if (defineProperty && options4.name === "__proto__") {
        defineProperty(target2, options4.name, {
          enumerable: true,
          configurable: true,
          value: options4.newValue,
          writable: true
        });
      } else {
        target2[options4.name] = options4.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name2) {
      if (name2 === "__proto__") {
        if (!hasOwn.call(obj, name2)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name2).value;
        }
      }
      return obj[name2];
    };
    var extend$2 = function extend2() {
      var options4, name2, src2, copy2, copyIsArray, clone2;
      var target2 = arguments[0];
      var i2 = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target2 === "boolean") {
        deep = target2;
        target2 = arguments[1] || {};
        i2 = 2;
      }
      if (target2 == null || typeof target2 !== "object" && typeof target2 !== "function") {
        target2 = {};
      }
      for (; i2 < length; ++i2) {
        options4 = arguments[i2];
        if (options4 != null) {
          for (name2 in options4) {
            src2 = getProperty(target2, name2);
            copy2 = getProperty(options4, name2);
            if (target2 !== copy2) {
              if (deep && copy2 && (isPlainObject(copy2) || (copyIsArray = isArray(copy2)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src2 && isArray(src2) ? src2 : [];
                } else {
                  clone2 = src2 && isPlainObject(src2) ? src2 : {};
                }
                setProperty(target2, { name: name2, newValue: extend2(deep, clone2, copy2) });
              } else if (typeof copy2 !== "undefined") {
                setProperty(target2, { name: name2, newValue: copy2 });
              }
            }
          }
        }
      }
      return target2;
    };
    var isPlainObj = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
    var slice$3 = [].slice;
    var wrap_1$1 = wrap$2;
    function wrap$2(fn, callback) {
      var invoked;
      return wrapped;
      function wrapped() {
        var params = slice$3.call(arguments, 0);
        var callback2 = fn.length > params.length;
        var result;
        if (callback2) {
          params.push(done);
        }
        try {
          result = fn.apply(null, params);
        } catch (error3) {
          if (callback2 && invoked) {
            throw error3;
          }
          return done(error3);
        }
        if (!callback2) {
          if (result && typeof result.then === "function") {
            result.then(then, done);
          } else if (result instanceof Error) {
            done(result);
          } else {
            then(result);
          }
        }
      }
      function done() {
        if (!invoked) {
          invoked = true;
          callback.apply(null, arguments);
        }
      }
      function then(value) {
        done(null, value);
      }
    }
    var trough_1 = trough;
    trough.wrap = wrap_1$1;
    var slice$2 = [].slice;
    function trough() {
      var fns = [];
      var middleware = {};
      middleware.run = run3;
      middleware.use = use;
      return middleware;
      function run3() {
        var index3 = -1;
        var input = slice$2.call(arguments, 0, -1);
        var done = arguments[arguments.length - 1];
        if (typeof done !== "function") {
          throw new Error("Expected function as last argument, not " + done);
        }
        next.apply(null, [null].concat(input));
        function next(err) {
          var fn = fns[++index3];
          var params = slice$2.call(arguments, 0);
          var values2 = params.slice(1);
          var length = input.length;
          var pos = -1;
          if (err) {
            done(err);
            return;
          }
          while (++pos < length) {
            if (values2[pos] === null || values2[pos] === void 0) {
              values2[pos] = input[pos];
            }
          }
          input = values2;
          if (fn) {
            wrap_1$1(fn, next).apply(null, input);
          } else {
            done.apply(null, [null].concat(input));
          }
        }
      }
      function use(fn) {
        if (typeof fn !== "function") {
          throw new Error("Expected `fn` to be a function, not " + fn);
        }
        fns.push(fn);
        return middleware;
      }
    }
    var own$f = {}.hasOwnProperty;
    var unistUtilStringifyPosition = stringify$4;
    function stringify$4(value) {
      if (!value || typeof value !== "object") {
        return "";
      }
      if (own$f.call(value, "position") || own$f.call(value, "type")) {
        return position$1(value.position);
      }
      if (own$f.call(value, "start") || own$f.call(value, "end")) {
        return position$1(value);
      }
      if (own$f.call(value, "line") || own$f.call(value, "column")) {
        return point(value);
      }
      return "";
    }
    function point(point2) {
      if (!point2 || typeof point2 !== "object") {
        point2 = {};
      }
      return index$6(point2.line) + ":" + index$6(point2.column);
    }
    function position$1(pos) {
      if (!pos || typeof pos !== "object") {
        pos = {};
      }
      return point(pos.start) + "-" + point(pos.end);
    }
    function index$6(value) {
      return value && typeof value === "number" ? value : 1;
    }
    var vfileMessage = VMessage;
    function VMessagePrototype() {
    }
    VMessagePrototype.prototype = Error.prototype;
    VMessage.prototype = new VMessagePrototype();
    var proto$6 = VMessage.prototype;
    proto$6.file = "";
    proto$6.name = "";
    proto$6.reason = "";
    proto$6.message = "";
    proto$6.stack = "";
    proto$6.fatal = null;
    proto$6.column = null;
    proto$6.line = null;
    function VMessage(reason, position2, origin) {
      var parts;
      var range2;
      var location;
      if (typeof position2 === "string") {
        origin = position2;
        position2 = null;
      }
      parts = parseOrigin(origin);
      range2 = unistUtilStringifyPosition(position2) || "1:1";
      location = {
        start: { line: null, column: null },
        end: { line: null, column: null }
      };
      if (position2 && position2.position) {
        position2 = position2.position;
      }
      if (position2) {
        if (position2.start) {
          location = position2;
          position2 = position2.start;
        } else {
          location.start = position2;
        }
      }
      if (reason.stack) {
        this.stack = reason.stack;
        reason = reason.message;
      }
      this.message = reason;
      this.name = range2;
      this.reason = reason;
      this.line = position2 ? position2.line : null;
      this.column = position2 ? position2.column : null;
      this.location = location;
      this.source = parts[0];
      this.ruleId = parts[1];
    }
    function parseOrigin(origin) {
      var result = [null, null];
      var index3;
      if (typeof origin === "string") {
        index3 = origin.indexOf(":");
        if (index3 === -1) {
          result[1] = origin;
        } else {
          result[0] = origin.slice(0, index3);
          result[1] = origin.slice(index3 + 1);
        }
      }
      return result;
    }
    function replaceExt(npath, ext) {
      if (typeof npath !== "string") {
        return npath;
      }
      if (npath.length === 0) {
        return npath;
      }
      var nFileName = path__default["default"].basename(npath, path__default["default"].extname(npath)) + ext;
      return path__default["default"].join(path__default["default"].dirname(npath), nFileName);
    }
    var replaceExt_1 = replaceExt;
    var core$1 = VFile;
    var own$e = {}.hasOwnProperty;
    var proto$5 = VFile.prototype;
    var order$1 = ["history", "path", "basename", "stem", "extname", "dirname"];
    proto$5.toString = toString;
    Object.defineProperty(proto$5, "path", { get: getPath, set: setPath });
    Object.defineProperty(proto$5, "dirname", { get: getDirname, set: setDirname });
    Object.defineProperty(proto$5, "basename", { get: getBasename, set: setBasename });
    Object.defineProperty(proto$5, "extname", { get: getExtname, set: setExtname });
    Object.defineProperty(proto$5, "stem", { get: getStem, set: setStem });
    function VFile(options4) {
      var prop2;
      var index3;
      var length;
      if (!options4) {
        options4 = {};
      } else if (typeof options4 === "string" || isBuffer(options4)) {
        options4 = { contents: options4 };
      } else if ("message" in options4 && "messages" in options4) {
        return options4;
      }
      if (!(this instanceof VFile)) {
        return new VFile(options4);
      }
      this.data = {};
      this.messages = [];
      this.history = [];
      this.cwd = process.cwd();
      index3 = -1;
      length = order$1.length;
      while (++index3 < length) {
        prop2 = order$1[index3];
        if (own$e.call(options4, prop2)) {
          this[prop2] = options4[prop2];
        }
      }
      for (prop2 in options4) {
        if (order$1.indexOf(prop2) === -1) {
          this[prop2] = options4[prop2];
        }
      }
    }
    function getPath() {
      return this.history[this.history.length - 1];
    }
    function setPath(path3) {
      assertNonEmpty(path3, "path");
      if (path3 !== this.path) {
        this.history.push(path3);
      }
    }
    function getDirname() {
      return typeof this.path === "string" ? path__default["default"].dirname(this.path) : void 0;
    }
    function setDirname(dirname) {
      assertPath(this.path, "dirname");
      this.path = path__default["default"].join(dirname || "", this.basename);
    }
    function getBasename() {
      return typeof this.path === "string" ? path__default["default"].basename(this.path) : void 0;
    }
    function setBasename(basename) {
      assertNonEmpty(basename, "basename");
      assertPart(basename, "basename");
      this.path = path__default["default"].join(this.dirname || "", basename);
    }
    function getExtname() {
      return typeof this.path === "string" ? path__default["default"].extname(this.path) : void 0;
    }
    function setExtname(extname) {
      var ext = extname || "";
      assertPart(ext, "extname");
      assertPath(this.path, "extname");
      if (ext) {
        if (ext.charAt(0) !== ".") {
          throw new Error("`extname` must start with `.`");
        }
        if (ext.indexOf(".", 1) !== -1) {
          throw new Error("`extname` cannot contain multiple dots");
        }
      }
      this.path = replaceExt_1(this.path, ext);
    }
    function getStem() {
      return typeof this.path === "string" ? path__default["default"].basename(this.path, this.extname) : void 0;
    }
    function setStem(stem) {
      assertNonEmpty(stem, "stem");
      assertPart(stem, "stem");
      this.path = path__default["default"].join(this.dirname || "", stem + (this.extname || ""));
    }
    function toString(encoding) {
      var value = this.contents || "";
      return isBuffer(value) ? value.toString(encoding) : String(value);
    }
    function assertPart(part2, name2) {
      if (part2.indexOf(path__default["default"].sep) !== -1) {
        throw new Error("`" + name2 + "` cannot be a path: did not expect `" + path__default["default"].sep + "`");
      }
    }
    function assertNonEmpty(part2, name2) {
      if (!part2) {
        throw new Error("`" + name2 + "` cannot be empty");
      }
    }
    function assertPath(path3, name2) {
      if (!path3) {
        throw new Error("Setting `" + name2 + "` requires `path` to be set too");
      }
    }
    var vfile = core$1;
    var proto$4 = core$1.prototype;
    proto$4.message = message;
    proto$4.info = info$1;
    proto$4.fail = fail;
    function message(reason, position2, origin) {
      var filePath = this.path;
      var message2 = new vfileMessage(reason, position2, origin);
      if (filePath) {
        message2.name = filePath + ":" + message2.name;
        message2.file = filePath;
      }
      message2.fatal = false;
      this.messages.push(message2);
      return message2;
    }
    function fail() {
      var message2 = this.message.apply(this, arguments);
      message2.fatal = true;
      throw message2;
    }
    function info$1() {
      var message2 = this.message.apply(this, arguments);
      message2.fatal = null;
      return message2;
    }
    var unified_1$1 = unified$1().freeze();
    var slice$1 = [].slice;
    var own$d = {}.hasOwnProperty;
    var pipeline$1 = trough_1().use(pipelineParse$1).use(pipelineRun$1).use(pipelineStringify$1);
    function pipelineParse$1(p2, ctx) {
      ctx.tree = p2.parse(ctx.file);
    }
    function pipelineRun$1(p2, ctx, next) {
      p2.run(ctx.tree, ctx.file, done);
      function done(err, tree, file) {
        if (err) {
          next(err);
        } else {
          ctx.tree = tree;
          ctx.file = file;
          next();
        }
      }
    }
    function pipelineStringify$1(p2, ctx) {
      var result = p2.stringify(ctx.tree, ctx.file);
      var file = ctx.file;
      if (result === void 0 || result === null)
        ;
      else if (typeof result === "string" || isBuffer(result)) {
        file.contents = result;
      } else {
        file.result = result;
      }
    }
    function unified$1() {
      var attachers = [];
      var transformers = trough_1();
      var namespace = {};
      var frozen = false;
      var freezeIndex = -1;
      processor.data = data2;
      processor.freeze = freeze;
      processor.attachers = attachers;
      processor.use = use;
      processor.parse = parse3;
      processor.stringify = stringify2;
      processor.run = run3;
      processor.runSync = runSync;
      processor.process = process2;
      processor.processSync = processSync;
      return processor;
      function processor() {
        var destination = unified$1();
        var length = attachers.length;
        var index3 = -1;
        while (++index3 < length) {
          destination.use.apply(null, attachers[index3]);
        }
        destination.data(extend$2(true, {}, namespace));
        return destination;
      }
      function freeze() {
        var values2;
        var plugin;
        var options4;
        var transformer;
        if (frozen) {
          return processor;
        }
        while (++freezeIndex < attachers.length) {
          values2 = attachers[freezeIndex];
          plugin = values2[0];
          options4 = values2[1];
          transformer = null;
          if (options4 === false) {
            continue;
          }
          if (options4 === true) {
            values2[1] = void 0;
          }
          transformer = plugin.apply(processor, values2.slice(1));
          if (typeof transformer === "function") {
            transformers.use(transformer);
          }
        }
        frozen = true;
        freezeIndex = Infinity;
        return processor;
      }
      function data2(key, value) {
        if (typeof key === "string") {
          if (arguments.length === 2) {
            assertUnfrozen$1("data", frozen);
            namespace[key] = value;
            return processor;
          }
          return own$d.call(namespace, key) && namespace[key] || null;
        }
        if (key) {
          assertUnfrozen$1("data", frozen);
          namespace = key;
          return processor;
        }
        return namespace;
      }
      function use(value) {
        var settings;
        assertUnfrozen$1("use", frozen);
        if (value === null || value === void 0)
          ;
        else if (typeof value === "function") {
          addPlugin.apply(null, arguments);
        } else if (typeof value === "object") {
          if ("length" in value) {
            addList(value);
          } else {
            addPreset(value);
          }
        } else {
          throw new Error("Expected usable value, not `" + value + "`");
        }
        if (settings) {
          namespace.settings = extend$2(namespace.settings || {}, settings);
        }
        return processor;
        function addPreset(result) {
          addList(result.plugins);
          if (result.settings) {
            settings = extend$2(settings || {}, result.settings);
          }
        }
        function add(value2) {
          if (typeof value2 === "function") {
            addPlugin(value2);
          } else if (typeof value2 === "object") {
            if ("length" in value2) {
              addPlugin.apply(null, value2);
            } else {
              addPreset(value2);
            }
          } else {
            throw new Error("Expected usable value, not `" + value2 + "`");
          }
        }
        function addList(plugins) {
          var length;
          var index3;
          if (plugins === null || plugins === void 0)
            ;
          else if (typeof plugins === "object" && "length" in plugins) {
            length = plugins.length;
            index3 = -1;
            while (++index3 < length) {
              add(plugins[index3]);
            }
          } else {
            throw new Error("Expected a list of plugins, not `" + plugins + "`");
          }
        }
        function addPlugin(plugin, value2) {
          var entry = find2(plugin);
          if (entry) {
            if (isPlainObj(entry[1]) && isPlainObj(value2)) {
              value2 = extend$2(entry[1], value2);
            }
            entry[1] = value2;
          } else {
            attachers.push(slice$1.call(arguments));
          }
        }
      }
      function find2(plugin) {
        var length = attachers.length;
        var index3 = -1;
        var entry;
        while (++index3 < length) {
          entry = attachers[index3];
          if (entry[0] === plugin) {
            return entry;
          }
        }
      }
      function parse3(doc) {
        var file = vfile(doc);
        var Parser2;
        freeze();
        Parser2 = processor.Parser;
        assertParser$1("parse", Parser2);
        if (newable$1(Parser2, "parse")) {
          return new Parser2(String(file), file).parse();
        }
        return Parser2(String(file), file);
      }
      function run3(node, file, cb) {
        assertNode$1(node);
        freeze();
        if (!cb && typeof file === "function") {
          cb = file;
          file = null;
        }
        if (!cb) {
          return new Promise(executor);
        }
        executor(null, cb);
        function executor(resolve2, reject) {
          transformers.run(node, vfile(file), done);
          function done(err, tree, file2) {
            tree = tree || node;
            if (err) {
              reject(err);
            } else if (resolve2) {
              resolve2(tree);
            } else {
              cb(null, tree, file2);
            }
          }
        }
      }
      function runSync(node, file) {
        var complete = false;
        var result;
        run3(node, file, done);
        assertDone$1("runSync", "run", complete);
        return result;
        function done(err, tree) {
          complete = true;
          bail_1(err);
          result = tree;
        }
      }
      function stringify2(node, doc) {
        var file = vfile(doc);
        var Compiler;
        freeze();
        Compiler = processor.Compiler;
        assertCompiler$1("stringify", Compiler);
        assertNode$1(node);
        if (newable$1(Compiler, "compile")) {
          return new Compiler(node, file).compile();
        }
        return Compiler(node, file);
      }
      function process2(doc, cb) {
        freeze();
        assertParser$1("process", processor.Parser);
        assertCompiler$1("process", processor.Compiler);
        if (!cb) {
          return new Promise(executor);
        }
        executor(null, cb);
        function executor(resolve2, reject) {
          var file = vfile(doc);
          pipeline$1.run(processor, { file }, done);
          function done(err) {
            if (err) {
              reject(err);
            } else if (resolve2) {
              resolve2(file);
            } else {
              cb(null, file);
            }
          }
        }
      }
      function processSync(doc) {
        var complete = false;
        var file;
        freeze();
        assertParser$1("processSync", processor.Parser);
        assertCompiler$1("processSync", processor.Compiler);
        file = vfile(doc);
        process2(file, done);
        assertDone$1("processSync", "process", complete);
        return file;
        function done(err) {
          complete = true;
          bail_1(err);
        }
      }
    }
    function newable$1(value, name2) {
      return typeof value === "function" && value.prototype && (keys$2(value.prototype) || name2 in value.prototype);
    }
    function keys$2(value) {
      var key;
      for (key in value) {
        return true;
      }
      return false;
    }
    function assertParser$1(name2, Parser2) {
      if (typeof Parser2 !== "function") {
        throw new Error("Cannot `" + name2 + "` without `Parser`");
      }
    }
    function assertCompiler$1(name2, Compiler) {
      if (typeof Compiler !== "function") {
        throw new Error("Cannot `" + name2 + "` without `Compiler`");
      }
    }
    function assertUnfrozen$1(name2, frozen) {
      if (frozen) {
        throw new Error("Cannot invoke `" + name2 + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
      }
    }
    function assertNode$1(node) {
      if (!node || typeof node.type !== "string") {
        throw new Error("Expected node, got `" + node + "`");
      }
    }
    function assertDone$1(name2, asyncName, complete) {
      if (!complete) {
        throw new Error("`" + name2 + "` finished async. Use `" + asyncName + "` instead");
      }
    }
    var immutable = extend$1;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend$1() {
      var target2 = {};
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target2[key] = source[key];
          }
        }
      }
      return target2;
    }
    function commonjsRequire() {
      throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
    }
    function createCommonjsModule(fn, module3) {
      return module3 = { exports: {} }, fn(module3, module3.exports), module3.exports;
    }
    function getCjsExportFromNamespace(n) {
      return n && n["default"] || n;
    }
    var inherits_browser = createCommonjsModule(function(module3) {
      if (typeof Object.create === "function") {
        module3.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module3.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    });
    var inherits = createCommonjsModule(function(module3) {
      try {
        var util2 = util__default["default"];
        if (typeof util2.inherits !== "function")
          throw "";
        module3.exports = util2.inherits;
      } catch (e) {
        module3.exports = inherits_browser;
      }
    });
    var unherit_1 = unherit;
    function unherit(Super) {
      var result;
      var key;
      var value;
      inherits(Of, Super);
      inherits(From, Of);
      result = Of.prototype;
      for (key in result) {
        value = result[key];
        if (value && typeof value === "object") {
          result[key] = "concat" in value ? value.concat() : immutable(value);
        }
      }
      return Of;
      function From(parameters) {
        return Super.apply(this, parameters);
      }
      function Of() {
        if (!(this instanceof Of)) {
          return new From(arguments);
        }
        return Super.apply(this, arguments);
      }
    }
    var stateToggle = factory$6;
    function factory$6(key, state, ctx) {
      return enter;
      function enter() {
        var context2 = ctx || this;
        var current = context2[key];
        context2[key] = !state;
        return exit;
        function exit() {
          context2[key] = current;
        }
      }
    }
    var vfileLocation = factory$5;
    function factory$5(file) {
      var contents = indices(String(file));
      return {
        toPosition: offsetToPositionFactory(contents),
        toOffset: positionToOffsetFactory(contents)
      };
    }
    function offsetToPositionFactory(indices2) {
      return offsetToPosition;
      function offsetToPosition(offset) {
        var index3 = -1;
        var length = indices2.length;
        if (offset < 0) {
          return {};
        }
        while (++index3 < length) {
          if (indices2[index3] > offset) {
            return {
              line: index3 + 1,
              column: offset - (indices2[index3 - 1] || 0) + 1,
              offset
            };
          }
        }
        return {};
      }
    }
    function positionToOffsetFactory(indices2) {
      return positionToOffset;
      function positionToOffset(position2) {
        var line2 = position2 && position2.line;
        var column = position2 && position2.column;
        if (!isNaN(line2) && !isNaN(column) && line2 - 1 in indices2) {
          return (indices2[line2 - 2] || 0) + column - 1 || 0;
        }
        return -1;
      }
    }
    function indices(value) {
      var result = [];
      var index3 = value.indexOf("\n");
      while (index3 !== -1) {
        result.push(index3 + 1);
        index3 = value.indexOf("\n", index3 + 1);
      }
      result.push(value.length + 1);
      return result;
    }
    var _unescape = factory$4;
    var backslash$7 = "\\";
    function factory$4(ctx, key) {
      return unescape2;
      function unescape2(value) {
        var previous = 0;
        var index3 = value.indexOf(backslash$7);
        var escape4 = ctx[key];
        var queue = [];
        var character;
        while (index3 !== -1) {
          queue.push(value.slice(previous, index3));
          previous = index3 + 1;
          character = value.charAt(previous);
          if (!character || escape4.indexOf(character) === -1) {
            queue.push(backslash$7);
          }
          index3 = value.indexOf(backslash$7, previous + 1);
        }
        queue.push(value.slice(previous));
        return queue.join("");
      }
    }
    var AElig$2 = "\xC6";
    var AMP$2 = "&";
    var Aacute$2 = "\xC1";
    var Acirc$2 = "\xC2";
    var Agrave$2 = "\xC0";
    var Aring$2 = "\xC5";
    var Atilde$2 = "\xC3";
    var Auml$2 = "\xC4";
    var COPY$1 = "\xA9";
    var Ccedil$2 = "\xC7";
    var ETH$2 = "\xD0";
    var Eacute$2 = "\xC9";
    var Ecirc$2 = "\xCA";
    var Egrave$2 = "\xC8";
    var Euml$2 = "\xCB";
    var GT$2 = ">";
    var Iacute$2 = "\xCD";
    var Icirc$2 = "\xCE";
    var Igrave$2 = "\xCC";
    var Iuml$2 = "\xCF";
    var LT$2 = "<";
    var Ntilde$2 = "\xD1";
    var Oacute$2 = "\xD3";
    var Ocirc$2 = "\xD4";
    var Ograve$2 = "\xD2";
    var Oslash$2 = "\xD8";
    var Otilde$2 = "\xD5";
    var Ouml$2 = "\xD6";
    var QUOT$1 = '"';
    var REG$1 = "\xAE";
    var THORN$2 = "\xDE";
    var Uacute$2 = "\xDA";
    var Ucirc$2 = "\xDB";
    var Ugrave$2 = "\xD9";
    var Uuml$2 = "\xDC";
    var Yacute$2 = "\xDD";
    var aacute$2 = "\xE1";
    var acirc$2 = "\xE2";
    var acute$2 = "\xB4";
    var aelig$2 = "\xE6";
    var agrave$2 = "\xE0";
    var amp$2 = "&";
    var aring$2 = "\xE5";
    var atilde$2 = "\xE3";
    var auml$2 = "\xE4";
    var brvbar$2 = "\xA6";
    var ccedil$2 = "\xE7";
    var cedil$2 = "\xB8";
    var cent$2 = "\xA2";
    var copy$2 = "\xA9";
    var curren$2 = "\xA4";
    var deg$2 = "\xB0";
    var divide$2 = "\xF7";
    var eacute$2 = "\xE9";
    var ecirc$2 = "\xEA";
    var egrave$2 = "\xE8";
    var eth$2 = "\xF0";
    var euml$2 = "\xEB";
    var frac12$2 = "\xBD";
    var frac14$2 = "\xBC";
    var frac34$2 = "\xBE";
    var gt$2 = ">";
    var iacute$2 = "\xED";
    var icirc$2 = "\xEE";
    var iexcl$2 = "\xA1";
    var igrave$2 = "\xEC";
    var iquest$2 = "\xBF";
    var iuml$2 = "\xEF";
    var laquo$2 = "\xAB";
    var lt$2 = "<";
    var macr$2 = "\xAF";
    var micro$2 = "\xB5";
    var middot$2 = "\xB7";
    var nbsp$2 = "\xA0";
    var not$2 = "\xAC";
    var ntilde$2 = "\xF1";
    var oacute$2 = "\xF3";
    var ocirc$2 = "\xF4";
    var ograve$2 = "\xF2";
    var ordf$2 = "\xAA";
    var ordm$2 = "\xBA";
    var oslash$2 = "\xF8";
    var otilde$2 = "\xF5";
    var ouml$2 = "\xF6";
    var para$2 = "\xB6";
    var plusmn$2 = "\xB1";
    var pound$2 = "\xA3";
    var quot$2 = '"';
    var raquo$2 = "\xBB";
    var reg$2 = "\xAE";
    var sect$2 = "\xA7";
    var shy$2 = "\xAD";
    var sup1$2 = "\xB9";
    var sup2$2 = "\xB2";
    var sup3$2 = "\xB3";
    var szlig$2 = "\xDF";
    var thorn$2 = "\xFE";
    var times$2 = "\xD7";
    var uacute$2 = "\xFA";
    var ucirc$2 = "\xFB";
    var ugrave$2 = "\xF9";
    var uml$2 = "\xA8";
    var uuml$2 = "\xFC";
    var yacute$2 = "\xFD";
    var yen$2 = "\xA5";
    var yuml$2 = "\xFF";
    var index$5 = {
      AElig: AElig$2,
      AMP: AMP$2,
      Aacute: Aacute$2,
      Acirc: Acirc$2,
      Agrave: Agrave$2,
      Aring: Aring$2,
      Atilde: Atilde$2,
      Auml: Auml$2,
      COPY: COPY$1,
      Ccedil: Ccedil$2,
      ETH: ETH$2,
      Eacute: Eacute$2,
      Ecirc: Ecirc$2,
      Egrave: Egrave$2,
      Euml: Euml$2,
      GT: GT$2,
      Iacute: Iacute$2,
      Icirc: Icirc$2,
      Igrave: Igrave$2,
      Iuml: Iuml$2,
      LT: LT$2,
      Ntilde: Ntilde$2,
      Oacute: Oacute$2,
      Ocirc: Ocirc$2,
      Ograve: Ograve$2,
      Oslash: Oslash$2,
      Otilde: Otilde$2,
      Ouml: Ouml$2,
      QUOT: QUOT$1,
      REG: REG$1,
      THORN: THORN$2,
      Uacute: Uacute$2,
      Ucirc: Ucirc$2,
      Ugrave: Ugrave$2,
      Uuml: Uuml$2,
      Yacute: Yacute$2,
      aacute: aacute$2,
      acirc: acirc$2,
      acute: acute$2,
      aelig: aelig$2,
      agrave: agrave$2,
      amp: amp$2,
      aring: aring$2,
      atilde: atilde$2,
      auml: auml$2,
      brvbar: brvbar$2,
      ccedil: ccedil$2,
      cedil: cedil$2,
      cent: cent$2,
      copy: copy$2,
      curren: curren$2,
      deg: deg$2,
      divide: divide$2,
      eacute: eacute$2,
      ecirc: ecirc$2,
      egrave: egrave$2,
      eth: eth$2,
      euml: euml$2,
      frac12: frac12$2,
      frac14: frac14$2,
      frac34: frac34$2,
      gt: gt$2,
      iacute: iacute$2,
      icirc: icirc$2,
      iexcl: iexcl$2,
      igrave: igrave$2,
      iquest: iquest$2,
      iuml: iuml$2,
      laquo: laquo$2,
      lt: lt$2,
      macr: macr$2,
      micro: micro$2,
      middot: middot$2,
      nbsp: nbsp$2,
      not: not$2,
      ntilde: ntilde$2,
      oacute: oacute$2,
      ocirc: ocirc$2,
      ograve: ograve$2,
      ordf: ordf$2,
      ordm: ordm$2,
      oslash: oslash$2,
      otilde: otilde$2,
      ouml: ouml$2,
      para: para$2,
      plusmn: plusmn$2,
      pound: pound$2,
      quot: quot$2,
      raquo: raquo$2,
      reg: reg$2,
      sect: sect$2,
      shy: shy$2,
      sup1: sup1$2,
      sup2: sup2$2,
      sup3: sup3$2,
      szlig: szlig$2,
      thorn: thorn$2,
      times: times$2,
      uacute: uacute$2,
      ucirc: ucirc$2,
      ugrave: ugrave$2,
      uml: uml$2,
      uuml: uuml$2,
      yacute: yacute$2,
      yen: yen$2,
      yuml: yuml$2
    };
    var characterEntitiesLegacy = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      AElig: AElig$2,
      AMP: AMP$2,
      Aacute: Aacute$2,
      Acirc: Acirc$2,
      Agrave: Agrave$2,
      Aring: Aring$2,
      Atilde: Atilde$2,
      Auml: Auml$2,
      COPY: COPY$1,
      Ccedil: Ccedil$2,
      ETH: ETH$2,
      Eacute: Eacute$2,
      Ecirc: Ecirc$2,
      Egrave: Egrave$2,
      Euml: Euml$2,
      GT: GT$2,
      Iacute: Iacute$2,
      Icirc: Icirc$2,
      Igrave: Igrave$2,
      Iuml: Iuml$2,
      LT: LT$2,
      Ntilde: Ntilde$2,
      Oacute: Oacute$2,
      Ocirc: Ocirc$2,
      Ograve: Ograve$2,
      Oslash: Oslash$2,
      Otilde: Otilde$2,
      Ouml: Ouml$2,
      QUOT: QUOT$1,
      REG: REG$1,
      THORN: THORN$2,
      Uacute: Uacute$2,
      Ucirc: Ucirc$2,
      Ugrave: Ugrave$2,
      Uuml: Uuml$2,
      Yacute: Yacute$2,
      aacute: aacute$2,
      acirc: acirc$2,
      acute: acute$2,
      aelig: aelig$2,
      agrave: agrave$2,
      amp: amp$2,
      aring: aring$2,
      atilde: atilde$2,
      auml: auml$2,
      brvbar: brvbar$2,
      ccedil: ccedil$2,
      cedil: cedil$2,
      cent: cent$2,
      copy: copy$2,
      curren: curren$2,
      deg: deg$2,
      divide: divide$2,
      eacute: eacute$2,
      ecirc: ecirc$2,
      egrave: egrave$2,
      eth: eth$2,
      euml: euml$2,
      frac12: frac12$2,
      frac14: frac14$2,
      frac34: frac34$2,
      gt: gt$2,
      iacute: iacute$2,
      icirc: icirc$2,
      iexcl: iexcl$2,
      igrave: igrave$2,
      iquest: iquest$2,
      iuml: iuml$2,
      laquo: laquo$2,
      lt: lt$2,
      macr: macr$2,
      micro: micro$2,
      middot: middot$2,
      nbsp: nbsp$2,
      not: not$2,
      ntilde: ntilde$2,
      oacute: oacute$2,
      ocirc: ocirc$2,
      ograve: ograve$2,
      ordf: ordf$2,
      ordm: ordm$2,
      oslash: oslash$2,
      otilde: otilde$2,
      ouml: ouml$2,
      para: para$2,
      plusmn: plusmn$2,
      pound: pound$2,
      quot: quot$2,
      raquo: raquo$2,
      reg: reg$2,
      sect: sect$2,
      shy: shy$2,
      sup1: sup1$2,
      sup2: sup2$2,
      sup3: sup3$2,
      szlig: szlig$2,
      thorn: thorn$2,
      times: times$2,
      uacute: uacute$2,
      ucirc: ucirc$2,
      ugrave: ugrave$2,
      uml: uml$2,
      uuml: uuml$2,
      yacute: yacute$2,
      yen: yen$2,
      yuml: yuml$2,
      "default": index$5
    });
    var index$4 = {
      "0": "\uFFFD",
      "128": "\u20AC",
      "130": "\u201A",
      "131": "\u0192",
      "132": "\u201E",
      "133": "\u2026",
      "134": "\u2020",
      "135": "\u2021",
      "136": "\u02C6",
      "137": "\u2030",
      "138": "\u0160",
      "139": "\u2039",
      "140": "\u0152",
      "142": "\u017D",
      "145": "\u2018",
      "146": "\u2019",
      "147": "\u201C",
      "148": "\u201D",
      "149": "\u2022",
      "150": "\u2013",
      "151": "\u2014",
      "152": "\u02DC",
      "153": "\u2122",
      "154": "\u0161",
      "155": "\u203A",
      "156": "\u0153",
      "158": "\u017E",
      "159": "\u0178"
    };
    var characterReferenceInvalid = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      "default": index$4
    });
    var isDecimal = decimal$1;
    function decimal$1(character) {
      var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
      return code2 >= 48 && code2 <= 57;
    }
    var isHexadecimal = hexadecimal;
    function hexadecimal(character) {
      var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
      return code2 >= 97 && code2 <= 102 || code2 >= 65 && code2 <= 70 || code2 >= 48 && code2 <= 57;
    }
    var isAlphabetical = alphabetical;
    function alphabetical(character) {
      var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
      return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
    }
    var isAlphanumerical = alphanumerical;
    function alphanumerical(character) {
      return isAlphabetical(character) || isDecimal(character);
    }
    var AEli = "\xC6";
    var AElig$1 = "\xC6";
    var AM = "&";
    var AMP$1 = "&";
    var Aacut = "\xC1";
    var Aacute$1 = "\xC1";
    var Abreve = "\u0102";
    var Acir = "\xC2";
    var Acirc$1 = "\xC2";
    var Acy = "\u0410";
    var Afr = "\u{1D504}";
    var Agrav = "\xC0";
    var Agrave$1 = "\xC0";
    var Alpha$1 = "\u0391";
    var Amacr = "\u0100";
    var And = "\u2A53";
    var Aogon = "\u0104";
    var Aopf = "\u{1D538}";
    var ApplyFunction = "\u2061";
    var Arin = "\xC5";
    var Aring$1 = "\xC5";
    var Ascr = "\u{1D49C}";
    var Assign = "\u2254";
    var Atild = "\xC3";
    var Atilde$1 = "\xC3";
    var Aum = "\xC4";
    var Auml$1 = "\xC4";
    var Backslash = "\u2216";
    var Barv = "\u2AE7";
    var Barwed = "\u2306";
    var Bcy = "\u0411";
    var Because = "\u2235";
    var Bernoullis = "\u212C";
    var Beta$1 = "\u0392";
    var Bfr = "\u{1D505}";
    var Bopf = "\u{1D539}";
    var Breve = "\u02D8";
    var Bscr = "\u212C";
    var Bumpeq = "\u224E";
    var CHcy = "\u0427";
    var COP = "\xA9";
    var COPY = "\xA9";
    var Cacute = "\u0106";
    var Cap = "\u22D2";
    var CapitalDifferentialD = "\u2145";
    var Cayleys = "\u212D";
    var Ccaron = "\u010C";
    var Ccedi = "\xC7";
    var Ccedil$1 = "\xC7";
    var Ccirc = "\u0108";
    var Cconint = "\u2230";
    var Cdot = "\u010A";
    var Cedilla = "\xB8";
    var CenterDot = "\xB7";
    var Cfr = "\u212D";
    var Chi$1 = "\u03A7";
    var CircleDot = "\u2299";
    var CircleMinus = "\u2296";
    var CirclePlus = "\u2295";
    var CircleTimes = "\u2297";
    var ClockwiseContourIntegral = "\u2232";
    var CloseCurlyDoubleQuote = "\u201D";
    var CloseCurlyQuote = "\u2019";
    var Colon = "\u2237";
    var Colone = "\u2A74";
    var Congruent = "\u2261";
    var Conint = "\u222F";
    var ContourIntegral = "\u222E";
    var Copf = "\u2102";
    var Coproduct = "\u2210";
    var CounterClockwiseContourIntegral = "\u2233";
    var Cross = "\u2A2F";
    var Cscr = "\u{1D49E}";
    var Cup = "\u22D3";
    var CupCap = "\u224D";
    var DD = "\u2145";
    var DDotrahd = "\u2911";
    var DJcy = "\u0402";
    var DScy = "\u0405";
    var DZcy = "\u040F";
    var Dagger$1 = "\u2021";
    var Darr = "\u21A1";
    var Dashv = "\u2AE4";
    var Dcaron = "\u010E";
    var Dcy = "\u0414";
    var Del = "\u2207";
    var Delta$1 = "\u0394";
    var Dfr = "\u{1D507}";
    var DiacriticalAcute = "\xB4";
    var DiacriticalDot = "\u02D9";
    var DiacriticalDoubleAcute = "\u02DD";
    var DiacriticalGrave = "`";
    var DiacriticalTilde = "\u02DC";
    var Diamond = "\u22C4";
    var DifferentialD = "\u2146";
    var Dopf = "\u{1D53B}";
    var Dot = "\xA8";
    var DotDot = "\u20DC";
    var DotEqual = "\u2250";
    var DoubleContourIntegral = "\u222F";
    var DoubleDot = "\xA8";
    var DoubleDownArrow = "\u21D3";
    var DoubleLeftArrow = "\u21D0";
    var DoubleLeftRightArrow = "\u21D4";
    var DoubleLeftTee = "\u2AE4";
    var DoubleLongLeftArrow = "\u27F8";
    var DoubleLongLeftRightArrow = "\u27FA";
    var DoubleLongRightArrow = "\u27F9";
    var DoubleRightArrow = "\u21D2";
    var DoubleRightTee = "\u22A8";
    var DoubleUpArrow = "\u21D1";
    var DoubleUpDownArrow = "\u21D5";
    var DoubleVerticalBar = "\u2225";
    var DownArrow = "\u2193";
    var DownArrowBar = "\u2913";
    var DownArrowUpArrow = "\u21F5";
    var DownBreve = "\u0311";
    var DownLeftRightVector = "\u2950";
    var DownLeftTeeVector = "\u295E";
    var DownLeftVector = "\u21BD";
    var DownLeftVectorBar = "\u2956";
    var DownRightTeeVector = "\u295F";
    var DownRightVector = "\u21C1";
    var DownRightVectorBar = "\u2957";
    var DownTee = "\u22A4";
    var DownTeeArrow = "\u21A7";
    var Downarrow = "\u21D3";
    var Dscr = "\u{1D49F}";
    var Dstrok = "\u0110";
    var ENG = "\u014A";
    var ET = "\xD0";
    var ETH$1 = "\xD0";
    var Eacut = "\xC9";
    var Eacute$1 = "\xC9";
    var Ecaron = "\u011A";
    var Ecir = "\xCA";
    var Ecirc$1 = "\xCA";
    var Ecy = "\u042D";
    var Edot = "\u0116";
    var Efr = "\u{1D508}";
    var Egrav = "\xC8";
    var Egrave$1 = "\xC8";
    var Element2 = "\u2208";
    var Emacr = "\u0112";
    var EmptySmallSquare = "\u25FB";
    var EmptyVerySmallSquare = "\u25AB";
    var Eogon = "\u0118";
    var Eopf = "\u{1D53C}";
    var Epsilon$1 = "\u0395";
    var Equal = "\u2A75";
    var EqualTilde = "\u2242";
    var Equilibrium = "\u21CC";
    var Escr = "\u2130";
    var Esim = "\u2A73";
    var Eta$1 = "\u0397";
    var Eum = "\xCB";
    var Euml$1 = "\xCB";
    var Exists = "\u2203";
    var ExponentialE = "\u2147";
    var Fcy = "\u0424";
    var Ffr = "\u{1D509}";
    var FilledSmallSquare = "\u25FC";
    var FilledVerySmallSquare = "\u25AA";
    var Fopf = "\u{1D53D}";
    var ForAll = "\u2200";
    var Fouriertrf = "\u2131";
    var Fscr = "\u2131";
    var GJcy = "\u0403";
    var G = ">";
    var GT$1 = ">";
    var Gamma$1 = "\u0393";
    var Gammad = "\u03DC";
    var Gbreve = "\u011E";
    var Gcedil = "\u0122";
    var Gcirc = "\u011C";
    var Gcy = "\u0413";
    var Gdot = "\u0120";
    var Gfr = "\u{1D50A}";
    var Gg = "\u22D9";
    var Gopf = "\u{1D53E}";
    var GreaterEqual = "\u2265";
    var GreaterEqualLess = "\u22DB";
    var GreaterFullEqual = "\u2267";
    var GreaterGreater = "\u2AA2";
    var GreaterLess = "\u2277";
    var GreaterSlantEqual = "\u2A7E";
    var GreaterTilde = "\u2273";
    var Gscr = "\u{1D4A2}";
    var Gt = "\u226B";
    var HARDcy = "\u042A";
    var Hacek = "\u02C7";
    var Hat = "^";
    var Hcirc = "\u0124";
    var Hfr = "\u210C";
    var HilbertSpace = "\u210B";
    var Hopf = "\u210D";
    var HorizontalLine = "\u2500";
    var Hscr = "\u210B";
    var Hstrok = "\u0126";
    var HumpDownHump = "\u224E";
    var HumpEqual = "\u224F";
    var IEcy = "\u0415";
    var IJlig = "\u0132";
    var IOcy = "\u0401";
    var Iacut = "\xCD";
    var Iacute$1 = "\xCD";
    var Icir = "\xCE";
    var Icirc$1 = "\xCE";
    var Icy = "\u0418";
    var Idot = "\u0130";
    var Ifr = "\u2111";
    var Igrav = "\xCC";
    var Igrave$1 = "\xCC";
    var Im = "\u2111";
    var Imacr = "\u012A";
    var ImaginaryI = "\u2148";
    var Implies = "\u21D2";
    var Int = "\u222C";
    var Integral = "\u222B";
    var Intersection = "\u22C2";
    var InvisibleComma = "\u2063";
    var InvisibleTimes = "\u2062";
    var Iogon = "\u012E";
    var Iopf = "\u{1D540}";
    var Iota$1 = "\u0399";
    var Iscr = "\u2110";
    var Itilde = "\u0128";
    var Iukcy = "\u0406";
    var Ium = "\xCF";
    var Iuml$1 = "\xCF";
    var Jcirc = "\u0134";
    var Jcy = "\u0419";
    var Jfr = "\u{1D50D}";
    var Jopf = "\u{1D541}";
    var Jscr = "\u{1D4A5}";
    var Jsercy = "\u0408";
    var Jukcy = "\u0404";
    var KHcy = "\u0425";
    var KJcy = "\u040C";
    var Kappa$1 = "\u039A";
    var Kcedil = "\u0136";
    var Kcy = "\u041A";
    var Kfr = "\u{1D50E}";
    var Kopf = "\u{1D542}";
    var Kscr = "\u{1D4A6}";
    var LJcy = "\u0409";
    var L = "<";
    var LT$1 = "<";
    var Lacute = "\u0139";
    var Lambda$1 = "\u039B";
    var Lang = "\u27EA";
    var Laplacetrf = "\u2112";
    var Larr = "\u219E";
    var Lcaron = "\u013D";
    var Lcedil = "\u013B";
    var Lcy = "\u041B";
    var LeftAngleBracket = "\u27E8";
    var LeftArrow = "\u2190";
    var LeftArrowBar = "\u21E4";
    var LeftArrowRightArrow = "\u21C6";
    var LeftCeiling = "\u2308";
    var LeftDoubleBracket = "\u27E6";
    var LeftDownTeeVector = "\u2961";
    var LeftDownVector = "\u21C3";
    var LeftDownVectorBar = "\u2959";
    var LeftFloor = "\u230A";
    var LeftRightArrow = "\u2194";
    var LeftRightVector = "\u294E";
    var LeftTee = "\u22A3";
    var LeftTeeArrow = "\u21A4";
    var LeftTeeVector = "\u295A";
    var LeftTriangle = "\u22B2";
    var LeftTriangleBar = "\u29CF";
    var LeftTriangleEqual = "\u22B4";
    var LeftUpDownVector = "\u2951";
    var LeftUpTeeVector = "\u2960";
    var LeftUpVector = "\u21BF";
    var LeftUpVectorBar = "\u2958";
    var LeftVector = "\u21BC";
    var LeftVectorBar = "\u2952";
    var Leftarrow = "\u21D0";
    var Leftrightarrow = "\u21D4";
    var LessEqualGreater = "\u22DA";
    var LessFullEqual = "\u2266";
    var LessGreater = "\u2276";
    var LessLess = "\u2AA1";
    var LessSlantEqual = "\u2A7D";
    var LessTilde = "\u2272";
    var Lfr = "\u{1D50F}";
    var Ll = "\u22D8";
    var Lleftarrow = "\u21DA";
    var Lmidot = "\u013F";
    var LongLeftArrow = "\u27F5";
    var LongLeftRightArrow = "\u27F7";
    var LongRightArrow = "\u27F6";
    var Longleftarrow = "\u27F8";
    var Longleftrightarrow = "\u27FA";
    var Longrightarrow = "\u27F9";
    var Lopf = "\u{1D543}";
    var LowerLeftArrow = "\u2199";
    var LowerRightArrow = "\u2198";
    var Lscr = "\u2112";
    var Lsh = "\u21B0";
    var Lstrok = "\u0141";
    var Lt = "\u226A";
    var Mcy = "\u041C";
    var MediumSpace = "\u205F";
    var Mellintrf = "\u2133";
    var Mfr = "\u{1D510}";
    var MinusPlus = "\u2213";
    var Mopf = "\u{1D544}";
    var Mscr = "\u2133";
    var Mu$1 = "\u039C";
    var NJcy = "\u040A";
    var Nacute = "\u0143";
    var Ncaron = "\u0147";
    var Ncedil = "\u0145";
    var Ncy = "\u041D";
    var NegativeMediumSpace = "\u200B";
    var NegativeThickSpace = "\u200B";
    var NegativeThinSpace = "\u200B";
    var NegativeVeryThinSpace = "\u200B";
    var NestedGreaterGreater = "\u226B";
    var NestedLessLess = "\u226A";
    var NewLine = "\n";
    var Nfr = "\u{1D511}";
    var NoBreak = "\u2060";
    var NonBreakingSpace = "\xA0";
    var Nopf = "\u2115";
    var Not = "\u2AEC";
    var NotCongruent = "\u2262";
    var NotCupCap = "\u226D";
    var NotDoubleVerticalBar = "\u2226";
    var NotElement = "\u2209";
    var NotEqual = "\u2260";
    var NotEqualTilde = "\u2242\u0338";
    var NotExists = "\u2204";
    var NotGreater = "\u226F";
    var NotGreaterEqual = "\u2271";
    var NotGreaterFullEqual = "\u2267\u0338";
    var NotGreaterGreater = "\u226B\u0338";
    var NotGreaterLess = "\u2279";
    var NotGreaterSlantEqual = "\u2A7E\u0338";
    var NotGreaterTilde = "\u2275";
    var NotHumpDownHump = "\u224E\u0338";
    var NotHumpEqual = "\u224F\u0338";
    var NotLeftTriangle = "\u22EA";
    var NotLeftTriangleBar = "\u29CF\u0338";
    var NotLeftTriangleEqual = "\u22EC";
    var NotLess = "\u226E";
    var NotLessEqual = "\u2270";
    var NotLessGreater = "\u2278";
    var NotLessLess = "\u226A\u0338";
    var NotLessSlantEqual = "\u2A7D\u0338";
    var NotLessTilde = "\u2274";
    var NotNestedGreaterGreater = "\u2AA2\u0338";
    var NotNestedLessLess = "\u2AA1\u0338";
    var NotPrecedes = "\u2280";
    var NotPrecedesEqual = "\u2AAF\u0338";
    var NotPrecedesSlantEqual = "\u22E0";
    var NotReverseElement = "\u220C";
    var NotRightTriangle = "\u22EB";
    var NotRightTriangleBar = "\u29D0\u0338";
    var NotRightTriangleEqual = "\u22ED";
    var NotSquareSubset = "\u228F\u0338";
    var NotSquareSubsetEqual = "\u22E2";
    var NotSquareSuperset = "\u2290\u0338";
    var NotSquareSupersetEqual = "\u22E3";
    var NotSubset = "\u2282\u20D2";
    var NotSubsetEqual = "\u2288";
    var NotSucceeds = "\u2281";
    var NotSucceedsEqual = "\u2AB0\u0338";
    var NotSucceedsSlantEqual = "\u22E1";
    var NotSucceedsTilde = "\u227F\u0338";
    var NotSuperset = "\u2283\u20D2";
    var NotSupersetEqual = "\u2289";
    var NotTilde = "\u2241";
    var NotTildeEqual = "\u2244";
    var NotTildeFullEqual = "\u2247";
    var NotTildeTilde = "\u2249";
    var NotVerticalBar = "\u2224";
    var Nscr = "\u{1D4A9}";
    var Ntild = "\xD1";
    var Ntilde$1 = "\xD1";
    var Nu$1 = "\u039D";
    var OElig$1 = "\u0152";
    var Oacut = "\xD3";
    var Oacute$1 = "\xD3";
    var Ocir = "\xD4";
    var Ocirc$1 = "\xD4";
    var Ocy = "\u041E";
    var Odblac = "\u0150";
    var Ofr = "\u{1D512}";
    var Ograv = "\xD2";
    var Ograve$1 = "\xD2";
    var Omacr = "\u014C";
    var Omega$1 = "\u03A9";
    var Omicron$1 = "\u039F";
    var Oopf = "\u{1D546}";
    var OpenCurlyDoubleQuote = "\u201C";
    var OpenCurlyQuote = "\u2018";
    var Or = "\u2A54";
    var Oscr = "\u{1D4AA}";
    var Oslas = "\xD8";
    var Oslash$1 = "\xD8";
    var Otild = "\xD5";
    var Otilde$1 = "\xD5";
    var Otimes = "\u2A37";
    var Oum = "\xD6";
    var Ouml$1 = "\xD6";
    var OverBar = "\u203E";
    var OverBrace = "\u23DE";
    var OverBracket = "\u23B4";
    var OverParenthesis = "\u23DC";
    var PartialD = "\u2202";
    var Pcy = "\u041F";
    var Pfr = "\u{1D513}";
    var Phi$1 = "\u03A6";
    var Pi$1 = "\u03A0";
    var PlusMinus = "\xB1";
    var Poincareplane = "\u210C";
    var Popf = "\u2119";
    var Pr = "\u2ABB";
    var Precedes = "\u227A";
    var PrecedesEqual = "\u2AAF";
    var PrecedesSlantEqual = "\u227C";
    var PrecedesTilde = "\u227E";
    var Prime$1 = "\u2033";
    var Product = "\u220F";
    var Proportion = "\u2237";
    var Proportional = "\u221D";
    var Pscr = "\u{1D4AB}";
    var Psi$1 = "\u03A8";
    var QUO = '"';
    var QUOT = '"';
    var Qfr = "\u{1D514}";
    var Qopf = "\u211A";
    var Qscr = "\u{1D4AC}";
    var RBarr = "\u2910";
    var RE = "\xAE";
    var REG = "\xAE";
    var Racute = "\u0154";
    var Rang = "\u27EB";
    var Rarr = "\u21A0";
    var Rarrtl = "\u2916";
    var Rcaron = "\u0158";
    var Rcedil = "\u0156";
    var Rcy = "\u0420";
    var Re = "\u211C";
    var ReverseElement = "\u220B";
    var ReverseEquilibrium = "\u21CB";
    var ReverseUpEquilibrium = "\u296F";
    var Rfr = "\u211C";
    var Rho$1 = "\u03A1";
    var RightAngleBracket = "\u27E9";
    var RightArrow = "\u2192";
    var RightArrowBar = "\u21E5";
    var RightArrowLeftArrow = "\u21C4";
    var RightCeiling = "\u2309";
    var RightDoubleBracket = "\u27E7";
    var RightDownTeeVector = "\u295D";
    var RightDownVector = "\u21C2";
    var RightDownVectorBar = "\u2955";
    var RightFloor = "\u230B";
    var RightTee = "\u22A2";
    var RightTeeArrow = "\u21A6";
    var RightTeeVector = "\u295B";
    var RightTriangle = "\u22B3";
    var RightTriangleBar = "\u29D0";
    var RightTriangleEqual = "\u22B5";
    var RightUpDownVector = "\u294F";
    var RightUpTeeVector = "\u295C";
    var RightUpVector = "\u21BE";
    var RightUpVectorBar = "\u2954";
    var RightVector = "\u21C0";
    var RightVectorBar = "\u2953";
    var Rightarrow = "\u21D2";
    var Ropf = "\u211D";
    var RoundImplies = "\u2970";
    var Rrightarrow = "\u21DB";
    var Rscr = "\u211B";
    var Rsh = "\u21B1";
    var RuleDelayed = "\u29F4";
    var SHCHcy = "\u0429";
    var SHcy = "\u0428";
    var SOFTcy = "\u042C";
    var Sacute = "\u015A";
    var Sc = "\u2ABC";
    var Scaron$1 = "\u0160";
    var Scedil = "\u015E";
    var Scirc = "\u015C";
    var Scy = "\u0421";
    var Sfr = "\u{1D516}";
    var ShortDownArrow = "\u2193";
    var ShortLeftArrow = "\u2190";
    var ShortRightArrow = "\u2192";
    var ShortUpArrow = "\u2191";
    var Sigma$1 = "\u03A3";
    var SmallCircle = "\u2218";
    var Sopf = "\u{1D54A}";
    var Sqrt = "\u221A";
    var Square = "\u25A1";
    var SquareIntersection = "\u2293";
    var SquareSubset = "\u228F";
    var SquareSubsetEqual = "\u2291";
    var SquareSuperset = "\u2290";
    var SquareSupersetEqual = "\u2292";
    var SquareUnion = "\u2294";
    var Sscr = "\u{1D4AE}";
    var Star = "\u22C6";
    var Sub = "\u22D0";
    var Subset = "\u22D0";
    var SubsetEqual = "\u2286";
    var Succeeds = "\u227B";
    var SucceedsEqual = "\u2AB0";
    var SucceedsSlantEqual = "\u227D";
    var SucceedsTilde = "\u227F";
    var SuchThat = "\u220B";
    var Sum = "\u2211";
    var Sup = "\u22D1";
    var Superset = "\u2283";
    var SupersetEqual = "\u2287";
    var Supset = "\u22D1";
    var THOR = "\xDE";
    var THORN$1 = "\xDE";
    var TRADE = "\u2122";
    var TSHcy = "\u040B";
    var TScy = "\u0426";
    var Tab = "	";
    var Tau$1 = "\u03A4";
    var Tcaron = "\u0164";
    var Tcedil = "\u0162";
    var Tcy = "\u0422";
    var Tfr = "\u{1D517}";
    var Therefore = "\u2234";
    var Theta$1 = "\u0398";
    var ThickSpace = "\u205F\u200A";
    var ThinSpace = "\u2009";
    var Tilde = "\u223C";
    var TildeEqual = "\u2243";
    var TildeFullEqual = "\u2245";
    var TildeTilde = "\u2248";
    var Topf = "\u{1D54B}";
    var TripleDot = "\u20DB";
    var Tscr = "\u{1D4AF}";
    var Tstrok = "\u0166";
    var Uacut = "\xDA";
    var Uacute$1 = "\xDA";
    var Uarr = "\u219F";
    var Uarrocir = "\u2949";
    var Ubrcy = "\u040E";
    var Ubreve = "\u016C";
    var Ucir = "\xDB";
    var Ucirc$1 = "\xDB";
    var Ucy = "\u0423";
    var Udblac = "\u0170";
    var Ufr = "\u{1D518}";
    var Ugrav = "\xD9";
    var Ugrave$1 = "\xD9";
    var Umacr = "\u016A";
    var UnderBar = "_";
    var UnderBrace = "\u23DF";
    var UnderBracket = "\u23B5";
    var UnderParenthesis = "\u23DD";
    var Union = "\u22C3";
    var UnionPlus = "\u228E";
    var Uogon = "\u0172";
    var Uopf = "\u{1D54C}";
    var UpArrow = "\u2191";
    var UpArrowBar = "\u2912";
    var UpArrowDownArrow = "\u21C5";
    var UpDownArrow = "\u2195";
    var UpEquilibrium = "\u296E";
    var UpTee = "\u22A5";
    var UpTeeArrow = "\u21A5";
    var Uparrow = "\u21D1";
    var Updownarrow = "\u21D5";
    var UpperLeftArrow = "\u2196";
    var UpperRightArrow = "\u2197";
    var Upsi = "\u03D2";
    var Upsilon$1 = "\u03A5";
    var Uring = "\u016E";
    var Uscr = "\u{1D4B0}";
    var Utilde = "\u0168";
    var Uum = "\xDC";
    var Uuml$1 = "\xDC";
    var VDash = "\u22AB";
    var Vbar = "\u2AEB";
    var Vcy = "\u0412";
    var Vdash = "\u22A9";
    var Vdashl = "\u2AE6";
    var Vee = "\u22C1";
    var Verbar = "\u2016";
    var Vert = "\u2016";
    var VerticalBar = "\u2223";
    var VerticalLine = "|";
    var VerticalSeparator = "\u2758";
    var VerticalTilde = "\u2240";
    var VeryThinSpace = "\u200A";
    var Vfr = "\u{1D519}";
    var Vopf = "\u{1D54D}";
    var Vscr = "\u{1D4B1}";
    var Vvdash = "\u22AA";
    var Wcirc = "\u0174";
    var Wedge = "\u22C0";
    var Wfr = "\u{1D51A}";
    var Wopf = "\u{1D54E}";
    var Wscr = "\u{1D4B2}";
    var Xfr = "\u{1D51B}";
    var Xi$1 = "\u039E";
    var Xopf = "\u{1D54F}";
    var Xscr = "\u{1D4B3}";
    var YAcy = "\u042F";
    var YIcy = "\u0407";
    var YUcy = "\u042E";
    var Yacut = "\xDD";
    var Yacute$1 = "\xDD";
    var Ycirc = "\u0176";
    var Ycy = "\u042B";
    var Yfr = "\u{1D51C}";
    var Yopf = "\u{1D550}";
    var Yscr = "\u{1D4B4}";
    var Yuml$1 = "\u0178";
    var ZHcy = "\u0416";
    var Zacute = "\u0179";
    var Zcaron = "\u017D";
    var Zcy = "\u0417";
    var Zdot = "\u017B";
    var ZeroWidthSpace = "\u200B";
    var Zeta$1 = "\u0396";
    var Zfr = "\u2128";
    var Zopf = "\u2124";
    var Zscr = "\u{1D4B5}";
    var aacut = "\xE1";
    var aacute$1 = "\xE1";
    var abreve = "\u0103";
    var ac = "\u223E";
    var acE = "\u223E\u0333";
    var acd = "\u223F";
    var acir = "\xE2";
    var acirc$1 = "\xE2";
    var acut = "\xB4";
    var acute$1 = "\xB4";
    var acy = "\u0430";
    var aeli = "\xE6";
    var aelig$1 = "\xE6";
    var af = "\u2061";
    var afr = "\u{1D51E}";
    var agrav = "\xE0";
    var agrave$1 = "\xE0";
    var alefsym$1 = "\u2135";
    var aleph = "\u2135";
    var alpha$1 = "\u03B1";
    var amacr = "\u0101";
    var amalg = "\u2A3F";
    var am = "&";
    var amp$1 = "&";
    var and$1 = "\u2227";
    var andand = "\u2A55";
    var andd = "\u2A5C";
    var andslope = "\u2A58";
    var andv = "\u2A5A";
    var ang$1 = "\u2220";
    var ange = "\u29A4";
    var angle = "\u2220";
    var angmsd = "\u2221";
    var angmsdaa = "\u29A8";
    var angmsdab = "\u29A9";
    var angmsdac = "\u29AA";
    var angmsdad = "\u29AB";
    var angmsdae = "\u29AC";
    var angmsdaf = "\u29AD";
    var angmsdag = "\u29AE";
    var angmsdah = "\u29AF";
    var angrt = "\u221F";
    var angrtvb = "\u22BE";
    var angrtvbd = "\u299D";
    var angsph = "\u2222";
    var angst = "\xC5";
    var angzarr = "\u237C";
    var aogon = "\u0105";
    var aopf = "\u{1D552}";
    var ap = "\u2248";
    var apE = "\u2A70";
    var apacir = "\u2A6F";
    var ape = "\u224A";
    var apid = "\u224B";
    var apos = "'";
    var approx = "\u2248";
    var approxeq = "\u224A";
    var arin = "\xE5";
    var aring$1 = "\xE5";
    var ascr = "\u{1D4B6}";
    var ast = "*";
    var asymp$1 = "\u2248";
    var asympeq = "\u224D";
    var atild = "\xE3";
    var atilde$1 = "\xE3";
    var aum = "\xE4";
    var auml$1 = "\xE4";
    var awconint = "\u2233";
    var awint = "\u2A11";
    var bNot = "\u2AED";
    var backcong = "\u224C";
    var backepsilon = "\u03F6";
    var backprime = "\u2035";
    var backsim = "\u223D";
    var backsimeq = "\u22CD";
    var barvee = "\u22BD";
    var barwed = "\u2305";
    var barwedge = "\u2305";
    var bbrk = "\u23B5";
    var bbrktbrk = "\u23B6";
    var bcong = "\u224C";
    var bcy = "\u0431";
    var bdquo$1 = "\u201E";
    var becaus = "\u2235";
    var because = "\u2235";
    var bemptyv = "\u29B0";
    var bepsi = "\u03F6";
    var bernou = "\u212C";
    var beta$1 = "\u03B2";
    var beth = "\u2136";
    var between = "\u226C";
    var bfr = "\u{1D51F}";
    var bigcap = "\u22C2";
    var bigcirc = "\u25EF";
    var bigcup = "\u22C3";
    var bigodot = "\u2A00";
    var bigoplus = "\u2A01";
    var bigotimes = "\u2A02";
    var bigsqcup = "\u2A06";
    var bigstar = "\u2605";
    var bigtriangledown = "\u25BD";
    var bigtriangleup = "\u25B3";
    var biguplus = "\u2A04";
    var bigvee = "\u22C1";
    var bigwedge = "\u22C0";
    var bkarow = "\u290D";
    var blacklozenge = "\u29EB";
    var blacksquare = "\u25AA";
    var blacktriangle = "\u25B4";
    var blacktriangledown = "\u25BE";
    var blacktriangleleft = "\u25C2";
    var blacktriangleright = "\u25B8";
    var blank = "\u2423";
    var blk12 = "\u2592";
    var blk14 = "\u2591";
    var blk34 = "\u2593";
    var block = "\u2588";
    var bne = "=\u20E5";
    var bnequiv = "\u2261\u20E5";
    var bnot = "\u2310";
    var bopf = "\u{1D553}";
    var bot = "\u22A5";
    var bottom = "\u22A5";
    var bowtie = "\u22C8";
    var boxDL = "\u2557";
    var boxDR = "\u2554";
    var boxDl = "\u2556";
    var boxDr = "\u2553";
    var boxH = "\u2550";
    var boxHD = "\u2566";
    var boxHU = "\u2569";
    var boxHd = "\u2564";
    var boxHu = "\u2567";
    var boxUL = "\u255D";
    var boxUR = "\u255A";
    var boxUl = "\u255C";
    var boxUr = "\u2559";
    var boxV = "\u2551";
    var boxVH = "\u256C";
    var boxVL = "\u2563";
    var boxVR = "\u2560";
    var boxVh = "\u256B";
    var boxVl = "\u2562";
    var boxVr = "\u255F";
    var boxbox = "\u29C9";
    var boxdL = "\u2555";
    var boxdR = "\u2552";
    var boxdl = "\u2510";
    var boxdr = "\u250C";
    var boxh = "\u2500";
    var boxhD = "\u2565";
    var boxhU = "\u2568";
    var boxhd = "\u252C";
    var boxhu = "\u2534";
    var boxminus = "\u229F";
    var boxplus = "\u229E";
    var boxtimes = "\u22A0";
    var boxuL = "\u255B";
    var boxuR = "\u2558";
    var boxul = "\u2518";
    var boxur = "\u2514";
    var boxv = "\u2502";
    var boxvH = "\u256A";
    var boxvL = "\u2561";
    var boxvR = "\u255E";
    var boxvh = "\u253C";
    var boxvl = "\u2524";
    var boxvr = "\u251C";
    var bprime = "\u2035";
    var breve = "\u02D8";
    var brvba = "\xA6";
    var brvbar$1 = "\xA6";
    var bscr = "\u{1D4B7}";
    var bsemi = "\u204F";
    var bsim = "\u223D";
    var bsime = "\u22CD";
    var bsol = "\\";
    var bsolb = "\u29C5";
    var bsolhsub = "\u27C8";
    var bull$1 = "\u2022";
    var bullet = "\u2022";
    var bump = "\u224E";
    var bumpE = "\u2AAE";
    var bumpe = "\u224F";
    var bumpeq = "\u224F";
    var cacute = "\u0107";
    var cap$2 = "\u2229";
    var capand = "\u2A44";
    var capbrcup = "\u2A49";
    var capcap = "\u2A4B";
    var capcup = "\u2A47";
    var capdot = "\u2A40";
    var caps = "\u2229\uFE00";
    var caret = "\u2041";
    var caron = "\u02C7";
    var ccaps = "\u2A4D";
    var ccaron = "\u010D";
    var ccedi = "\xE7";
    var ccedil$1 = "\xE7";
    var ccirc = "\u0109";
    var ccups = "\u2A4C";
    var ccupssm = "\u2A50";
    var cdot = "\u010B";
    var cedi = "\xB8";
    var cedil$1 = "\xB8";
    var cemptyv = "\u29B2";
    var cen = "\xA2";
    var cent$1 = "\xA2";
    var centerdot = "\xB7";
    var cfr = "\u{1D520}";
    var chcy = "\u0447";
    var check = "\u2713";
    var checkmark = "\u2713";
    var chi$1 = "\u03C7";
    var cir = "\u25CB";
    var cirE = "\u29C3";
    var circ$1 = "\u02C6";
    var circeq = "\u2257";
    var circlearrowleft = "\u21BA";
    var circlearrowright = "\u21BB";
    var circledR = "\xAE";
    var circledS = "\u24C8";
    var circledast = "\u229B";
    var circledcirc = "\u229A";
    var circleddash = "\u229D";
    var cire = "\u2257";
    var cirfnint = "\u2A10";
    var cirmid = "\u2AEF";
    var cirscir = "\u29C2";
    var clubs$1 = "\u2663";
    var clubsuit = "\u2663";
    var colon$3 = ":";
    var colone = "\u2254";
    var coloneq = "\u2254";
    var comma$2 = ",";
    var commat = "@";
    var comp = "\u2201";
    var compfn = "\u2218";
    var complement = "\u2201";
    var complexes = "\u2102";
    var cong$1 = "\u2245";
    var congdot = "\u2A6D";
    var conint = "\u222E";
    var copf = "\u{1D554}";
    var coprod = "\u2210";
    var cop = "\xA9";
    var copy$1 = "\xA9";
    var copysr = "\u2117";
    var crarr$1 = "\u21B5";
    var cross = "\u2717";
    var cscr = "\u{1D4B8}";
    var csub = "\u2ACF";
    var csube = "\u2AD1";
    var csup = "\u2AD0";
    var csupe = "\u2AD2";
    var ctdot = "\u22EF";
    var cudarrl = "\u2938";
    var cudarrr = "\u2935";
    var cuepr = "\u22DE";
    var cuesc = "\u22DF";
    var cularr = "\u21B6";
    var cularrp = "\u293D";
    var cup$1 = "\u222A";
    var cupbrcap = "\u2A48";
    var cupcap = "\u2A46";
    var cupcup = "\u2A4A";
    var cupdot = "\u228D";
    var cupor = "\u2A45";
    var cups = "\u222A\uFE00";
    var curarr = "\u21B7";
    var curarrm = "\u293C";
    var curlyeqprec = "\u22DE";
    var curlyeqsucc = "\u22DF";
    var curlyvee = "\u22CE";
    var curlywedge = "\u22CF";
    var curre = "\xA4";
    var curren$1 = "\xA4";
    var curvearrowleft = "\u21B6";
    var curvearrowright = "\u21B7";
    var cuvee = "\u22CE";
    var cuwed = "\u22CF";
    var cwconint = "\u2232";
    var cwint = "\u2231";
    var cylcty = "\u232D";
    var dArr$1 = "\u21D3";
    var dHar = "\u2965";
    var dagger$1 = "\u2020";
    var daleth = "\u2138";
    var darr$1 = "\u2193";
    var dash$8 = "\u2010";
    var dashv = "\u22A3";
    var dbkarow = "\u290F";
    var dblac = "\u02DD";
    var dcaron = "\u010F";
    var dcy = "\u0434";
    var dd$1 = "\u2146";
    var ddagger = "\u2021";
    var ddarr = "\u21CA";
    var ddotseq = "\u2A77";
    var de = "\xB0";
    var deg$1 = "\xB0";
    var delta$1 = "\u03B4";
    var demptyv = "\u29B1";
    var dfisht = "\u297F";
    var dfr = "\u{1D521}";
    var dharl = "\u21C3";
    var dharr = "\u21C2";
    var diam = "\u22C4";
    var diamond = "\u22C4";
    var diamondsuit = "\u2666";
    var diams$1 = "\u2666";
    var die = "\xA8";
    var digamma = "\u03DD";
    var disin = "\u22F2";
    var div = "\xF7";
    var divid = "\xF7";
    var divide$1 = "\xF7";
    var divideontimes = "\u22C7";
    var divonx = "\u22C7";
    var djcy = "\u0452";
    var dlcorn = "\u231E";
    var dlcrop = "\u230D";
    var dollar = "$";
    var dopf = "\u{1D555}";
    var dot$4 = "\u02D9";
    var doteq = "\u2250";
    var doteqdot = "\u2251";
    var dotminus = "\u2238";
    var dotplus = "\u2214";
    var dotsquare = "\u22A1";
    var doublebarwedge = "\u2306";
    var downarrow = "\u2193";
    var downdownarrows = "\u21CA";
    var downharpoonleft = "\u21C3";
    var downharpoonright = "\u21C2";
    var drbkarow = "\u2910";
    var drcorn = "\u231F";
    var drcrop = "\u230C";
    var dscr = "\u{1D4B9}";
    var dscy = "\u0455";
    var dsol = "\u29F6";
    var dstrok = "\u0111";
    var dtdot = "\u22F1";
    var dtri = "\u25BF";
    var dtrif = "\u25BE";
    var duarr = "\u21F5";
    var duhar = "\u296F";
    var dwangle = "\u29A6";
    var dzcy = "\u045F";
    var dzigrarr = "\u27FF";
    var eDDot = "\u2A77";
    var eDot = "\u2251";
    var eacut = "\xE9";
    var eacute$1 = "\xE9";
    var easter = "\u2A6E";
    var ecaron = "\u011B";
    var ecir = "\xEA";
    var ecirc$1 = "\xEA";
    var ecolon = "\u2255";
    var ecy = "\u044D";
    var edot = "\u0117";
    var ee = "\u2147";
    var efDot = "\u2252";
    var efr = "\u{1D522}";
    var eg = "\u2A9A";
    var egrav = "\xE8";
    var egrave$1 = "\xE8";
    var egs = "\u2A96";
    var egsdot = "\u2A98";
    var el = "\u2A99";
    var elinters = "\u23E7";
    var ell = "\u2113";
    var els = "\u2A95";
    var elsdot = "\u2A97";
    var emacr = "\u0113";
    var empty$3 = "\u2205";
    var emptyset = "\u2205";
    var emptyv = "\u2205";
    var emsp13 = "\u2004";
    var emsp14 = "\u2005";
    var emsp$1 = "\u2003";
    var eng = "\u014B";
    var ensp$1 = "\u2002";
    var eogon = "\u0119";
    var eopf = "\u{1D556}";
    var epar = "\u22D5";
    var eparsl = "\u29E3";
    var eplus = "\u2A71";
    var epsi = "\u03B5";
    var epsilon$1 = "\u03B5";
    var epsiv = "\u03F5";
    var eqcirc = "\u2256";
    var eqcolon = "\u2255";
    var eqsim = "\u2242";
    var eqslantgtr = "\u2A96";
    var eqslantless = "\u2A95";
    var equals = "=";
    var equest = "\u225F";
    var equiv$1 = "\u2261";
    var equivDD = "\u2A78";
    var eqvparsl = "\u29E5";
    var erDot = "\u2253";
    var erarr = "\u2971";
    var escr = "\u212F";
    var esdot = "\u2250";
    var esim = "\u2242";
    var eta$1 = "\u03B7";
    var et = "\xF0";
    var eth$1 = "\xF0";
    var eum = "\xEB";
    var euml$1 = "\xEB";
    var euro$1 = "\u20AC";
    var excl = "!";
    var exist$1 = "\u2203";
    var expectation = "\u2130";
    var exponentiale = "\u2147";
    var fallingdotseq = "\u2252";
    var fcy = "\u0444";
    var female = "\u2640";
    var ffilig = "\uFB03";
    var fflig = "\uFB00";
    var ffllig = "\uFB04";
    var ffr = "\u{1D523}";
    var filig = "\uFB01";
    var fjlig = "fj";
    var flat = "\u266D";
    var fllig = "\uFB02";
    var fltns = "\u25B1";
    var fnof$1 = "\u0192";
    var fopf = "\u{1D557}";
    var forall$1 = "\u2200";
    var fork = "\u22D4";
    var forkv = "\u2AD9";
    var fpartint = "\u2A0D";
    var frac1 = "\xBC";
    var frac12$1 = "\xBD";
    var frac13 = "\u2153";
    var frac14$1 = "\xBC";
    var frac15 = "\u2155";
    var frac16 = "\u2159";
    var frac18 = "\u215B";
    var frac23 = "\u2154";
    var frac25 = "\u2156";
    var frac3 = "\xBE";
    var frac34$1 = "\xBE";
    var frac35 = "\u2157";
    var frac38 = "\u215C";
    var frac45 = "\u2158";
    var frac56 = "\u215A";
    var frac58 = "\u215D";
    var frac78 = "\u215E";
    var frasl$1 = "\u2044";
    var frown = "\u2322";
    var fscr = "\u{1D4BB}";
    var gE = "\u2267";
    var gEl = "\u2A8C";
    var gacute = "\u01F5";
    var gamma$1 = "\u03B3";
    var gammad = "\u03DD";
    var gap = "\u2A86";
    var gbreve = "\u011F";
    var gcirc = "\u011D";
    var gcy = "\u0433";
    var gdot = "\u0121";
    var ge$1 = "\u2265";
    var gel = "\u22DB";
    var geq = "\u2265";
    var geqq = "\u2267";
    var geqslant = "\u2A7E";
    var ges = "\u2A7E";
    var gescc = "\u2AA9";
    var gesdot = "\u2A80";
    var gesdoto = "\u2A82";
    var gesdotol = "\u2A84";
    var gesl = "\u22DB\uFE00";
    var gesles = "\u2A94";
    var gfr = "\u{1D524}";
    var gg = "\u226B";
    var ggg = "\u22D9";
    var gimel = "\u2137";
    var gjcy = "\u0453";
    var gl = "\u2277";
    var glE = "\u2A92";
    var gla = "\u2AA5";
    var glj = "\u2AA4";
    var gnE = "\u2269";
    var gnap = "\u2A8A";
    var gnapprox = "\u2A8A";
    var gne = "\u2A88";
    var gneq = "\u2A88";
    var gneqq = "\u2269";
    var gnsim = "\u22E7";
    var gopf = "\u{1D558}";
    var grave = "`";
    var gscr = "\u210A";
    var gsim = "\u2273";
    var gsime = "\u2A8E";
    var gsiml = "\u2A90";
    var g = ">";
    var gt$1 = ">";
    var gtcc = "\u2AA7";
    var gtcir = "\u2A7A";
    var gtdot = "\u22D7";
    var gtlPar = "\u2995";
    var gtquest = "\u2A7C";
    var gtrapprox = "\u2A86";
    var gtrarr = "\u2978";
    var gtrdot = "\u22D7";
    var gtreqless = "\u22DB";
    var gtreqqless = "\u2A8C";
    var gtrless = "\u2277";
    var gtrsim = "\u2273";
    var gvertneqq = "\u2269\uFE00";
    var gvnE = "\u2269\uFE00";
    var hArr$1 = "\u21D4";
    var hairsp = "\u200A";
    var half = "\xBD";
    var hamilt = "\u210B";
    var hardcy = "\u044A";
    var harr$1 = "\u2194";
    var harrcir = "\u2948";
    var harrw = "\u21AD";
    var hbar = "\u210F";
    var hcirc = "\u0125";
    var hearts$1 = "\u2665";
    var heartsuit = "\u2665";
    var hellip$1 = "\u2026";
    var hercon = "\u22B9";
    var hfr = "\u{1D525}";
    var hksearow = "\u2925";
    var hkswarow = "\u2926";
    var hoarr = "\u21FF";
    var homtht = "\u223B";
    var hookleftarrow = "\u21A9";
    var hookrightarrow = "\u21AA";
    var hopf = "\u{1D559}";
    var horbar = "\u2015";
    var hscr = "\u{1D4BD}";
    var hslash = "\u210F";
    var hstrok = "\u0127";
    var hybull = "\u2043";
    var hyphen = "\u2010";
    var iacut = "\xED";
    var iacute$1 = "\xED";
    var ic = "\u2063";
    var icir = "\xEE";
    var icirc$1 = "\xEE";
    var icy = "\u0438";
    var iecy = "\u0435";
    var iexc = "\xA1";
    var iexcl$1 = "\xA1";
    var iff = "\u21D4";
    var ifr = "\u{1D526}";
    var igrav = "\xEC";
    var igrave$1 = "\xEC";
    var ii = "\u2148";
    var iiiint = "\u2A0C";
    var iiint = "\u222D";
    var iinfin = "\u29DC";
    var iiota = "\u2129";
    var ijlig = "\u0133";
    var imacr = "\u012B";
    var image$3 = "\u2111";
    var imagline = "\u2110";
    var imagpart = "\u2111";
    var imath = "\u0131";
    var imof = "\u22B7";
    var imped = "\u01B5";
    var incare = "\u2105";
    var infin$1 = "\u221E";
    var infintie = "\u29DD";
    var inodot = "\u0131";
    var int$1 = "\u222B";
    var intcal = "\u22BA";
    var integers = "\u2124";
    var intercal = "\u22BA";
    var intlarhk = "\u2A17";
    var intprod = "\u2A3C";
    var iocy = "\u0451";
    var iogon = "\u012F";
    var iopf = "\u{1D55A}";
    var iota$1 = "\u03B9";
    var iprod = "\u2A3C";
    var iques = "\xBF";
    var iquest$1 = "\xBF";
    var iscr = "\u{1D4BE}";
    var isin$1 = "\u2208";
    var isinE = "\u22F9";
    var isindot = "\u22F5";
    var isins = "\u22F4";
    var isinsv = "\u22F3";
    var isinv = "\u2208";
    var it = "\u2062";
    var itilde = "\u0129";
    var iukcy = "\u0456";
    var ium = "\xEF";
    var iuml$1 = "\xEF";
    var jcirc = "\u0135";
    var jcy = "\u0439";
    var jfr = "\u{1D527}";
    var jmath = "\u0237";
    var jopf = "\u{1D55B}";
    var jscr = "\u{1D4BF}";
    var jsercy = "\u0458";
    var jukcy = "\u0454";
    var kappa$1 = "\u03BA";
    var kappav = "\u03F0";
    var kcedil = "\u0137";
    var kcy = "\u043A";
    var kfr = "\u{1D528}";
    var kgreen = "\u0138";
    var khcy = "\u0445";
    var kjcy = "\u045C";
    var kopf = "\u{1D55C}";
    var kscr = "\u{1D4C0}";
    var lAarr = "\u21DA";
    var lArr$1 = "\u21D0";
    var lAtail = "\u291B";
    var lBarr = "\u290E";
    var lE = "\u2266";
    var lEg = "\u2A8B";
    var lHar = "\u2962";
    var lacute = "\u013A";
    var laemptyv = "\u29B4";
    var lagran = "\u2112";
    var lambda$1 = "\u03BB";
    var lang$1 = "\u27E8";
    var langd = "\u2991";
    var langle = "\u27E8";
    var lap = "\u2A85";
    var laqu = "\xAB";
    var laquo$1 = "\xAB";
    var larr$1 = "\u2190";
    var larrb = "\u21E4";
    var larrbfs = "\u291F";
    var larrfs = "\u291D";
    var larrhk = "\u21A9";
    var larrlp = "\u21AB";
    var larrpl = "\u2939";
    var larrsim = "\u2973";
    var larrtl = "\u21A2";
    var lat = "\u2AAB";
    var latail = "\u2919";
    var late = "\u2AAD";
    var lates = "\u2AAD\uFE00";
    var lbarr = "\u290C";
    var lbbrk = "\u2772";
    var lbrace = "{";
    var lbrack = "[";
    var lbrke = "\u298B";
    var lbrksld = "\u298F";
    var lbrkslu = "\u298D";
    var lcaron = "\u013E";
    var lcedil = "\u013C";
    var lceil$1 = "\u2308";
    var lcub = "{";
    var lcy = "\u043B";
    var ldca = "\u2936";
    var ldquo$1 = "\u201C";
    var ldquor = "\u201E";
    var ldrdhar = "\u2967";
    var ldrushar = "\u294B";
    var ldsh = "\u21B2";
    var le$1 = "\u2264";
    var leftarrow = "\u2190";
    var leftarrowtail = "\u21A2";
    var leftharpoondown = "\u21BD";
    var leftharpoonup = "\u21BC";
    var leftleftarrows = "\u21C7";
    var leftrightarrow = "\u2194";
    var leftrightarrows = "\u21C6";
    var leftrightharpoons = "\u21CB";
    var leftrightsquigarrow = "\u21AD";
    var leftthreetimes = "\u22CB";
    var leg = "\u22DA";
    var leq = "\u2264";
    var leqq = "\u2266";
    var leqslant = "\u2A7D";
    var les = "\u2A7D";
    var lescc = "\u2AA8";
    var lesdot = "\u2A7F";
    var lesdoto = "\u2A81";
    var lesdotor = "\u2A83";
    var lesg = "\u22DA\uFE00";
    var lesges = "\u2A93";
    var lessapprox = "\u2A85";
    var lessdot = "\u22D6";
    var lesseqgtr = "\u22DA";
    var lesseqqgtr = "\u2A8B";
    var lessgtr = "\u2276";
    var lesssim = "\u2272";
    var lfisht = "\u297C";
    var lfloor$1 = "\u230A";
    var lfr = "\u{1D529}";
    var lg = "\u2276";
    var lgE = "\u2A91";
    var lhard = "\u21BD";
    var lharu = "\u21BC";
    var lharul = "\u296A";
    var lhblk = "\u2584";
    var ljcy = "\u0459";
    var ll = "\u226A";
    var llarr = "\u21C7";
    var llcorner = "\u231E";
    var llhard = "\u296B";
    var lltri = "\u25FA";
    var lmidot = "\u0140";
    var lmoust = "\u23B0";
    var lmoustache = "\u23B0";
    var lnE = "\u2268";
    var lnap = "\u2A89";
    var lnapprox = "\u2A89";
    var lne = "\u2A87";
    var lneq = "\u2A87";
    var lneqq = "\u2268";
    var lnsim = "\u22E6";
    var loang = "\u27EC";
    var loarr = "\u21FD";
    var lobrk = "\u27E6";
    var longleftarrow = "\u27F5";
    var longleftrightarrow = "\u27F7";
    var longmapsto = "\u27FC";
    var longrightarrow = "\u27F6";
    var looparrowleft = "\u21AB";
    var looparrowright = "\u21AC";
    var lopar = "\u2985";
    var lopf = "\u{1D55D}";
    var loplus = "\u2A2D";
    var lotimes = "\u2A34";
    var lowast$1 = "\u2217";
    var lowbar = "_";
    var loz$1 = "\u25CA";
    var lozenge = "\u25CA";
    var lozf = "\u29EB";
    var lpar = "(";
    var lparlt = "\u2993";
    var lrarr = "\u21C6";
    var lrcorner = "\u231F";
    var lrhar = "\u21CB";
    var lrhard = "\u296D";
    var lrm$1 = "\u200E";
    var lrtri = "\u22BF";
    var lsaquo$1 = "\u2039";
    var lscr = "\u{1D4C1}";
    var lsh = "\u21B0";
    var lsim = "\u2272";
    var lsime = "\u2A8D";
    var lsimg = "\u2A8F";
    var lsqb = "[";
    var lsquo$1 = "\u2018";
    var lsquor = "\u201A";
    var lstrok = "\u0142";
    var l = "<";
    var lt$1 = "<";
    var ltcc = "\u2AA6";
    var ltcir = "\u2A79";
    var ltdot = "\u22D6";
    var lthree = "\u22CB";
    var ltimes = "\u22C9";
    var ltlarr = "\u2976";
    var ltquest = "\u2A7B";
    var ltrPar = "\u2996";
    var ltri = "\u25C3";
    var ltrie = "\u22B4";
    var ltrif = "\u25C2";
    var lurdshar = "\u294A";
    var luruhar = "\u2966";
    var lvertneqq = "\u2268\uFE00";
    var lvnE = "\u2268\uFE00";
    var mDDot = "\u223A";
    var mac = "\xAF";
    var macr$1 = "\xAF";
    var male = "\u2642";
    var malt = "\u2720";
    var maltese = "\u2720";
    var map$1 = "\u21A6";
    var mapsto = "\u21A6";
    var mapstodown = "\u21A7";
    var mapstoleft = "\u21A4";
    var mapstoup = "\u21A5";
    var marker = "\u25AE";
    var mcomma = "\u2A29";
    var mcy = "\u043C";
    var mdash$1 = "\u2014";
    var measuredangle = "\u2221";
    var mfr = "\u{1D52A}";
    var mho = "\u2127";
    var micr = "\xB5";
    var micro$1 = "\xB5";
    var mid = "\u2223";
    var midast = "*";
    var midcir = "\u2AF0";
    var middo = "\xB7";
    var middot$1 = "\xB7";
    var minus$1 = "\u2212";
    var minusb = "\u229F";
    var minusd = "\u2238";
    var minusdu = "\u2A2A";
    var mlcp = "\u2ADB";
    var mldr = "\u2026";
    var mnplus = "\u2213";
    var models = "\u22A7";
    var mopf = "\u{1D55E}";
    var mp = "\u2213";
    var mscr = "\u{1D4C2}";
    var mstpos = "\u223E";
    var mu$1 = "\u03BC";
    var multimap = "\u22B8";
    var mumap = "\u22B8";
    var nGg = "\u22D9\u0338";
    var nGt = "\u226B\u20D2";
    var nGtv = "\u226B\u0338";
    var nLeftarrow = "\u21CD";
    var nLeftrightarrow = "\u21CE";
    var nLl = "\u22D8\u0338";
    var nLt = "\u226A\u20D2";
    var nLtv = "\u226A\u0338";
    var nRightarrow = "\u21CF";
    var nVDash = "\u22AF";
    var nVdash = "\u22AE";
    var nabla$1 = "\u2207";
    var nacute = "\u0144";
    var nang = "\u2220\u20D2";
    var nap = "\u2249";
    var napE = "\u2A70\u0338";
    var napid = "\u224B\u0338";
    var napos = "\u0149";
    var napprox = "\u2249";
    var natur = "\u266E";
    var natural = "\u266E";
    var naturals = "\u2115";
    var nbs = "\xA0";
    var nbsp$1 = "\xA0";
    var nbump = "\u224E\u0338";
    var nbumpe = "\u224F\u0338";
    var ncap = "\u2A43";
    var ncaron = "\u0148";
    var ncedil = "\u0146";
    var ncong = "\u2247";
    var ncongdot = "\u2A6D\u0338";
    var ncup = "\u2A42";
    var ncy = "\u043D";
    var ndash$1 = "\u2013";
    var ne$1 = "\u2260";
    var neArr = "\u21D7";
    var nearhk = "\u2924";
    var nearr = "\u2197";
    var nearrow = "\u2197";
    var nedot = "\u2250\u0338";
    var nequiv = "\u2262";
    var nesear = "\u2928";
    var nesim = "\u2242\u0338";
    var nexist = "\u2204";
    var nexists = "\u2204";
    var nfr = "\u{1D52B}";
    var ngE = "\u2267\u0338";
    var nge = "\u2271";
    var ngeq = "\u2271";
    var ngeqq = "\u2267\u0338";
    var ngeqslant = "\u2A7E\u0338";
    var nges = "\u2A7E\u0338";
    var ngsim = "\u2275";
    var ngt = "\u226F";
    var ngtr = "\u226F";
    var nhArr = "\u21CE";
    var nharr = "\u21AE";
    var nhpar = "\u2AF2";
    var ni$1 = "\u220B";
    var nis = "\u22FC";
    var nisd = "\u22FA";
    var niv = "\u220B";
    var njcy = "\u045A";
    var nlArr = "\u21CD";
    var nlE = "\u2266\u0338";
    var nlarr = "\u219A";
    var nldr = "\u2025";
    var nle = "\u2270";
    var nleftarrow = "\u219A";
    var nleftrightarrow = "\u21AE";
    var nleq = "\u2270";
    var nleqq = "\u2266\u0338";
    var nleqslant = "\u2A7D\u0338";
    var nles = "\u2A7D\u0338";
    var nless = "\u226E";
    var nlsim = "\u2274";
    var nlt = "\u226E";
    var nltri = "\u22EA";
    var nltrie = "\u22EC";
    var nmid = "\u2224";
    var nopf = "\u{1D55F}";
    var no = "\xAC";
    var not$1 = "\xAC";
    var notin$1 = "\u2209";
    var notinE = "\u22F9\u0338";
    var notindot = "\u22F5\u0338";
    var notinva = "\u2209";
    var notinvb = "\u22F7";
    var notinvc = "\u22F6";
    var notni = "\u220C";
    var notniva = "\u220C";
    var notnivb = "\u22FE";
    var notnivc = "\u22FD";
    var npar = "\u2226";
    var nparallel = "\u2226";
    var nparsl = "\u2AFD\u20E5";
    var npart = "\u2202\u0338";
    var npolint = "\u2A14";
    var npr = "\u2280";
    var nprcue = "\u22E0";
    var npre = "\u2AAF\u0338";
    var nprec = "\u2280";
    var npreceq = "\u2AAF\u0338";
    var nrArr = "\u21CF";
    var nrarr = "\u219B";
    var nrarrc = "\u2933\u0338";
    var nrarrw = "\u219D\u0338";
    var nrightarrow = "\u219B";
    var nrtri = "\u22EB";
    var nrtrie = "\u22ED";
    var nsc = "\u2281";
    var nsccue = "\u22E1";
    var nsce = "\u2AB0\u0338";
    var nscr = "\u{1D4C3}";
    var nshortmid = "\u2224";
    var nshortparallel = "\u2226";
    var nsim = "\u2241";
    var nsime = "\u2244";
    var nsimeq = "\u2244";
    var nsmid = "\u2224";
    var nspar = "\u2226";
    var nsqsube = "\u22E2";
    var nsqsupe = "\u22E3";
    var nsub$1 = "\u2284";
    var nsubE = "\u2AC5\u0338";
    var nsube = "\u2288";
    var nsubset = "\u2282\u20D2";
    var nsubseteq = "\u2288";
    var nsubseteqq = "\u2AC5\u0338";
    var nsucc = "\u2281";
    var nsucceq = "\u2AB0\u0338";
    var nsup = "\u2285";
    var nsupE = "\u2AC6\u0338";
    var nsupe = "\u2289";
    var nsupset = "\u2283\u20D2";
    var nsupseteq = "\u2289";
    var nsupseteqq = "\u2AC6\u0338";
    var ntgl = "\u2279";
    var ntild = "\xF1";
    var ntilde$1 = "\xF1";
    var ntlg = "\u2278";
    var ntriangleleft = "\u22EA";
    var ntrianglelefteq = "\u22EC";
    var ntriangleright = "\u22EB";
    var ntrianglerighteq = "\u22ED";
    var nu$1 = "\u03BD";
    var num = "#";
    var numero = "\u2116";
    var numsp = "\u2007";
    var nvDash = "\u22AD";
    var nvHarr = "\u2904";
    var nvap = "\u224D\u20D2";
    var nvdash = "\u22AC";
    var nvge = "\u2265\u20D2";
    var nvgt = ">\u20D2";
    var nvinfin = "\u29DE";
    var nvlArr = "\u2902";
    var nvle = "\u2264\u20D2";
    var nvlt = "<\u20D2";
    var nvltrie = "\u22B4\u20D2";
    var nvrArr = "\u2903";
    var nvrtrie = "\u22B5\u20D2";
    var nvsim = "\u223C\u20D2";
    var nwArr = "\u21D6";
    var nwarhk = "\u2923";
    var nwarr = "\u2196";
    var nwarrow = "\u2196";
    var nwnear = "\u2927";
    var oS = "\u24C8";
    var oacut = "\xF3";
    var oacute$1 = "\xF3";
    var oast = "\u229B";
    var ocir = "\xF4";
    var ocirc$1 = "\xF4";
    var ocy = "\u043E";
    var odash = "\u229D";
    var odblac = "\u0151";
    var odiv = "\u2A38";
    var odot = "\u2299";
    var odsold = "\u29BC";
    var oelig$1 = "\u0153";
    var ofcir = "\u29BF";
    var ofr = "\u{1D52C}";
    var ogon = "\u02DB";
    var ograv = "\xF2";
    var ograve$1 = "\xF2";
    var ogt = "\u29C1";
    var ohbar = "\u29B5";
    var ohm = "\u03A9";
    var oint = "\u222E";
    var olarr = "\u21BA";
    var olcir = "\u29BE";
    var olcross = "\u29BB";
    var oline$1 = "\u203E";
    var olt = "\u29C0";
    var omacr = "\u014D";
    var omega$1 = "\u03C9";
    var omicron$1 = "\u03BF";
    var omid = "\u29B6";
    var ominus = "\u2296";
    var oopf = "\u{1D560}";
    var opar = "\u29B7";
    var operp = "\u29B9";
    var oplus$1 = "\u2295";
    var or$1 = "\u2228";
    var orarr = "\u21BB";
    var ord = "\xBA";
    var order = "\u2134";
    var orderof = "\u2134";
    var ordf$1 = "\xAA";
    var ordm$1 = "\xBA";
    var origof = "\u22B6";
    var oror = "\u2A56";
    var orslope = "\u2A57";
    var orv = "\u2A5B";
    var oscr = "\u2134";
    var oslas = "\xF8";
    var oslash$1 = "\xF8";
    var osol = "\u2298";
    var otild = "\xF5";
    var otilde$1 = "\xF5";
    var otimes$1 = "\u2297";
    var otimesas = "\u2A36";
    var oum = "\xF6";
    var ouml$1 = "\xF6";
    var ovbar = "\u233D";
    var par = "\xB6";
    var para$1 = "\xB6";
    var parallel = "\u2225";
    var parsim = "\u2AF3";
    var parsl = "\u2AFD";
    var part$1 = "\u2202";
    var pcy = "\u043F";
    var percnt = "%";
    var period = ".";
    var permil$1 = "\u2030";
    var perp$1 = "\u22A5";
    var pertenk = "\u2031";
    var pfr = "\u{1D52D}";
    var phi$1 = "\u03C6";
    var phiv = "\u03D5";
    var phmmat = "\u2133";
    var phone = "\u260E";
    var pi$1 = "\u03C0";
    var pitchfork = "\u22D4";
    var piv$1 = "\u03D6";
    var planck = "\u210F";
    var planckh = "\u210E";
    var plankv = "\u210F";
    var plus = "+";
    var plusacir = "\u2A23";
    var plusb = "\u229E";
    var pluscir = "\u2A22";
    var plusdo = "\u2214";
    var plusdu = "\u2A25";
    var pluse = "\u2A72";
    var plusm = "\xB1";
    var plusmn$1 = "\xB1";
    var plussim = "\u2A26";
    var plustwo = "\u2A27";
    var pm = "\xB1";
    var pointint = "\u2A15";
    var popf = "\u{1D561}";
    var poun = "\xA3";
    var pound$1 = "\xA3";
    var pr = "\u227A";
    var prE = "\u2AB3";
    var prap = "\u2AB7";
    var prcue = "\u227C";
    var pre = "\u2AAF";
    var prec = "\u227A";
    var precapprox = "\u2AB7";
    var preccurlyeq = "\u227C";
    var preceq = "\u2AAF";
    var precnapprox = "\u2AB9";
    var precneqq = "\u2AB5";
    var precnsim = "\u22E8";
    var precsim = "\u227E";
    var prime$1 = "\u2032";
    var primes = "\u2119";
    var prnE = "\u2AB5";
    var prnap = "\u2AB9";
    var prnsim = "\u22E8";
    var prod$1 = "\u220F";
    var profalar = "\u232E";
    var profline = "\u2312";
    var profsurf = "\u2313";
    var prop$1 = "\u221D";
    var propto = "\u221D";
    var prsim = "\u227E";
    var prurel = "\u22B0";
    var pscr = "\u{1D4C5}";
    var psi$1 = "\u03C8";
    var puncsp = "\u2008";
    var qfr = "\u{1D52E}";
    var qint = "\u2A0C";
    var qopf = "\u{1D562}";
    var qprime = "\u2057";
    var qscr = "\u{1D4C6}";
    var quaternions = "\u210D";
    var quatint = "\u2A16";
    var quest = "?";
    var questeq = "\u225F";
    var quo = '"';
    var quot$1 = '"';
    var rAarr = "\u21DB";
    var rArr$1 = "\u21D2";
    var rAtail = "\u291C";
    var rBarr = "\u290F";
    var rHar = "\u2964";
    var race = "\u223D\u0331";
    var racute = "\u0155";
    var radic$1 = "\u221A";
    var raemptyv = "\u29B3";
    var rang$1 = "\u27E9";
    var rangd = "\u2992";
    var range = "\u29A5";
    var rangle = "\u27E9";
    var raqu = "\xBB";
    var raquo$1 = "\xBB";
    var rarr$1 = "\u2192";
    var rarrap = "\u2975";
    var rarrb = "\u21E5";
    var rarrbfs = "\u2920";
    var rarrc = "\u2933";
    var rarrfs = "\u291E";
    var rarrhk = "\u21AA";
    var rarrlp = "\u21AC";
    var rarrpl = "\u2945";
    var rarrsim = "\u2974";
    var rarrtl = "\u21A3";
    var rarrw = "\u219D";
    var ratail = "\u291A";
    var ratio = "\u2236";
    var rationals = "\u211A";
    var rbarr = "\u290D";
    var rbbrk = "\u2773";
    var rbrace = "}";
    var rbrack = "]";
    var rbrke = "\u298C";
    var rbrksld = "\u298E";
    var rbrkslu = "\u2990";
    var rcaron = "\u0159";
    var rcedil = "\u0157";
    var rceil$1 = "\u2309";
    var rcub = "}";
    var rcy = "\u0440";
    var rdca = "\u2937";
    var rdldhar = "\u2969";
    var rdquo$1 = "\u201D";
    var rdquor = "\u201D";
    var rdsh = "\u21B3";
    var real$1 = "\u211C";
    var realine = "\u211B";
    var realpart = "\u211C";
    var reals = "\u211D";
    var rect = "\u25AD";
    var re$3 = "\xAE";
    var reg$1 = "\xAE";
    var rfisht = "\u297D";
    var rfloor$1 = "\u230B";
    var rfr = "\u{1D52F}";
    var rhard = "\u21C1";
    var rharu = "\u21C0";
    var rharul = "\u296C";
    var rho$1 = "\u03C1";
    var rhov = "\u03F1";
    var rightarrow = "\u2192";
    var rightarrowtail = "\u21A3";
    var rightharpoondown = "\u21C1";
    var rightharpoonup = "\u21C0";
    var rightleftarrows = "\u21C4";
    var rightleftharpoons = "\u21CC";
    var rightrightarrows = "\u21C9";
    var rightsquigarrow = "\u219D";
    var rightthreetimes = "\u22CC";
    var ring = "\u02DA";
    var risingdotseq = "\u2253";
    var rlarr = "\u21C4";
    var rlhar = "\u21CC";
    var rlm$1 = "\u200F";
    var rmoust = "\u23B1";
    var rmoustache = "\u23B1";
    var rnmid = "\u2AEE";
    var roang = "\u27ED";
    var roarr = "\u21FE";
    var robrk = "\u27E7";
    var ropar = "\u2986";
    var ropf = "\u{1D563}";
    var roplus = "\u2A2E";
    var rotimes = "\u2A35";
    var rpar = ")";
    var rpargt = "\u2994";
    var rppolint = "\u2A12";
    var rrarr = "\u21C9";
    var rsaquo$1 = "\u203A";
    var rscr = "\u{1D4C7}";
    var rsh = "\u21B1";
    var rsqb = "]";
    var rsquo$1 = "\u2019";
    var rsquor = "\u2019";
    var rthree = "\u22CC";
    var rtimes = "\u22CA";
    var rtri = "\u25B9";
    var rtrie = "\u22B5";
    var rtrif = "\u25B8";
    var rtriltri = "\u29CE";
    var ruluhar = "\u2968";
    var rx = "\u211E";
    var sacute = "\u015B";
    var sbquo$1 = "\u201A";
    var sc = "\u227B";
    var scE = "\u2AB4";
    var scap = "\u2AB8";
    var scaron$1 = "\u0161";
    var sccue = "\u227D";
    var sce = "\u2AB0";
    var scedil = "\u015F";
    var scirc = "\u015D";
    var scnE = "\u2AB6";
    var scnap = "\u2ABA";
    var scnsim = "\u22E9";
    var scpolint = "\u2A13";
    var scsim = "\u227F";
    var scy = "\u0441";
    var sdot$1 = "\u22C5";
    var sdotb = "\u22A1";
    var sdote = "\u2A66";
    var seArr = "\u21D8";
    var searhk = "\u2925";
    var searr = "\u2198";
    var searrow = "\u2198";
    var sec = "\xA7";
    var sect$1 = "\xA7";
    var semi = ";";
    var seswar = "\u2929";
    var setminus = "\u2216";
    var setmn = "\u2216";
    var sext = "\u2736";
    var sfr = "\u{1D530}";
    var sfrown = "\u2322";
    var sharp = "\u266F";
    var shchcy = "\u0449";
    var shcy = "\u0448";
    var shortmid = "\u2223";
    var shortparallel = "\u2225";
    var sh = "\xAD";
    var shy$1 = "\xAD";
    var sigma$1 = "\u03C3";
    var sigmaf$1 = "\u03C2";
    var sigmav = "\u03C2";
    var sim$1 = "\u223C";
    var simdot = "\u2A6A";
    var sime = "\u2243";
    var simeq = "\u2243";
    var simg = "\u2A9E";
    var simgE = "\u2AA0";
    var siml = "\u2A9D";
    var simlE = "\u2A9F";
    var simne = "\u2246";
    var simplus = "\u2A24";
    var simrarr = "\u2972";
    var slarr = "\u2190";
    var smallsetminus = "\u2216";
    var smashp = "\u2A33";
    var smeparsl = "\u29E4";
    var smid = "\u2223";
    var smile = "\u2323";
    var smt = "\u2AAA";
    var smte = "\u2AAC";
    var smtes = "\u2AAC\uFE00";
    var softcy = "\u044C";
    var sol = "/";
    var solb = "\u29C4";
    var solbar = "\u233F";
    var sopf = "\u{1D564}";
    var spades$1 = "\u2660";
    var spadesuit = "\u2660";
    var spar = "\u2225";
    var sqcap = "\u2293";
    var sqcaps = "\u2293\uFE00";
    var sqcup = "\u2294";
    var sqcups = "\u2294\uFE00";
    var sqsub = "\u228F";
    var sqsube = "\u2291";
    var sqsubset = "\u228F";
    var sqsubseteq = "\u2291";
    var sqsup = "\u2290";
    var sqsupe = "\u2292";
    var sqsupset = "\u2290";
    var sqsupseteq = "\u2292";
    var squ = "\u25A1";
    var square = "\u25A1";
    var squarf = "\u25AA";
    var squf = "\u25AA";
    var srarr = "\u2192";
    var sscr = "\u{1D4C8}";
    var ssetmn = "\u2216";
    var ssmile = "\u2323";
    var sstarf = "\u22C6";
    var star = "\u2606";
    var starf = "\u2605";
    var straightepsilon = "\u03F5";
    var straightphi = "\u03D5";
    var strns = "\xAF";
    var sub$1 = "\u2282";
    var subE = "\u2AC5";
    var subdot = "\u2ABD";
    var sube$1 = "\u2286";
    var subedot = "\u2AC3";
    var submult = "\u2AC1";
    var subnE = "\u2ACB";
    var subne = "\u228A";
    var subplus = "\u2ABF";
    var subrarr = "\u2979";
    var subset = "\u2282";
    var subseteq = "\u2286";
    var subseteqq = "\u2AC5";
    var subsetneq = "\u228A";
    var subsetneqq = "\u2ACB";
    var subsim = "\u2AC7";
    var subsub = "\u2AD5";
    var subsup = "\u2AD3";
    var succ = "\u227B";
    var succapprox = "\u2AB8";
    var succcurlyeq = "\u227D";
    var succeq = "\u2AB0";
    var succnapprox = "\u2ABA";
    var succneqq = "\u2AB6";
    var succnsim = "\u22E9";
    var succsim = "\u227F";
    var sum$1 = "\u2211";
    var sung = "\u266A";
    var sup$1 = "\u2283";
    var sup1$1 = "\xB9";
    var sup2$1 = "\xB2";
    var sup3$1 = "\xB3";
    var supE = "\u2AC6";
    var supdot = "\u2ABE";
    var supdsub = "\u2AD8";
    var supe$1 = "\u2287";
    var supedot = "\u2AC4";
    var suphsol = "\u27C9";
    var suphsub = "\u2AD7";
    var suplarr = "\u297B";
    var supmult = "\u2AC2";
    var supnE = "\u2ACC";
    var supne = "\u228B";
    var supplus = "\u2AC0";
    var supset = "\u2283";
    var supseteq = "\u2287";
    var supseteqq = "\u2AC6";
    var supsetneq = "\u228B";
    var supsetneqq = "\u2ACC";
    var supsim = "\u2AC8";
    var supsub = "\u2AD4";
    var supsup = "\u2AD6";
    var swArr = "\u21D9";
    var swarhk = "\u2926";
    var swarr = "\u2199";
    var swarrow = "\u2199";
    var swnwar = "\u292A";
    var szli = "\xDF";
    var szlig$1 = "\xDF";
    var target = "\u2316";
    var tau$1 = "\u03C4";
    var tbrk = "\u23B4";
    var tcaron = "\u0165";
    var tcedil = "\u0163";
    var tcy = "\u0442";
    var tdot = "\u20DB";
    var telrec = "\u2315";
    var tfr = "\u{1D531}";
    var there4$1 = "\u2234";
    var therefore = "\u2234";
    var theta$1 = "\u03B8";
    var thetasym$1 = "\u03D1";
    var thetav = "\u03D1";
    var thickapprox = "\u2248";
    var thicksim = "\u223C";
    var thinsp$1 = "\u2009";
    var thkap = "\u2248";
    var thksim = "\u223C";
    var thor = "\xFE";
    var thorn$1 = "\xFE";
    var tilde$4 = "\u02DC";
    var time = "\xD7";
    var times$1 = "\xD7";
    var timesb = "\u22A0";
    var timesbar = "\u2A31";
    var timesd = "\u2A30";
    var tint = "\u222D";
    var toea = "\u2928";
    var top = "\u22A4";
    var topbot = "\u2336";
    var topcir = "\u2AF1";
    var topf = "\u{1D565}";
    var topfork = "\u2ADA";
    var tosa = "\u2929";
    var tprime = "\u2034";
    var trade$1 = "\u2122";
    var triangle = "\u25B5";
    var triangledown = "\u25BF";
    var triangleleft = "\u25C3";
    var trianglelefteq = "\u22B4";
    var triangleq = "\u225C";
    var triangleright = "\u25B9";
    var trianglerighteq = "\u22B5";
    var tridot = "\u25EC";
    var trie = "\u225C";
    var triminus = "\u2A3A";
    var triplus = "\u2A39";
    var trisb = "\u29CD";
    var tritime = "\u2A3B";
    var trpezium = "\u23E2";
    var tscr = "\u{1D4C9}";
    var tscy = "\u0446";
    var tshcy = "\u045B";
    var tstrok = "\u0167";
    var twixt = "\u226C";
    var twoheadleftarrow = "\u219E";
    var twoheadrightarrow = "\u21A0";
    var uArr$1 = "\u21D1";
    var uHar = "\u2963";
    var uacut = "\xFA";
    var uacute$1 = "\xFA";
    var uarr$1 = "\u2191";
    var ubrcy = "\u045E";
    var ubreve = "\u016D";
    var ucir = "\xFB";
    var ucirc$1 = "\xFB";
    var ucy = "\u0443";
    var udarr = "\u21C5";
    var udblac = "\u0171";
    var udhar = "\u296E";
    var ufisht = "\u297E";
    var ufr = "\u{1D532}";
    var ugrav = "\xF9";
    var ugrave$1 = "\xF9";
    var uharl = "\u21BF";
    var uharr = "\u21BE";
    var uhblk = "\u2580";
    var ulcorn = "\u231C";
    var ulcorner = "\u231C";
    var ulcrop = "\u230F";
    var ultri = "\u25F8";
    var umacr = "\u016B";
    var um = "\xA8";
    var uml$1 = "\xA8";
    var uogon = "\u0173";
    var uopf = "\u{1D566}";
    var uparrow = "\u2191";
    var updownarrow = "\u2195";
    var upharpoonleft = "\u21BF";
    var upharpoonright = "\u21BE";
    var uplus = "\u228E";
    var upsi = "\u03C5";
    var upsih$1 = "\u03D2";
    var upsilon$1 = "\u03C5";
    var upuparrows = "\u21C8";
    var urcorn = "\u231D";
    var urcorner = "\u231D";
    var urcrop = "\u230E";
    var uring = "\u016F";
    var urtri = "\u25F9";
    var uscr = "\u{1D4CA}";
    var utdot = "\u22F0";
    var utilde = "\u0169";
    var utri = "\u25B5";
    var utrif = "\u25B4";
    var uuarr = "\u21C8";
    var uum = "\xFC";
    var uuml$1 = "\xFC";
    var uwangle = "\u29A7";
    var vArr = "\u21D5";
    var vBar = "\u2AE8";
    var vBarv = "\u2AE9";
    var vDash = "\u22A8";
    var vangrt = "\u299C";
    var varepsilon = "\u03F5";
    var varkappa = "\u03F0";
    var varnothing = "\u2205";
    var varphi = "\u03D5";
    var varpi = "\u03D6";
    var varpropto = "\u221D";
    var varr = "\u2195";
    var varrho = "\u03F1";
    var varsigma = "\u03C2";
    var varsubsetneq = "\u228A\uFE00";
    var varsubsetneqq = "\u2ACB\uFE00";
    var varsupsetneq = "\u228B\uFE00";
    var varsupsetneqq = "\u2ACC\uFE00";
    var vartheta = "\u03D1";
    var vartriangleleft = "\u22B2";
    var vartriangleright = "\u22B3";
    var vcy = "\u0432";
    var vdash = "\u22A2";
    var vee = "\u2228";
    var veebar = "\u22BB";
    var veeeq = "\u225A";
    var vellip = "\u22EE";
    var verbar = "|";
    var vert = "|";
    var vfr = "\u{1D533}";
    var vltri = "\u22B2";
    var vnsub = "\u2282\u20D2";
    var vnsup = "\u2283\u20D2";
    var vopf = "\u{1D567}";
    var vprop = "\u221D";
    var vrtri = "\u22B3";
    var vscr = "\u{1D4CB}";
    var vsubnE = "\u2ACB\uFE00";
    var vsubne = "\u228A\uFE00";
    var vsupnE = "\u2ACC\uFE00";
    var vsupne = "\u228B\uFE00";
    var vzigzag = "\u299A";
    var wcirc = "\u0175";
    var wedbar = "\u2A5F";
    var wedge = "\u2227";
    var wedgeq = "\u2259";
    var weierp$1 = "\u2118";
    var wfr = "\u{1D534}";
    var wopf = "\u{1D568}";
    var wp = "\u2118";
    var wr = "\u2240";
    var wreath = "\u2240";
    var wscr = "\u{1D4CC}";
    var xcap = "\u22C2";
    var xcirc = "\u25EF";
    var xcup = "\u22C3";
    var xdtri = "\u25BD";
    var xfr = "\u{1D535}";
    var xhArr = "\u27FA";
    var xharr = "\u27F7";
    var xi$1 = "\u03BE";
    var xlArr = "\u27F8";
    var xlarr = "\u27F5";
    var xmap = "\u27FC";
    var xnis = "\u22FB";
    var xodot = "\u2A00";
    var xopf = "\u{1D569}";
    var xoplus = "\u2A01";
    var xotime = "\u2A02";
    var xrArr = "\u27F9";
    var xrarr = "\u27F6";
    var xscr = "\u{1D4CD}";
    var xsqcup = "\u2A06";
    var xuplus = "\u2A04";
    var xutri = "\u25B3";
    var xvee = "\u22C1";
    var xwedge = "\u22C0";
    var yacut = "\xFD";
    var yacute$1 = "\xFD";
    var yacy = "\u044F";
    var ycirc = "\u0177";
    var ycy = "\u044B";
    var ye = "\xA5";
    var yen$1 = "\xA5";
    var yfr = "\u{1D536}";
    var yicy = "\u0457";
    var yopf = "\u{1D56A}";
    var yscr = "\u{1D4CE}";
    var yucy = "\u044E";
    var yum = "\xFF";
    var yuml$1 = "\xFF";
    var zacute = "\u017A";
    var zcaron = "\u017E";
    var zcy = "\u0437";
    var zdot = "\u017C";
    var zeetrf = "\u2128";
    var zeta$1 = "\u03B6";
    var zfr = "\u{1D537}";
    var zhcy = "\u0436";
    var zigrarr = "\u21DD";
    var zopf = "\u{1D56B}";
    var zscr = "\u{1D4CF}";
    var zwj$1 = "\u200D";
    var zwnj$1 = "\u200C";
    var index$3 = {
      AEli,
      AElig: AElig$1,
      AM,
      AMP: AMP$1,
      Aacut,
      Aacute: Aacute$1,
      Abreve,
      Acir,
      Acirc: Acirc$1,
      Acy,
      Afr,
      Agrav,
      Agrave: Agrave$1,
      Alpha: Alpha$1,
      Amacr,
      And,
      Aogon,
      Aopf,
      ApplyFunction,
      Arin,
      Aring: Aring$1,
      Ascr,
      Assign,
      Atild,
      Atilde: Atilde$1,
      Aum,
      Auml: Auml$1,
      Backslash,
      Barv,
      Barwed,
      Bcy,
      Because,
      Bernoullis,
      Beta: Beta$1,
      Bfr,
      Bopf,
      Breve,
      Bscr,
      Bumpeq,
      CHcy,
      COP,
      COPY,
      Cacute,
      Cap,
      CapitalDifferentialD,
      Cayleys,
      Ccaron,
      Ccedi,
      Ccedil: Ccedil$1,
      Ccirc,
      Cconint,
      Cdot,
      Cedilla,
      CenterDot,
      Cfr,
      Chi: Chi$1,
      CircleDot,
      CircleMinus,
      CirclePlus,
      CircleTimes,
      ClockwiseContourIntegral,
      CloseCurlyDoubleQuote,
      CloseCurlyQuote,
      Colon,
      Colone,
      Congruent,
      Conint,
      ContourIntegral,
      Copf,
      Coproduct,
      CounterClockwiseContourIntegral,
      Cross,
      Cscr,
      Cup,
      CupCap,
      DD,
      DDotrahd,
      DJcy,
      DScy,
      DZcy,
      Dagger: Dagger$1,
      Darr,
      Dashv,
      Dcaron,
      Dcy,
      Del,
      Delta: Delta$1,
      Dfr,
      DiacriticalAcute,
      DiacriticalDot,
      DiacriticalDoubleAcute,
      DiacriticalGrave,
      DiacriticalTilde,
      Diamond,
      DifferentialD,
      Dopf,
      Dot,
      DotDot,
      DotEqual,
      DoubleContourIntegral,
      DoubleDot,
      DoubleDownArrow,
      DoubleLeftArrow,
      DoubleLeftRightArrow,
      DoubleLeftTee,
      DoubleLongLeftArrow,
      DoubleLongLeftRightArrow,
      DoubleLongRightArrow,
      DoubleRightArrow,
      DoubleRightTee,
      DoubleUpArrow,
      DoubleUpDownArrow,
      DoubleVerticalBar,
      DownArrow,
      DownArrowBar,
      DownArrowUpArrow,
      DownBreve,
      DownLeftRightVector,
      DownLeftTeeVector,
      DownLeftVector,
      DownLeftVectorBar,
      DownRightTeeVector,
      DownRightVector,
      DownRightVectorBar,
      DownTee,
      DownTeeArrow,
      Downarrow,
      Dscr,
      Dstrok,
      ENG,
      ET,
      ETH: ETH$1,
      Eacut,
      Eacute: Eacute$1,
      Ecaron,
      Ecir,
      Ecirc: Ecirc$1,
      Ecy,
      Edot,
      Efr,
      Egrav,
      Egrave: Egrave$1,
      Element: Element2,
      Emacr,
      EmptySmallSquare,
      EmptyVerySmallSquare,
      Eogon,
      Eopf,
      Epsilon: Epsilon$1,
      Equal,
      EqualTilde,
      Equilibrium,
      Escr,
      Esim,
      Eta: Eta$1,
      Eum,
      Euml: Euml$1,
      Exists,
      ExponentialE,
      Fcy,
      Ffr,
      FilledSmallSquare,
      FilledVerySmallSquare,
      Fopf,
      ForAll,
      Fouriertrf,
      Fscr,
      GJcy,
      G,
      GT: GT$1,
      Gamma: Gamma$1,
      Gammad,
      Gbreve,
      Gcedil,
      Gcirc,
      Gcy,
      Gdot,
      Gfr,
      Gg,
      Gopf,
      GreaterEqual,
      GreaterEqualLess,
      GreaterFullEqual,
      GreaterGreater,
      GreaterLess,
      GreaterSlantEqual,
      GreaterTilde,
      Gscr,
      Gt,
      HARDcy,
      Hacek,
      Hat,
      Hcirc,
      Hfr,
      HilbertSpace,
      Hopf,
      HorizontalLine,
      Hscr,
      Hstrok,
      HumpDownHump,
      HumpEqual,
      IEcy,
      IJlig,
      IOcy,
      Iacut,
      Iacute: Iacute$1,
      Icir,
      Icirc: Icirc$1,
      Icy,
      Idot,
      Ifr,
      Igrav,
      Igrave: Igrave$1,
      Im,
      Imacr,
      ImaginaryI,
      Implies,
      Int,
      Integral,
      Intersection,
      InvisibleComma,
      InvisibleTimes,
      Iogon,
      Iopf,
      Iota: Iota$1,
      Iscr,
      Itilde,
      Iukcy,
      Ium,
      Iuml: Iuml$1,
      Jcirc,
      Jcy,
      Jfr,
      Jopf,
      Jscr,
      Jsercy,
      Jukcy,
      KHcy,
      KJcy,
      Kappa: Kappa$1,
      Kcedil,
      Kcy,
      Kfr,
      Kopf,
      Kscr,
      LJcy,
      L,
      LT: LT$1,
      Lacute,
      Lambda: Lambda$1,
      Lang,
      Laplacetrf,
      Larr,
      Lcaron,
      Lcedil,
      Lcy,
      LeftAngleBracket,
      LeftArrow,
      LeftArrowBar,
      LeftArrowRightArrow,
      LeftCeiling,
      LeftDoubleBracket,
      LeftDownTeeVector,
      LeftDownVector,
      LeftDownVectorBar,
      LeftFloor,
      LeftRightArrow,
      LeftRightVector,
      LeftTee,
      LeftTeeArrow,
      LeftTeeVector,
      LeftTriangle,
      LeftTriangleBar,
      LeftTriangleEqual,
      LeftUpDownVector,
      LeftUpTeeVector,
      LeftUpVector,
      LeftUpVectorBar,
      LeftVector,
      LeftVectorBar,
      Leftarrow,
      Leftrightarrow,
      LessEqualGreater,
      LessFullEqual,
      LessGreater,
      LessLess,
      LessSlantEqual,
      LessTilde,
      Lfr,
      Ll,
      Lleftarrow,
      Lmidot,
      LongLeftArrow,
      LongLeftRightArrow,
      LongRightArrow,
      Longleftarrow,
      Longleftrightarrow,
      Longrightarrow,
      Lopf,
      LowerLeftArrow,
      LowerRightArrow,
      Lscr,
      Lsh,
      Lstrok,
      Lt,
      "Map": "\u2905",
      Mcy,
      MediumSpace,
      Mellintrf,
      Mfr,
      MinusPlus,
      Mopf,
      Mscr,
      Mu: Mu$1,
      NJcy,
      Nacute,
      Ncaron,
      Ncedil,
      Ncy,
      NegativeMediumSpace,
      NegativeThickSpace,
      NegativeThinSpace,
      NegativeVeryThinSpace,
      NestedGreaterGreater,
      NestedLessLess,
      NewLine,
      Nfr,
      NoBreak,
      NonBreakingSpace,
      Nopf,
      Not,
      NotCongruent,
      NotCupCap,
      NotDoubleVerticalBar,
      NotElement,
      NotEqual,
      NotEqualTilde,
      NotExists,
      NotGreater,
      NotGreaterEqual,
      NotGreaterFullEqual,
      NotGreaterGreater,
      NotGreaterLess,
      NotGreaterSlantEqual,
      NotGreaterTilde,
      NotHumpDownHump,
      NotHumpEqual,
      NotLeftTriangle,
      NotLeftTriangleBar,
      NotLeftTriangleEqual,
      NotLess,
      NotLessEqual,
      NotLessGreater,
      NotLessLess,
      NotLessSlantEqual,
      NotLessTilde,
      NotNestedGreaterGreater,
      NotNestedLessLess,
      NotPrecedes,
      NotPrecedesEqual,
      NotPrecedesSlantEqual,
      NotReverseElement,
      NotRightTriangle,
      NotRightTriangleBar,
      NotRightTriangleEqual,
      NotSquareSubset,
      NotSquareSubsetEqual,
      NotSquareSuperset,
      NotSquareSupersetEqual,
      NotSubset,
      NotSubsetEqual,
      NotSucceeds,
      NotSucceedsEqual,
      NotSucceedsSlantEqual,
      NotSucceedsTilde,
      NotSuperset,
      NotSupersetEqual,
      NotTilde,
      NotTildeEqual,
      NotTildeFullEqual,
      NotTildeTilde,
      NotVerticalBar,
      Nscr,
      Ntild,
      Ntilde: Ntilde$1,
      Nu: Nu$1,
      OElig: OElig$1,
      Oacut,
      Oacute: Oacute$1,
      Ocir,
      Ocirc: Ocirc$1,
      Ocy,
      Odblac,
      Ofr,
      Ograv,
      Ograve: Ograve$1,
      Omacr,
      Omega: Omega$1,
      Omicron: Omicron$1,
      Oopf,
      OpenCurlyDoubleQuote,
      OpenCurlyQuote,
      Or,
      Oscr,
      Oslas,
      Oslash: Oslash$1,
      Otild,
      Otilde: Otilde$1,
      Otimes,
      Oum,
      Ouml: Ouml$1,
      OverBar,
      OverBrace,
      OverBracket,
      OverParenthesis,
      PartialD,
      Pcy,
      Pfr,
      Phi: Phi$1,
      Pi: Pi$1,
      PlusMinus,
      Poincareplane,
      Popf,
      Pr,
      Precedes,
      PrecedesEqual,
      PrecedesSlantEqual,
      PrecedesTilde,
      Prime: Prime$1,
      Product,
      Proportion,
      Proportional,
      Pscr,
      Psi: Psi$1,
      QUO,
      QUOT,
      Qfr,
      Qopf,
      Qscr,
      RBarr,
      RE,
      REG,
      Racute,
      Rang,
      Rarr,
      Rarrtl,
      Rcaron,
      Rcedil,
      Rcy,
      Re,
      ReverseElement,
      ReverseEquilibrium,
      ReverseUpEquilibrium,
      Rfr,
      Rho: Rho$1,
      RightAngleBracket,
      RightArrow,
      RightArrowBar,
      RightArrowLeftArrow,
      RightCeiling,
      RightDoubleBracket,
      RightDownTeeVector,
      RightDownVector,
      RightDownVectorBar,
      RightFloor,
      RightTee,
      RightTeeArrow,
      RightTeeVector,
      RightTriangle,
      RightTriangleBar,
      RightTriangleEqual,
      RightUpDownVector,
      RightUpTeeVector,
      RightUpVector,
      RightUpVectorBar,
      RightVector,
      RightVectorBar,
      Rightarrow,
      Ropf,
      RoundImplies,
      Rrightarrow,
      Rscr,
      Rsh,
      RuleDelayed,
      SHCHcy,
      SHcy,
      SOFTcy,
      Sacute,
      Sc,
      Scaron: Scaron$1,
      Scedil,
      Scirc,
      Scy,
      Sfr,
      ShortDownArrow,
      ShortLeftArrow,
      ShortRightArrow,
      ShortUpArrow,
      Sigma: Sigma$1,
      SmallCircle,
      Sopf,
      Sqrt,
      Square,
      SquareIntersection,
      SquareSubset,
      SquareSubsetEqual,
      SquareSuperset,
      SquareSupersetEqual,
      SquareUnion,
      Sscr,
      Star,
      Sub,
      Subset,
      SubsetEqual,
      Succeeds,
      SucceedsEqual,
      SucceedsSlantEqual,
      SucceedsTilde,
      SuchThat,
      Sum,
      Sup,
      Superset,
      SupersetEqual,
      Supset,
      THOR,
      THORN: THORN$1,
      TRADE,
      TSHcy,
      TScy,
      Tab,
      Tau: Tau$1,
      Tcaron,
      Tcedil,
      Tcy,
      Tfr,
      Therefore,
      Theta: Theta$1,
      ThickSpace,
      ThinSpace,
      Tilde,
      TildeEqual,
      TildeFullEqual,
      TildeTilde,
      Topf,
      TripleDot,
      Tscr,
      Tstrok,
      Uacut,
      Uacute: Uacute$1,
      Uarr,
      Uarrocir,
      Ubrcy,
      Ubreve,
      Ucir,
      Ucirc: Ucirc$1,
      Ucy,
      Udblac,
      Ufr,
      Ugrav,
      Ugrave: Ugrave$1,
      Umacr,
      UnderBar,
      UnderBrace,
      UnderBracket,
      UnderParenthesis,
      Union,
      UnionPlus,
      Uogon,
      Uopf,
      UpArrow,
      UpArrowBar,
      UpArrowDownArrow,
      UpDownArrow,
      UpEquilibrium,
      UpTee,
      UpTeeArrow,
      Uparrow,
      Updownarrow,
      UpperLeftArrow,
      UpperRightArrow,
      Upsi,
      Upsilon: Upsilon$1,
      Uring,
      Uscr,
      Utilde,
      Uum,
      Uuml: Uuml$1,
      VDash,
      Vbar,
      Vcy,
      Vdash,
      Vdashl,
      Vee,
      Verbar,
      Vert,
      VerticalBar,
      VerticalLine,
      VerticalSeparator,
      VerticalTilde,
      VeryThinSpace,
      Vfr,
      Vopf,
      Vscr,
      Vvdash,
      Wcirc,
      Wedge,
      Wfr,
      Wopf,
      Wscr,
      Xfr,
      Xi: Xi$1,
      Xopf,
      Xscr,
      YAcy,
      YIcy,
      YUcy,
      Yacut,
      Yacute: Yacute$1,
      Ycirc,
      Ycy,
      Yfr,
      Yopf,
      Yscr,
      Yuml: Yuml$1,
      ZHcy,
      Zacute,
      Zcaron,
      Zcy,
      Zdot,
      ZeroWidthSpace,
      Zeta: Zeta$1,
      Zfr,
      Zopf,
      Zscr,
      aacut,
      aacute: aacute$1,
      abreve,
      ac,
      acE,
      acd,
      acir,
      acirc: acirc$1,
      acut,
      acute: acute$1,
      acy,
      aeli,
      aelig: aelig$1,
      af,
      afr,
      agrav,
      agrave: agrave$1,
      alefsym: alefsym$1,
      aleph,
      alpha: alpha$1,
      amacr,
      amalg,
      am,
      amp: amp$1,
      and: and$1,
      andand,
      andd,
      andslope,
      andv,
      ang: ang$1,
      ange,
      angle,
      angmsd,
      angmsdaa,
      angmsdab,
      angmsdac,
      angmsdad,
      angmsdae,
      angmsdaf,
      angmsdag,
      angmsdah,
      angrt,
      angrtvb,
      angrtvbd,
      angsph,
      angst,
      angzarr,
      aogon,
      aopf,
      ap,
      apE,
      apacir,
      ape,
      apid,
      apos,
      approx,
      approxeq,
      arin,
      aring: aring$1,
      ascr,
      ast,
      asymp: asymp$1,
      asympeq,
      atild,
      atilde: atilde$1,
      aum,
      auml: auml$1,
      awconint,
      awint,
      bNot,
      backcong,
      backepsilon,
      backprime,
      backsim,
      backsimeq,
      barvee,
      barwed,
      barwedge,
      bbrk,
      bbrktbrk,
      bcong,
      bcy,
      bdquo: bdquo$1,
      becaus,
      because,
      bemptyv,
      bepsi,
      bernou,
      beta: beta$1,
      beth,
      between,
      bfr,
      bigcap,
      bigcirc,
      bigcup,
      bigodot,
      bigoplus,
      bigotimes,
      bigsqcup,
      bigstar,
      bigtriangledown,
      bigtriangleup,
      biguplus,
      bigvee,
      bigwedge,
      bkarow,
      blacklozenge,
      blacksquare,
      blacktriangle,
      blacktriangledown,
      blacktriangleleft,
      blacktriangleright,
      blank,
      blk12,
      blk14,
      blk34,
      block,
      bne,
      bnequiv,
      bnot,
      bopf,
      bot,
      bottom,
      bowtie,
      boxDL,
      boxDR,
      boxDl,
      boxDr,
      boxH,
      boxHD,
      boxHU,
      boxHd,
      boxHu,
      boxUL,
      boxUR,
      boxUl,
      boxUr,
      boxV,
      boxVH,
      boxVL,
      boxVR,
      boxVh,
      boxVl,
      boxVr,
      boxbox,
      boxdL,
      boxdR,
      boxdl,
      boxdr,
      boxh,
      boxhD,
      boxhU,
      boxhd,
      boxhu,
      boxminus,
      boxplus,
      boxtimes,
      boxuL,
      boxuR,
      boxul,
      boxur,
      boxv,
      boxvH,
      boxvL,
      boxvR,
      boxvh,
      boxvl,
      boxvr,
      bprime,
      breve,
      brvba,
      brvbar: brvbar$1,
      bscr,
      bsemi,
      bsim,
      bsime,
      bsol,
      bsolb,
      bsolhsub,
      bull: bull$1,
      bullet,
      bump,
      bumpE,
      bumpe,
      bumpeq,
      cacute,
      cap: cap$2,
      capand,
      capbrcup,
      capcap,
      capcup,
      capdot,
      caps,
      caret,
      caron,
      ccaps,
      ccaron,
      ccedi,
      ccedil: ccedil$1,
      ccirc,
      ccups,
      ccupssm,
      cdot,
      cedi,
      cedil: cedil$1,
      cemptyv,
      cen,
      cent: cent$1,
      centerdot,
      cfr,
      chcy,
      check,
      checkmark,
      chi: chi$1,
      cir,
      cirE,
      circ: circ$1,
      circeq,
      circlearrowleft,
      circlearrowright,
      circledR,
      circledS,
      circledast,
      circledcirc,
      circleddash,
      cire,
      cirfnint,
      cirmid,
      cirscir,
      clubs: clubs$1,
      clubsuit,
      colon: colon$3,
      colone,
      coloneq,
      comma: comma$2,
      commat,
      comp,
      compfn,
      complement,
      complexes,
      cong: cong$1,
      congdot,
      conint,
      copf,
      coprod,
      cop,
      copy: copy$1,
      copysr,
      crarr: crarr$1,
      cross,
      cscr,
      csub,
      csube,
      csup,
      csupe,
      ctdot,
      cudarrl,
      cudarrr,
      cuepr,
      cuesc,
      cularr,
      cularrp,
      cup: cup$1,
      cupbrcap,
      cupcap,
      cupcup,
      cupdot,
      cupor,
      cups,
      curarr,
      curarrm,
      curlyeqprec,
      curlyeqsucc,
      curlyvee,
      curlywedge,
      curre,
      curren: curren$1,
      curvearrowleft,
      curvearrowright,
      cuvee,
      cuwed,
      cwconint,
      cwint,
      cylcty,
      dArr: dArr$1,
      dHar,
      dagger: dagger$1,
      daleth,
      darr: darr$1,
      dash: dash$8,
      dashv,
      dbkarow,
      dblac,
      dcaron,
      dcy,
      dd: dd$1,
      ddagger,
      ddarr,
      ddotseq,
      de,
      deg: deg$1,
      delta: delta$1,
      demptyv,
      dfisht,
      dfr,
      dharl,
      dharr,
      diam,
      diamond,
      diamondsuit,
      diams: diams$1,
      die,
      digamma,
      disin,
      div,
      divid,
      divide: divide$1,
      divideontimes,
      divonx,
      djcy,
      dlcorn,
      dlcrop,
      dollar,
      dopf,
      dot: dot$4,
      doteq,
      doteqdot,
      dotminus,
      dotplus,
      dotsquare,
      doublebarwedge,
      downarrow,
      downdownarrows,
      downharpoonleft,
      downharpoonright,
      drbkarow,
      drcorn,
      drcrop,
      dscr,
      dscy,
      dsol,
      dstrok,
      dtdot,
      dtri,
      dtrif,
      duarr,
      duhar,
      dwangle,
      dzcy,
      dzigrarr,
      eDDot,
      eDot,
      eacut,
      eacute: eacute$1,
      easter,
      ecaron,
      ecir,
      ecirc: ecirc$1,
      ecolon,
      ecy,
      edot,
      ee,
      efDot,
      efr,
      eg,
      egrav,
      egrave: egrave$1,
      egs,
      egsdot,
      el,
      elinters,
      ell,
      els,
      elsdot,
      emacr,
      empty: empty$3,
      emptyset,
      emptyv,
      emsp13,
      emsp14,
      emsp: emsp$1,
      eng,
      ensp: ensp$1,
      eogon,
      eopf,
      epar,
      eparsl,
      eplus,
      epsi,
      epsilon: epsilon$1,
      epsiv,
      eqcirc,
      eqcolon,
      eqsim,
      eqslantgtr,
      eqslantless,
      equals,
      equest,
      equiv: equiv$1,
      equivDD,
      eqvparsl,
      erDot,
      erarr,
      escr,
      esdot,
      esim,
      eta: eta$1,
      et,
      eth: eth$1,
      eum,
      euml: euml$1,
      euro: euro$1,
      excl,
      exist: exist$1,
      expectation,
      exponentiale,
      fallingdotseq,
      fcy,
      female,
      ffilig,
      fflig,
      ffllig,
      ffr,
      filig,
      fjlig,
      flat,
      fllig,
      fltns,
      fnof: fnof$1,
      fopf,
      forall: forall$1,
      fork,
      forkv,
      fpartint,
      frac1,
      frac12: frac12$1,
      frac13,
      frac14: frac14$1,
      frac15,
      frac16,
      frac18,
      frac23,
      frac25,
      frac3,
      frac34: frac34$1,
      frac35,
      frac38,
      frac45,
      frac56,
      frac58,
      frac78,
      frasl: frasl$1,
      frown,
      fscr,
      gE,
      gEl,
      gacute,
      gamma: gamma$1,
      gammad,
      gap,
      gbreve,
      gcirc,
      gcy,
      gdot,
      ge: ge$1,
      gel,
      geq,
      geqq,
      geqslant,
      ges,
      gescc,
      gesdot,
      gesdoto,
      gesdotol,
      gesl,
      gesles,
      gfr,
      gg,
      ggg,
      gimel,
      gjcy,
      gl,
      glE,
      gla,
      glj,
      gnE,
      gnap,
      gnapprox,
      gne,
      gneq,
      gneqq,
      gnsim,
      gopf,
      grave,
      gscr,
      gsim,
      gsime,
      gsiml,
      g,
      gt: gt$1,
      gtcc,
      gtcir,
      gtdot,
      gtlPar,
      gtquest,
      gtrapprox,
      gtrarr,
      gtrdot,
      gtreqless,
      gtreqqless,
      gtrless,
      gtrsim,
      gvertneqq,
      gvnE,
      hArr: hArr$1,
      hairsp,
      half,
      hamilt,
      hardcy,
      harr: harr$1,
      harrcir,
      harrw,
      hbar,
      hcirc,
      hearts: hearts$1,
      heartsuit,
      hellip: hellip$1,
      hercon,
      hfr,
      hksearow,
      hkswarow,
      hoarr,
      homtht,
      hookleftarrow,
      hookrightarrow,
      hopf,
      horbar,
      hscr,
      hslash,
      hstrok,
      hybull,
      hyphen,
      iacut,
      iacute: iacute$1,
      ic,
      icir,
      icirc: icirc$1,
      icy,
      iecy,
      iexc,
      iexcl: iexcl$1,
      iff,
      ifr,
      igrav,
      igrave: igrave$1,
      ii,
      iiiint,
      iiint,
      iinfin,
      iiota,
      ijlig,
      imacr,
      image: image$3,
      imagline,
      imagpart,
      imath,
      imof,
      imped,
      "in": "\u2208",
      incare,
      infin: infin$1,
      infintie,
      inodot,
      int: int$1,
      intcal,
      integers,
      intercal,
      intlarhk,
      intprod,
      iocy,
      iogon,
      iopf,
      iota: iota$1,
      iprod,
      iques,
      iquest: iquest$1,
      iscr,
      isin: isin$1,
      isinE,
      isindot,
      isins,
      isinsv,
      isinv,
      it,
      itilde,
      iukcy,
      ium,
      iuml: iuml$1,
      jcirc,
      jcy,
      jfr,
      jmath,
      jopf,
      jscr,
      jsercy,
      jukcy,
      kappa: kappa$1,
      kappav,
      kcedil,
      kcy,
      kfr,
      kgreen,
      khcy,
      kjcy,
      kopf,
      kscr,
      lAarr,
      lArr: lArr$1,
      lAtail,
      lBarr,
      lE,
      lEg,
      lHar,
      lacute,
      laemptyv,
      lagran,
      lambda: lambda$1,
      lang: lang$1,
      langd,
      langle,
      lap,
      laqu,
      laquo: laquo$1,
      larr: larr$1,
      larrb,
      larrbfs,
      larrfs,
      larrhk,
      larrlp,
      larrpl,
      larrsim,
      larrtl,
      lat,
      latail,
      late,
      lates,
      lbarr,
      lbbrk,
      lbrace,
      lbrack,
      lbrke,
      lbrksld,
      lbrkslu,
      lcaron,
      lcedil,
      lceil: lceil$1,
      lcub,
      lcy,
      ldca,
      ldquo: ldquo$1,
      ldquor,
      ldrdhar,
      ldrushar,
      ldsh,
      le: le$1,
      leftarrow,
      leftarrowtail,
      leftharpoondown,
      leftharpoonup,
      leftleftarrows,
      leftrightarrow,
      leftrightarrows,
      leftrightharpoons,
      leftrightsquigarrow,
      leftthreetimes,
      leg,
      leq,
      leqq,
      leqslant,
      les,
      lescc,
      lesdot,
      lesdoto,
      lesdotor,
      lesg,
      lesges,
      lessapprox,
      lessdot,
      lesseqgtr,
      lesseqqgtr,
      lessgtr,
      lesssim,
      lfisht,
      lfloor: lfloor$1,
      lfr,
      lg,
      lgE,
      lhard,
      lharu,
      lharul,
      lhblk,
      ljcy,
      ll,
      llarr,
      llcorner,
      llhard,
      lltri,
      lmidot,
      lmoust,
      lmoustache,
      lnE,
      lnap,
      lnapprox,
      lne,
      lneq,
      lneqq,
      lnsim,
      loang,
      loarr,
      lobrk,
      longleftarrow,
      longleftrightarrow,
      longmapsto,
      longrightarrow,
      looparrowleft,
      looparrowright,
      lopar,
      lopf,
      loplus,
      lotimes,
      lowast: lowast$1,
      lowbar,
      loz: loz$1,
      lozenge,
      lozf,
      lpar,
      lparlt,
      lrarr,
      lrcorner,
      lrhar,
      lrhard,
      lrm: lrm$1,
      lrtri,
      lsaquo: lsaquo$1,
      lscr,
      lsh,
      lsim,
      lsime,
      lsimg,
      lsqb,
      lsquo: lsquo$1,
      lsquor,
      lstrok,
      l,
      lt: lt$1,
      ltcc,
      ltcir,
      ltdot,
      lthree,
      ltimes,
      ltlarr,
      ltquest,
      ltrPar,
      ltri,
      ltrie,
      ltrif,
      lurdshar,
      luruhar,
      lvertneqq,
      lvnE,
      mDDot,
      mac,
      macr: macr$1,
      male,
      malt,
      maltese,
      map: map$1,
      mapsto,
      mapstodown,
      mapstoleft,
      mapstoup,
      marker,
      mcomma,
      mcy,
      mdash: mdash$1,
      measuredangle,
      mfr,
      mho,
      micr,
      micro: micro$1,
      mid,
      midast,
      midcir,
      middo,
      middot: middot$1,
      minus: minus$1,
      minusb,
      minusd,
      minusdu,
      mlcp,
      mldr,
      mnplus,
      models,
      mopf,
      mp,
      mscr,
      mstpos,
      mu: mu$1,
      multimap,
      mumap,
      nGg,
      nGt,
      nGtv,
      nLeftarrow,
      nLeftrightarrow,
      nLl,
      nLt,
      nLtv,
      nRightarrow,
      nVDash,
      nVdash,
      nabla: nabla$1,
      nacute,
      nang,
      nap,
      napE,
      napid,
      napos,
      napprox,
      natur,
      natural,
      naturals,
      nbs,
      nbsp: nbsp$1,
      nbump,
      nbumpe,
      ncap,
      ncaron,
      ncedil,
      ncong,
      ncongdot,
      ncup,
      ncy,
      ndash: ndash$1,
      ne: ne$1,
      neArr,
      nearhk,
      nearr,
      nearrow,
      nedot,
      nequiv,
      nesear,
      nesim,
      nexist,
      nexists,
      nfr,
      ngE,
      nge,
      ngeq,
      ngeqq,
      ngeqslant,
      nges,
      ngsim,
      ngt,
      ngtr,
      nhArr,
      nharr,
      nhpar,
      ni: ni$1,
      nis,
      nisd,
      niv,
      njcy,
      nlArr,
      nlE,
      nlarr,
      nldr,
      nle,
      nleftarrow,
      nleftrightarrow,
      nleq,
      nleqq,
      nleqslant,
      nles,
      nless,
      nlsim,
      nlt,
      nltri,
      nltrie,
      nmid,
      nopf,
      no,
      not: not$1,
      notin: notin$1,
      notinE,
      notindot,
      notinva,
      notinvb,
      notinvc,
      notni,
      notniva,
      notnivb,
      notnivc,
      npar,
      nparallel,
      nparsl,
      npart,
      npolint,
      npr,
      nprcue,
      npre,
      nprec,
      npreceq,
      nrArr,
      nrarr,
      nrarrc,
      nrarrw,
      nrightarrow,
      nrtri,
      nrtrie,
      nsc,
      nsccue,
      nsce,
      nscr,
      nshortmid,
      nshortparallel,
      nsim,
      nsime,
      nsimeq,
      nsmid,
      nspar,
      nsqsube,
      nsqsupe,
      nsub: nsub$1,
      nsubE,
      nsube,
      nsubset,
      nsubseteq,
      nsubseteqq,
      nsucc,
      nsucceq,
      nsup,
      nsupE,
      nsupe,
      nsupset,
      nsupseteq,
      nsupseteqq,
      ntgl,
      ntild,
      ntilde: ntilde$1,
      ntlg,
      ntriangleleft,
      ntrianglelefteq,
      ntriangleright,
      ntrianglerighteq,
      nu: nu$1,
      num,
      numero,
      numsp,
      nvDash,
      nvHarr,
      nvap,
      nvdash,
      nvge,
      nvgt,
      nvinfin,
      nvlArr,
      nvle,
      nvlt,
      nvltrie,
      nvrArr,
      nvrtrie,
      nvsim,
      nwArr,
      nwarhk,
      nwarr,
      nwarrow,
      nwnear,
      oS,
      oacut,
      oacute: oacute$1,
      oast,
      ocir,
      ocirc: ocirc$1,
      ocy,
      odash,
      odblac,
      odiv,
      odot,
      odsold,
      oelig: oelig$1,
      ofcir,
      ofr,
      ogon,
      ograv,
      ograve: ograve$1,
      ogt,
      ohbar,
      ohm,
      oint,
      olarr,
      olcir,
      olcross,
      oline: oline$1,
      olt,
      omacr,
      omega: omega$1,
      omicron: omicron$1,
      omid,
      ominus,
      oopf,
      opar,
      operp,
      oplus: oplus$1,
      or: or$1,
      orarr,
      ord,
      order,
      orderof,
      ordf: ordf$1,
      ordm: ordm$1,
      origof,
      oror,
      orslope,
      orv,
      oscr,
      oslas,
      oslash: oslash$1,
      osol,
      otild,
      otilde: otilde$1,
      otimes: otimes$1,
      otimesas,
      oum,
      ouml: ouml$1,
      ovbar,
      par,
      para: para$1,
      parallel,
      parsim,
      parsl,
      part: part$1,
      pcy,
      percnt,
      period,
      permil: permil$1,
      perp: perp$1,
      pertenk,
      pfr,
      phi: phi$1,
      phiv,
      phmmat,
      phone,
      pi: pi$1,
      pitchfork,
      piv: piv$1,
      planck,
      planckh,
      plankv,
      plus,
      plusacir,
      plusb,
      pluscir,
      plusdo,
      plusdu,
      pluse,
      plusm,
      plusmn: plusmn$1,
      plussim,
      plustwo,
      pm,
      pointint,
      popf,
      poun,
      pound: pound$1,
      pr,
      prE,
      prap,
      prcue,
      pre,
      prec,
      precapprox,
      preccurlyeq,
      preceq,
      precnapprox,
      precneqq,
      precnsim,
      precsim,
      prime: prime$1,
      primes,
      prnE,
      prnap,
      prnsim,
      prod: prod$1,
      profalar,
      profline,
      profsurf,
      prop: prop$1,
      propto,
      prsim,
      prurel,
      pscr,
      psi: psi$1,
      puncsp,
      qfr,
      qint,
      qopf,
      qprime,
      qscr,
      quaternions,
      quatint,
      quest,
      questeq,
      quo,
      quot: quot$1,
      rAarr,
      rArr: rArr$1,
      rAtail,
      rBarr,
      rHar,
      race,
      racute,
      radic: radic$1,
      raemptyv,
      rang: rang$1,
      rangd,
      range,
      rangle,
      raqu,
      raquo: raquo$1,
      rarr: rarr$1,
      rarrap,
      rarrb,
      rarrbfs,
      rarrc,
      rarrfs,
      rarrhk,
      rarrlp,
      rarrpl,
      rarrsim,
      rarrtl,
      rarrw,
      ratail,
      ratio,
      rationals,
      rbarr,
      rbbrk,
      rbrace,
      rbrack,
      rbrke,
      rbrksld,
      rbrkslu,
      rcaron,
      rcedil,
      rceil: rceil$1,
      rcub,
      rcy,
      rdca,
      rdldhar,
      rdquo: rdquo$1,
      rdquor,
      rdsh,
      real: real$1,
      realine,
      realpart,
      reals,
      rect,
      re: re$3,
      reg: reg$1,
      rfisht,
      rfloor: rfloor$1,
      rfr,
      rhard,
      rharu,
      rharul,
      rho: rho$1,
      rhov,
      rightarrow,
      rightarrowtail,
      rightharpoondown,
      rightharpoonup,
      rightleftarrows,
      rightleftharpoons,
      rightrightarrows,
      rightsquigarrow,
      rightthreetimes,
      ring,
      risingdotseq,
      rlarr,
      rlhar,
      rlm: rlm$1,
      rmoust,
      rmoustache,
      rnmid,
      roang,
      roarr,
      robrk,
      ropar,
      ropf,
      roplus,
      rotimes,
      rpar,
      rpargt,
      rppolint,
      rrarr,
      rsaquo: rsaquo$1,
      rscr,
      rsh,
      rsqb,
      rsquo: rsquo$1,
      rsquor,
      rthree,
      rtimes,
      rtri,
      rtrie,
      rtrif,
      rtriltri,
      ruluhar,
      rx,
      sacute,
      sbquo: sbquo$1,
      sc,
      scE,
      scap,
      scaron: scaron$1,
      sccue,
      sce,
      scedil,
      scirc,
      scnE,
      scnap,
      scnsim,
      scpolint,
      scsim,
      scy,
      sdot: sdot$1,
      sdotb,
      sdote,
      seArr,
      searhk,
      searr,
      searrow,
      sec,
      sect: sect$1,
      semi,
      seswar,
      setminus,
      setmn,
      sext,
      sfr,
      sfrown,
      sharp,
      shchcy,
      shcy,
      shortmid,
      shortparallel,
      sh,
      shy: shy$1,
      sigma: sigma$1,
      sigmaf: sigmaf$1,
      sigmav,
      sim: sim$1,
      simdot,
      sime,
      simeq,
      simg,
      simgE,
      siml,
      simlE,
      simne,
      simplus,
      simrarr,
      slarr,
      smallsetminus,
      smashp,
      smeparsl,
      smid,
      smile,
      smt,
      smte,
      smtes,
      softcy,
      sol,
      solb,
      solbar,
      sopf,
      spades: spades$1,
      spadesuit,
      spar,
      sqcap,
      sqcaps,
      sqcup,
      sqcups,
      sqsub,
      sqsube,
      sqsubset,
      sqsubseteq,
      sqsup,
      sqsupe,
      sqsupset,
      sqsupseteq,
      squ,
      square,
      squarf,
      squf,
      srarr,
      sscr,
      ssetmn,
      ssmile,
      sstarf,
      star,
      starf,
      straightepsilon,
      straightphi,
      strns,
      sub: sub$1,
      subE,
      subdot,
      sube: sube$1,
      subedot,
      submult,
      subnE,
      subne,
      subplus,
      subrarr,
      subset,
      subseteq,
      subseteqq,
      subsetneq,
      subsetneqq,
      subsim,
      subsub,
      subsup,
      succ,
      succapprox,
      succcurlyeq,
      succeq,
      succnapprox,
      succneqq,
      succnsim,
      succsim,
      sum: sum$1,
      sung,
      sup: sup$1,
      sup1: sup1$1,
      sup2: sup2$1,
      sup3: sup3$1,
      supE,
      supdot,
      supdsub,
      supe: supe$1,
      supedot,
      suphsol,
      suphsub,
      suplarr,
      supmult,
      supnE,
      supne,
      supplus,
      supset,
      supseteq,
      supseteqq,
      supsetneq,
      supsetneqq,
      supsim,
      supsub,
      supsup,
      swArr,
      swarhk,
      swarr,
      swarrow,
      swnwar,
      szli,
      szlig: szlig$1,
      target,
      tau: tau$1,
      tbrk,
      tcaron,
      tcedil,
      tcy,
      tdot,
      telrec,
      tfr,
      there4: there4$1,
      therefore,
      theta: theta$1,
      thetasym: thetasym$1,
      thetav,
      thickapprox,
      thicksim,
      thinsp: thinsp$1,
      thkap,
      thksim,
      thor,
      thorn: thorn$1,
      tilde: tilde$4,
      time,
      times: times$1,
      timesb,
      timesbar,
      timesd,
      tint,
      toea,
      top,
      topbot,
      topcir,
      topf,
      topfork,
      tosa,
      tprime,
      trade: trade$1,
      triangle,
      triangledown,
      triangleleft,
      trianglelefteq,
      triangleq,
      triangleright,
      trianglerighteq,
      tridot,
      trie,
      triminus,
      triplus,
      trisb,
      tritime,
      trpezium,
      tscr,
      tscy,
      tshcy,
      tstrok,
      twixt,
      twoheadleftarrow,
      twoheadrightarrow,
      uArr: uArr$1,
      uHar,
      uacut,
      uacute: uacute$1,
      uarr: uarr$1,
      ubrcy,
      ubreve,
      ucir,
      ucirc: ucirc$1,
      ucy,
      udarr,
      udblac,
      udhar,
      ufisht,
      ufr,
      ugrav,
      ugrave: ugrave$1,
      uharl,
      uharr,
      uhblk,
      ulcorn,
      ulcorner,
      ulcrop,
      ultri,
      umacr,
      um,
      uml: uml$1,
      uogon,
      uopf,
      uparrow,
      updownarrow,
      upharpoonleft,
      upharpoonright,
      uplus,
      upsi,
      upsih: upsih$1,
      upsilon: upsilon$1,
      upuparrows,
      urcorn,
      urcorner,
      urcrop,
      uring,
      urtri,
      uscr,
      utdot,
      utilde,
      utri,
      utrif,
      uuarr,
      uum,
      uuml: uuml$1,
      uwangle,
      vArr,
      vBar,
      vBarv,
      vDash,
      vangrt,
      varepsilon,
      varkappa,
      varnothing,
      varphi,
      varpi,
      varpropto,
      varr,
      varrho,
      varsigma,
      varsubsetneq,
      varsubsetneqq,
      varsupsetneq,
      varsupsetneqq,
      vartheta,
      vartriangleleft,
      vartriangleright,
      vcy,
      vdash,
      vee,
      veebar,
      veeeq,
      vellip,
      verbar,
      vert,
      vfr,
      vltri,
      vnsub,
      vnsup,
      vopf,
      vprop,
      vrtri,
      vscr,
      vsubnE,
      vsubne,
      vsupnE,
      vsupne,
      vzigzag,
      wcirc,
      wedbar,
      wedge,
      wedgeq,
      weierp: weierp$1,
      wfr,
      wopf,
      wp,
      wr,
      wreath,
      wscr,
      xcap,
      xcirc,
      xcup,
      xdtri,
      xfr,
      xhArr,
      xharr,
      xi: xi$1,
      xlArr,
      xlarr,
      xmap,
      xnis,
      xodot,
      xopf,
      xoplus,
      xotime,
      xrArr,
      xrarr,
      xscr,
      xsqcup,
      xuplus,
      xutri,
      xvee,
      xwedge,
      yacut,
      yacute: yacute$1,
      yacy,
      ycirc,
      ycy,
      ye,
      yen: yen$1,
      yfr,
      yicy,
      yopf,
      yscr,
      yucy,
      yum,
      yuml: yuml$1,
      zacute,
      zcaron,
      zcy,
      zdot,
      zeetrf,
      zeta: zeta$1,
      zfr,
      zhcy,
      zigrarr,
      zopf,
      zscr,
      zwj: zwj$1,
      zwnj: zwnj$1
    };
    var characterEntities$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      AEli,
      AElig: AElig$1,
      AM,
      AMP: AMP$1,
      Aacut,
      Aacute: Aacute$1,
      Abreve,
      Acir,
      Acirc: Acirc$1,
      Acy,
      Afr,
      Agrav,
      Agrave: Agrave$1,
      Alpha: Alpha$1,
      Amacr,
      And,
      Aogon,
      Aopf,
      ApplyFunction,
      Arin,
      Aring: Aring$1,
      Ascr,
      Assign,
      Atild,
      Atilde: Atilde$1,
      Aum,
      Auml: Auml$1,
      Backslash,
      Barv,
      Barwed,
      Bcy,
      Because,
      Bernoullis,
      Beta: Beta$1,
      Bfr,
      Bopf,
      Breve,
      Bscr,
      Bumpeq,
      CHcy,
      COP,
      COPY,
      Cacute,
      Cap,
      CapitalDifferentialD,
      Cayleys,
      Ccaron,
      Ccedi,
      Ccedil: Ccedil$1,
      Ccirc,
      Cconint,
      Cdot,
      Cedilla,
      CenterDot,
      Cfr,
      Chi: Chi$1,
      CircleDot,
      CircleMinus,
      CirclePlus,
      CircleTimes,
      ClockwiseContourIntegral,
      CloseCurlyDoubleQuote,
      CloseCurlyQuote,
      Colon,
      Colone,
      Congruent,
      Conint,
      ContourIntegral,
      Copf,
      Coproduct,
      CounterClockwiseContourIntegral,
      Cross,
      Cscr,
      Cup,
      CupCap,
      DD,
      DDotrahd,
      DJcy,
      DScy,
      DZcy,
      Dagger: Dagger$1,
      Darr,
      Dashv,
      Dcaron,
      Dcy,
      Del,
      Delta: Delta$1,
      Dfr,
      DiacriticalAcute,
      DiacriticalDot,
      DiacriticalDoubleAcute,
      DiacriticalGrave,
      DiacriticalTilde,
      Diamond,
      DifferentialD,
      Dopf,
      Dot,
      DotDot,
      DotEqual,
      DoubleContourIntegral,
      DoubleDot,
      DoubleDownArrow,
      DoubleLeftArrow,
      DoubleLeftRightArrow,
      DoubleLeftTee,
      DoubleLongLeftArrow,
      DoubleLongLeftRightArrow,
      DoubleLongRightArrow,
      DoubleRightArrow,
      DoubleRightTee,
      DoubleUpArrow,
      DoubleUpDownArrow,
      DoubleVerticalBar,
      DownArrow,
      DownArrowBar,
      DownArrowUpArrow,
      DownBreve,
      DownLeftRightVector,
      DownLeftTeeVector,
      DownLeftVector,
      DownLeftVectorBar,
      DownRightTeeVector,
      DownRightVector,
      DownRightVectorBar,
      DownTee,
      DownTeeArrow,
      Downarrow,
      Dscr,
      Dstrok,
      ENG,
      ET,
      ETH: ETH$1,
      Eacut,
      Eacute: Eacute$1,
      Ecaron,
      Ecir,
      Ecirc: Ecirc$1,
      Ecy,
      Edot,
      Efr,
      Egrav,
      Egrave: Egrave$1,
      Element: Element2,
      Emacr,
      EmptySmallSquare,
      EmptyVerySmallSquare,
      Eogon,
      Eopf,
      Epsilon: Epsilon$1,
      Equal,
      EqualTilde,
      Equilibrium,
      Escr,
      Esim,
      Eta: Eta$1,
      Eum,
      Euml: Euml$1,
      Exists,
      ExponentialE,
      Fcy,
      Ffr,
      FilledSmallSquare,
      FilledVerySmallSquare,
      Fopf,
      ForAll,
      Fouriertrf,
      Fscr,
      GJcy,
      G,
      GT: GT$1,
      Gamma: Gamma$1,
      Gammad,
      Gbreve,
      Gcedil,
      Gcirc,
      Gcy,
      Gdot,
      Gfr,
      Gg,
      Gopf,
      GreaterEqual,
      GreaterEqualLess,
      GreaterFullEqual,
      GreaterGreater,
      GreaterLess,
      GreaterSlantEqual,
      GreaterTilde,
      Gscr,
      Gt,
      HARDcy,
      Hacek,
      Hat,
      Hcirc,
      Hfr,
      HilbertSpace,
      Hopf,
      HorizontalLine,
      Hscr,
      Hstrok,
      HumpDownHump,
      HumpEqual,
      IEcy,
      IJlig,
      IOcy,
      Iacut,
      Iacute: Iacute$1,
      Icir,
      Icirc: Icirc$1,
      Icy,
      Idot,
      Ifr,
      Igrav,
      Igrave: Igrave$1,
      Im,
      Imacr,
      ImaginaryI,
      Implies,
      Int,
      Integral,
      Intersection,
      InvisibleComma,
      InvisibleTimes,
      Iogon,
      Iopf,
      Iota: Iota$1,
      Iscr,
      Itilde,
      Iukcy,
      Ium,
      Iuml: Iuml$1,
      Jcirc,
      Jcy,
      Jfr,
      Jopf,
      Jscr,
      Jsercy,
      Jukcy,
      KHcy,
      KJcy,
      Kappa: Kappa$1,
      Kcedil,
      Kcy,
      Kfr,
      Kopf,
      Kscr,
      LJcy,
      L,
      LT: LT$1,
      Lacute,
      Lambda: Lambda$1,
      Lang,
      Laplacetrf,
      Larr,
      Lcaron,
      Lcedil,
      Lcy,
      LeftAngleBracket,
      LeftArrow,
      LeftArrowBar,
      LeftArrowRightArrow,
      LeftCeiling,
      LeftDoubleBracket,
      LeftDownTeeVector,
      LeftDownVector,
      LeftDownVectorBar,
      LeftFloor,
      LeftRightArrow,
      LeftRightVector,
      LeftTee,
      LeftTeeArrow,
      LeftTeeVector,
      LeftTriangle,
      LeftTriangleBar,
      LeftTriangleEqual,
      LeftUpDownVector,
      LeftUpTeeVector,
      LeftUpVector,
      LeftUpVectorBar,
      LeftVector,
      LeftVectorBar,
      Leftarrow,
      Leftrightarrow,
      LessEqualGreater,
      LessFullEqual,
      LessGreater,
      LessLess,
      LessSlantEqual,
      LessTilde,
      Lfr,
      Ll,
      Lleftarrow,
      Lmidot,
      LongLeftArrow,
      LongLeftRightArrow,
      LongRightArrow,
      Longleftarrow,
      Longleftrightarrow,
      Longrightarrow,
      Lopf,
      LowerLeftArrow,
      LowerRightArrow,
      Lscr,
      Lsh,
      Lstrok,
      Lt,
      Mcy,
      MediumSpace,
      Mellintrf,
      Mfr,
      MinusPlus,
      Mopf,
      Mscr,
      Mu: Mu$1,
      NJcy,
      Nacute,
      Ncaron,
      Ncedil,
      Ncy,
      NegativeMediumSpace,
      NegativeThickSpace,
      NegativeThinSpace,
      NegativeVeryThinSpace,
      NestedGreaterGreater,
      NestedLessLess,
      NewLine,
      Nfr,
      NoBreak,
      NonBreakingSpace,
      Nopf,
      Not,
      NotCongruent,
      NotCupCap,
      NotDoubleVerticalBar,
      NotElement,
      NotEqual,
      NotEqualTilde,
      NotExists,
      NotGreater,
      NotGreaterEqual,
      NotGreaterFullEqual,
      NotGreaterGreater,
      NotGreaterLess,
      NotGreaterSlantEqual,
      NotGreaterTilde,
      NotHumpDownHump,
      NotHumpEqual,
      NotLeftTriangle,
      NotLeftTriangleBar,
      NotLeftTriangleEqual,
      NotLess,
      NotLessEqual,
      NotLessGreater,
      NotLessLess,
      NotLessSlantEqual,
      NotLessTilde,
      NotNestedGreaterGreater,
      NotNestedLessLess,
      NotPrecedes,
      NotPrecedesEqual,
      NotPrecedesSlantEqual,
      NotReverseElement,
      NotRightTriangle,
      NotRightTriangleBar,
      NotRightTriangleEqual,
      NotSquareSubset,
      NotSquareSubsetEqual,
      NotSquareSuperset,
      NotSquareSupersetEqual,
      NotSubset,
      NotSubsetEqual,
      NotSucceeds,
      NotSucceedsEqual,
      NotSucceedsSlantEqual,
      NotSucceedsTilde,
      NotSuperset,
      NotSupersetEqual,
      NotTilde,
      NotTildeEqual,
      NotTildeFullEqual,
      NotTildeTilde,
      NotVerticalBar,
      Nscr,
      Ntild,
      Ntilde: Ntilde$1,
      Nu: Nu$1,
      OElig: OElig$1,
      Oacut,
      Oacute: Oacute$1,
      Ocir,
      Ocirc: Ocirc$1,
      Ocy,
      Odblac,
      Ofr,
      Ograv,
      Ograve: Ograve$1,
      Omacr,
      Omega: Omega$1,
      Omicron: Omicron$1,
      Oopf,
      OpenCurlyDoubleQuote,
      OpenCurlyQuote,
      Or,
      Oscr,
      Oslas,
      Oslash: Oslash$1,
      Otild,
      Otilde: Otilde$1,
      Otimes,
      Oum,
      Ouml: Ouml$1,
      OverBar,
      OverBrace,
      OverBracket,
      OverParenthesis,
      PartialD,
      Pcy,
      Pfr,
      Phi: Phi$1,
      Pi: Pi$1,
      PlusMinus,
      Poincareplane,
      Popf,
      Pr,
      Precedes,
      PrecedesEqual,
      PrecedesSlantEqual,
      PrecedesTilde,
      Prime: Prime$1,
      Product,
      Proportion,
      Proportional,
      Pscr,
      Psi: Psi$1,
      QUO,
      QUOT,
      Qfr,
      Qopf,
      Qscr,
      RBarr,
      RE,
      REG,
      Racute,
      Rang,
      Rarr,
      Rarrtl,
      Rcaron,
      Rcedil,
      Rcy,
      Re,
      ReverseElement,
      ReverseEquilibrium,
      ReverseUpEquilibrium,
      Rfr,
      Rho: Rho$1,
      RightAngleBracket,
      RightArrow,
      RightArrowBar,
      RightArrowLeftArrow,
      RightCeiling,
      RightDoubleBracket,
      RightDownTeeVector,
      RightDownVector,
      RightDownVectorBar,
      RightFloor,
      RightTee,
      RightTeeArrow,
      RightTeeVector,
      RightTriangle,
      RightTriangleBar,
      RightTriangleEqual,
      RightUpDownVector,
      RightUpTeeVector,
      RightUpVector,
      RightUpVectorBar,
      RightVector,
      RightVectorBar,
      Rightarrow,
      Ropf,
      RoundImplies,
      Rrightarrow,
      Rscr,
      Rsh,
      RuleDelayed,
      SHCHcy,
      SHcy,
      SOFTcy,
      Sacute,
      Sc,
      Scaron: Scaron$1,
      Scedil,
      Scirc,
      Scy,
      Sfr,
      ShortDownArrow,
      ShortLeftArrow,
      ShortRightArrow,
      ShortUpArrow,
      Sigma: Sigma$1,
      SmallCircle,
      Sopf,
      Sqrt,
      Square,
      SquareIntersection,
      SquareSubset,
      SquareSubsetEqual,
      SquareSuperset,
      SquareSupersetEqual,
      SquareUnion,
      Sscr,
      Star,
      Sub,
      Subset,
      SubsetEqual,
      Succeeds,
      SucceedsEqual,
      SucceedsSlantEqual,
      SucceedsTilde,
      SuchThat,
      Sum,
      Sup,
      Superset,
      SupersetEqual,
      Supset,
      THOR,
      THORN: THORN$1,
      TRADE,
      TSHcy,
      TScy,
      Tab,
      Tau: Tau$1,
      Tcaron,
      Tcedil,
      Tcy,
      Tfr,
      Therefore,
      Theta: Theta$1,
      ThickSpace,
      ThinSpace,
      Tilde,
      TildeEqual,
      TildeFullEqual,
      TildeTilde,
      Topf,
      TripleDot,
      Tscr,
      Tstrok,
      Uacut,
      Uacute: Uacute$1,
      Uarr,
      Uarrocir,
      Ubrcy,
      Ubreve,
      Ucir,
      Ucirc: Ucirc$1,
      Ucy,
      Udblac,
      Ufr,
      Ugrav,
      Ugrave: Ugrave$1,
      Umacr,
      UnderBar,
      UnderBrace,
      UnderBracket,
      UnderParenthesis,
      Union,
      UnionPlus,
      Uogon,
      Uopf,
      UpArrow,
      UpArrowBar,
      UpArrowDownArrow,
      UpDownArrow,
      UpEquilibrium,
      UpTee,
      UpTeeArrow,
      Uparrow,
      Updownarrow,
      UpperLeftArrow,
      UpperRightArrow,
      Upsi,
      Upsilon: Upsilon$1,
      Uring,
      Uscr,
      Utilde,
      Uum,
      Uuml: Uuml$1,
      VDash,
      Vbar,
      Vcy,
      Vdash,
      Vdashl,
      Vee,
      Verbar,
      Vert,
      VerticalBar,
      VerticalLine,
      VerticalSeparator,
      VerticalTilde,
      VeryThinSpace,
      Vfr,
      Vopf,
      Vscr,
      Vvdash,
      Wcirc,
      Wedge,
      Wfr,
      Wopf,
      Wscr,
      Xfr,
      Xi: Xi$1,
      Xopf,
      Xscr,
      YAcy,
      YIcy,
      YUcy,
      Yacut,
      Yacute: Yacute$1,
      Ycirc,
      Ycy,
      Yfr,
      Yopf,
      Yscr,
      Yuml: Yuml$1,
      ZHcy,
      Zacute,
      Zcaron,
      Zcy,
      Zdot,
      ZeroWidthSpace,
      Zeta: Zeta$1,
      Zfr,
      Zopf,
      Zscr,
      aacut,
      aacute: aacute$1,
      abreve,
      ac,
      acE,
      acd,
      acir,
      acirc: acirc$1,
      acut,
      acute: acute$1,
      acy,
      aeli,
      aelig: aelig$1,
      af,
      afr,
      agrav,
      agrave: agrave$1,
      alefsym: alefsym$1,
      aleph,
      alpha: alpha$1,
      amacr,
      amalg,
      am,
      amp: amp$1,
      and: and$1,
      andand,
      andd,
      andslope,
      andv,
      ang: ang$1,
      ange,
      angle,
      angmsd,
      angmsdaa,
      angmsdab,
      angmsdac,
      angmsdad,
      angmsdae,
      angmsdaf,
      angmsdag,
      angmsdah,
      angrt,
      angrtvb,
      angrtvbd,
      angsph,
      angst,
      angzarr,
      aogon,
      aopf,
      ap,
      apE,
      apacir,
      ape,
      apid,
      apos,
      approx,
      approxeq,
      arin,
      aring: aring$1,
      ascr,
      ast,
      asymp: asymp$1,
      asympeq,
      atild,
      atilde: atilde$1,
      aum,
      auml: auml$1,
      awconint,
      awint,
      bNot,
      backcong,
      backepsilon,
      backprime,
      backsim,
      backsimeq,
      barvee,
      barwed,
      barwedge,
      bbrk,
      bbrktbrk,
      bcong,
      bcy,
      bdquo: bdquo$1,
      becaus,
      because,
      bemptyv,
      bepsi,
      bernou,
      beta: beta$1,
      beth,
      between,
      bfr,
      bigcap,
      bigcirc,
      bigcup,
      bigodot,
      bigoplus,
      bigotimes,
      bigsqcup,
      bigstar,
      bigtriangledown,
      bigtriangleup,
      biguplus,
      bigvee,
      bigwedge,
      bkarow,
      blacklozenge,
      blacksquare,
      blacktriangle,
      blacktriangledown,
      blacktriangleleft,
      blacktriangleright,
      blank,
      blk12,
      blk14,
      blk34,
      block,
      bne,
      bnequiv,
      bnot,
      bopf,
      bot,
      bottom,
      bowtie,
      boxDL,
      boxDR,
      boxDl,
      boxDr,
      boxH,
      boxHD,
      boxHU,
      boxHd,
      boxHu,
      boxUL,
      boxUR,
      boxUl,
      boxUr,
      boxV,
      boxVH,
      boxVL,
      boxVR,
      boxVh,
      boxVl,
      boxVr,
      boxbox,
      boxdL,
      boxdR,
      boxdl,
      boxdr,
      boxh,
      boxhD,
      boxhU,
      boxhd,
      boxhu,
      boxminus,
      boxplus,
      boxtimes,
      boxuL,
      boxuR,
      boxul,
      boxur,
      boxv,
      boxvH,
      boxvL,
      boxvR,
      boxvh,
      boxvl,
      boxvr,
      bprime,
      breve,
      brvba,
      brvbar: brvbar$1,
      bscr,
      bsemi,
      bsim,
      bsime,
      bsol,
      bsolb,
      bsolhsub,
      bull: bull$1,
      bullet,
      bump,
      bumpE,
      bumpe,
      bumpeq,
      cacute,
      cap: cap$2,
      capand,
      capbrcup,
      capcap,
      capcup,
      capdot,
      caps,
      caret,
      caron,
      ccaps,
      ccaron,
      ccedi,
      ccedil: ccedil$1,
      ccirc,
      ccups,
      ccupssm,
      cdot,
      cedi,
      cedil: cedil$1,
      cemptyv,
      cen,
      cent: cent$1,
      centerdot,
      cfr,
      chcy,
      check,
      checkmark,
      chi: chi$1,
      cir,
      cirE,
      circ: circ$1,
      circeq,
      circlearrowleft,
      circlearrowright,
      circledR,
      circledS,
      circledast,
      circledcirc,
      circleddash,
      cire,
      cirfnint,
      cirmid,
      cirscir,
      clubs: clubs$1,
      clubsuit,
      colon: colon$3,
      colone,
      coloneq,
      comma: comma$2,
      commat,
      comp,
      compfn,
      complement,
      complexes,
      cong: cong$1,
      congdot,
      conint,
      copf,
      coprod,
      cop,
      copy: copy$1,
      copysr,
      crarr: crarr$1,
      cross,
      cscr,
      csub,
      csube,
      csup,
      csupe,
      ctdot,
      cudarrl,
      cudarrr,
      cuepr,
      cuesc,
      cularr,
      cularrp,
      cup: cup$1,
      cupbrcap,
      cupcap,
      cupcup,
      cupdot,
      cupor,
      cups,
      curarr,
      curarrm,
      curlyeqprec,
      curlyeqsucc,
      curlyvee,
      curlywedge,
      curre,
      curren: curren$1,
      curvearrowleft,
      curvearrowright,
      cuvee,
      cuwed,
      cwconint,
      cwint,
      cylcty,
      dArr: dArr$1,
      dHar,
      dagger: dagger$1,
      daleth,
      darr: darr$1,
      dash: dash$8,
      dashv,
      dbkarow,
      dblac,
      dcaron,
      dcy,
      dd: dd$1,
      ddagger,
      ddarr,
      ddotseq,
      de,
      deg: deg$1,
      delta: delta$1,
      demptyv,
      dfisht,
      dfr,
      dharl,
      dharr,
      diam,
      diamond,
      diamondsuit,
      diams: diams$1,
      die,
      digamma,
      disin,
      div,
      divid,
      divide: divide$1,
      divideontimes,
      divonx,
      djcy,
      dlcorn,
      dlcrop,
      dollar,
      dopf,
      dot: dot$4,
      doteq,
      doteqdot,
      dotminus,
      dotplus,
      dotsquare,
      doublebarwedge,
      downarrow,
      downdownarrows,
      downharpoonleft,
      downharpoonright,
      drbkarow,
      drcorn,
      drcrop,
      dscr,
      dscy,
      dsol,
      dstrok,
      dtdot,
      dtri,
      dtrif,
      duarr,
      duhar,
      dwangle,
      dzcy,
      dzigrarr,
      eDDot,
      eDot,
      eacut,
      eacute: eacute$1,
      easter,
      ecaron,
      ecir,
      ecirc: ecirc$1,
      ecolon,
      ecy,
      edot,
      ee,
      efDot,
      efr,
      eg,
      egrav,
      egrave: egrave$1,
      egs,
      egsdot,
      el,
      elinters,
      ell,
      els,
      elsdot,
      emacr,
      empty: empty$3,
      emptyset,
      emptyv,
      emsp13,
      emsp14,
      emsp: emsp$1,
      eng,
      ensp: ensp$1,
      eogon,
      eopf,
      epar,
      eparsl,
      eplus,
      epsi,
      epsilon: epsilon$1,
      epsiv,
      eqcirc,
      eqcolon,
      eqsim,
      eqslantgtr,
      eqslantless,
      equals,
      equest,
      equiv: equiv$1,
      equivDD,
      eqvparsl,
      erDot,
      erarr,
      escr,
      esdot,
      esim,
      eta: eta$1,
      et,
      eth: eth$1,
      eum,
      euml: euml$1,
      euro: euro$1,
      excl,
      exist: exist$1,
      expectation,
      exponentiale,
      fallingdotseq,
      fcy,
      female,
      ffilig,
      fflig,
      ffllig,
      ffr,
      filig,
      fjlig,
      flat,
      fllig,
      fltns,
      fnof: fnof$1,
      fopf,
      forall: forall$1,
      fork,
      forkv,
      fpartint,
      frac1,
      frac12: frac12$1,
      frac13,
      frac14: frac14$1,
      frac15,
      frac16,
      frac18,
      frac23,
      frac25,
      frac3,
      frac34: frac34$1,
      frac35,
      frac38,
      frac45,
      frac56,
      frac58,
      frac78,
      frasl: frasl$1,
      frown,
      fscr,
      gE,
      gEl,
      gacute,
      gamma: gamma$1,
      gammad,
      gap,
      gbreve,
      gcirc,
      gcy,
      gdot,
      ge: ge$1,
      gel,
      geq,
      geqq,
      geqslant,
      ges,
      gescc,
      gesdot,
      gesdoto,
      gesdotol,
      gesl,
      gesles,
      gfr,
      gg,
      ggg,
      gimel,
      gjcy,
      gl,
      glE,
      gla,
      glj,
      gnE,
      gnap,
      gnapprox,
      gne,
      gneq,
      gneqq,
      gnsim,
      gopf,
      grave,
      gscr,
      gsim,
      gsime,
      gsiml,
      g,
      gt: gt$1,
      gtcc,
      gtcir,
      gtdot,
      gtlPar,
      gtquest,
      gtrapprox,
      gtrarr,
      gtrdot,
      gtreqless,
      gtreqqless,
      gtrless,
      gtrsim,
      gvertneqq,
      gvnE,
      hArr: hArr$1,
      hairsp,
      half,
      hamilt,
      hardcy,
      harr: harr$1,
      harrcir,
      harrw,
      hbar,
      hcirc,
      hearts: hearts$1,
      heartsuit,
      hellip: hellip$1,
      hercon,
      hfr,
      hksearow,
      hkswarow,
      hoarr,
      homtht,
      hookleftarrow,
      hookrightarrow,
      hopf,
      horbar,
      hscr,
      hslash,
      hstrok,
      hybull,
      hyphen,
      iacut,
      iacute: iacute$1,
      ic,
      icir,
      icirc: icirc$1,
      icy,
      iecy,
      iexc,
      iexcl: iexcl$1,
      iff,
      ifr,
      igrav,
      igrave: igrave$1,
      ii,
      iiiint,
      iiint,
      iinfin,
      iiota,
      ijlig,
      imacr,
      image: image$3,
      imagline,
      imagpart,
      imath,
      imof,
      imped,
      incare,
      infin: infin$1,
      infintie,
      inodot,
      int: int$1,
      intcal,
      integers,
      intercal,
      intlarhk,
      intprod,
      iocy,
      iogon,
      iopf,
      iota: iota$1,
      iprod,
      iques,
      iquest: iquest$1,
      iscr,
      isin: isin$1,
      isinE,
      isindot,
      isins,
      isinsv,
      isinv,
      it,
      itilde,
      iukcy,
      ium,
      iuml: iuml$1,
      jcirc,
      jcy,
      jfr,
      jmath,
      jopf,
      jscr,
      jsercy,
      jukcy,
      kappa: kappa$1,
      kappav,
      kcedil,
      kcy,
      kfr,
      kgreen,
      khcy,
      kjcy,
      kopf,
      kscr,
      lAarr,
      lArr: lArr$1,
      lAtail,
      lBarr,
      lE,
      lEg,
      lHar,
      lacute,
      laemptyv,
      lagran,
      lambda: lambda$1,
      lang: lang$1,
      langd,
      langle,
      lap,
      laqu,
      laquo: laquo$1,
      larr: larr$1,
      larrb,
      larrbfs,
      larrfs,
      larrhk,
      larrlp,
      larrpl,
      larrsim,
      larrtl,
      lat,
      latail,
      late,
      lates,
      lbarr,
      lbbrk,
      lbrace,
      lbrack,
      lbrke,
      lbrksld,
      lbrkslu,
      lcaron,
      lcedil,
      lceil: lceil$1,
      lcub,
      lcy,
      ldca,
      ldquo: ldquo$1,
      ldquor,
      ldrdhar,
      ldrushar,
      ldsh,
      le: le$1,
      leftarrow,
      leftarrowtail,
      leftharpoondown,
      leftharpoonup,
      leftleftarrows,
      leftrightarrow,
      leftrightarrows,
      leftrightharpoons,
      leftrightsquigarrow,
      leftthreetimes,
      leg,
      leq,
      leqq,
      leqslant,
      les,
      lescc,
      lesdot,
      lesdoto,
      lesdotor,
      lesg,
      lesges,
      lessapprox,
      lessdot,
      lesseqgtr,
      lesseqqgtr,
      lessgtr,
      lesssim,
      lfisht,
      lfloor: lfloor$1,
      lfr,
      lg,
      lgE,
      lhard,
      lharu,
      lharul,
      lhblk,
      ljcy,
      ll,
      llarr,
      llcorner,
      llhard,
      lltri,
      lmidot,
      lmoust,
      lmoustache,
      lnE,
      lnap,
      lnapprox,
      lne,
      lneq,
      lneqq,
      lnsim,
      loang,
      loarr,
      lobrk,
      longleftarrow,
      longleftrightarrow,
      longmapsto,
      longrightarrow,
      looparrowleft,
      looparrowright,
      lopar,
      lopf,
      loplus,
      lotimes,
      lowast: lowast$1,
      lowbar,
      loz: loz$1,
      lozenge,
      lozf,
      lpar,
      lparlt,
      lrarr,
      lrcorner,
      lrhar,
      lrhard,
      lrm: lrm$1,
      lrtri,
      lsaquo: lsaquo$1,
      lscr,
      lsh,
      lsim,
      lsime,
      lsimg,
      lsqb,
      lsquo: lsquo$1,
      lsquor,
      lstrok,
      l,
      lt: lt$1,
      ltcc,
      ltcir,
      ltdot,
      lthree,
      ltimes,
      ltlarr,
      ltquest,
      ltrPar,
      ltri,
      ltrie,
      ltrif,
      lurdshar,
      luruhar,
      lvertneqq,
      lvnE,
      mDDot,
      mac,
      macr: macr$1,
      male,
      malt,
      maltese,
      map: map$1,
      mapsto,
      mapstodown,
      mapstoleft,
      mapstoup,
      marker,
      mcomma,
      mcy,
      mdash: mdash$1,
      measuredangle,
      mfr,
      mho,
      micr,
      micro: micro$1,
      mid,
      midast,
      midcir,
      middo,
      middot: middot$1,
      minus: minus$1,
      minusb,
      minusd,
      minusdu,
      mlcp,
      mldr,
      mnplus,
      models,
      mopf,
      mp,
      mscr,
      mstpos,
      mu: mu$1,
      multimap,
      mumap,
      nGg,
      nGt,
      nGtv,
      nLeftarrow,
      nLeftrightarrow,
      nLl,
      nLt,
      nLtv,
      nRightarrow,
      nVDash,
      nVdash,
      nabla: nabla$1,
      nacute,
      nang,
      nap,
      napE,
      napid,
      napos,
      napprox,
      natur,
      natural,
      naturals,
      nbs,
      nbsp: nbsp$1,
      nbump,
      nbumpe,
      ncap,
      ncaron,
      ncedil,
      ncong,
      ncongdot,
      ncup,
      ncy,
      ndash: ndash$1,
      ne: ne$1,
      neArr,
      nearhk,
      nearr,
      nearrow,
      nedot,
      nequiv,
      nesear,
      nesim,
      nexist,
      nexists,
      nfr,
      ngE,
      nge,
      ngeq,
      ngeqq,
      ngeqslant,
      nges,
      ngsim,
      ngt,
      ngtr,
      nhArr,
      nharr,
      nhpar,
      ni: ni$1,
      nis,
      nisd,
      niv,
      njcy,
      nlArr,
      nlE,
      nlarr,
      nldr,
      nle,
      nleftarrow,
      nleftrightarrow,
      nleq,
      nleqq,
      nleqslant,
      nles,
      nless,
      nlsim,
      nlt,
      nltri,
      nltrie,
      nmid,
      nopf,
      no,
      not: not$1,
      notin: notin$1,
      notinE,
      notindot,
      notinva,
      notinvb,
      notinvc,
      notni,
      notniva,
      notnivb,
      notnivc,
      npar,
      nparallel,
      nparsl,
      npart,
      npolint,
      npr,
      nprcue,
      npre,
      nprec,
      npreceq,
      nrArr,
      nrarr,
      nrarrc,
      nrarrw,
      nrightarrow,
      nrtri,
      nrtrie,
      nsc,
      nsccue,
      nsce,
      nscr,
      nshortmid,
      nshortparallel,
      nsim,
      nsime,
      nsimeq,
      nsmid,
      nspar,
      nsqsube,
      nsqsupe,
      nsub: nsub$1,
      nsubE,
      nsube,
      nsubset,
      nsubseteq,
      nsubseteqq,
      nsucc,
      nsucceq,
      nsup,
      nsupE,
      nsupe,
      nsupset,
      nsupseteq,
      nsupseteqq,
      ntgl,
      ntild,
      ntilde: ntilde$1,
      ntlg,
      ntriangleleft,
      ntrianglelefteq,
      ntriangleright,
      ntrianglerighteq,
      nu: nu$1,
      num,
      numero,
      numsp,
      nvDash,
      nvHarr,
      nvap,
      nvdash,
      nvge,
      nvgt,
      nvinfin,
      nvlArr,
      nvle,
      nvlt,
      nvltrie,
      nvrArr,
      nvrtrie,
      nvsim,
      nwArr,
      nwarhk,
      nwarr,
      nwarrow,
      nwnear,
      oS,
      oacut,
      oacute: oacute$1,
      oast,
      ocir,
      ocirc: ocirc$1,
      ocy,
      odash,
      odblac,
      odiv,
      odot,
      odsold,
      oelig: oelig$1,
      ofcir,
      ofr,
      ogon,
      ograv,
      ograve: ograve$1,
      ogt,
      ohbar,
      ohm,
      oint,
      olarr,
      olcir,
      olcross,
      oline: oline$1,
      olt,
      omacr,
      omega: omega$1,
      omicron: omicron$1,
      omid,
      ominus,
      oopf,
      opar,
      operp,
      oplus: oplus$1,
      or: or$1,
      orarr,
      ord,
      order,
      orderof,
      ordf: ordf$1,
      ordm: ordm$1,
      origof,
      oror,
      orslope,
      orv,
      oscr,
      oslas,
      oslash: oslash$1,
      osol,
      otild,
      otilde: otilde$1,
      otimes: otimes$1,
      otimesas,
      oum,
      ouml: ouml$1,
      ovbar,
      par,
      para: para$1,
      parallel,
      parsim,
      parsl,
      part: part$1,
      pcy,
      percnt,
      period,
      permil: permil$1,
      perp: perp$1,
      pertenk,
      pfr,
      phi: phi$1,
      phiv,
      phmmat,
      phone,
      pi: pi$1,
      pitchfork,
      piv: piv$1,
      planck,
      planckh,
      plankv,
      plus,
      plusacir,
      plusb,
      pluscir,
      plusdo,
      plusdu,
      pluse,
      plusm,
      plusmn: plusmn$1,
      plussim,
      plustwo,
      pm,
      pointint,
      popf,
      poun,
      pound: pound$1,
      pr,
      prE,
      prap,
      prcue,
      pre,
      prec,
      precapprox,
      preccurlyeq,
      preceq,
      precnapprox,
      precneqq,
      precnsim,
      precsim,
      prime: prime$1,
      primes,
      prnE,
      prnap,
      prnsim,
      prod: prod$1,
      profalar,
      profline,
      profsurf,
      prop: prop$1,
      propto,
      prsim,
      prurel,
      pscr,
      psi: psi$1,
      puncsp,
      qfr,
      qint,
      qopf,
      qprime,
      qscr,
      quaternions,
      quatint,
      quest,
      questeq,
      quo,
      quot: quot$1,
      rAarr,
      rArr: rArr$1,
      rAtail,
      rBarr,
      rHar,
      race,
      racute,
      radic: radic$1,
      raemptyv,
      rang: rang$1,
      rangd,
      range,
      rangle,
      raqu,
      raquo: raquo$1,
      rarr: rarr$1,
      rarrap,
      rarrb,
      rarrbfs,
      rarrc,
      rarrfs,
      rarrhk,
      rarrlp,
      rarrpl,
      rarrsim,
      rarrtl,
      rarrw,
      ratail,
      ratio,
      rationals,
      rbarr,
      rbbrk,
      rbrace,
      rbrack,
      rbrke,
      rbrksld,
      rbrkslu,
      rcaron,
      rcedil,
      rceil: rceil$1,
      rcub,
      rcy,
      rdca,
      rdldhar,
      rdquo: rdquo$1,
      rdquor,
      rdsh,
      real: real$1,
      realine,
      realpart,
      reals,
      rect,
      re: re$3,
      reg: reg$1,
      rfisht,
      rfloor: rfloor$1,
      rfr,
      rhard,
      rharu,
      rharul,
      rho: rho$1,
      rhov,
      rightarrow,
      rightarrowtail,
      rightharpoondown,
      rightharpoonup,
      rightleftarrows,
      rightleftharpoons,
      rightrightarrows,
      rightsquigarrow,
      rightthreetimes,
      ring,
      risingdotseq,
      rlarr,
      rlhar,
      rlm: rlm$1,
      rmoust,
      rmoustache,
      rnmid,
      roang,
      roarr,
      robrk,
      ropar,
      ropf,
      roplus,
      rotimes,
      rpar,
      rpargt,
      rppolint,
      rrarr,
      rsaquo: rsaquo$1,
      rscr,
      rsh,
      rsqb,
      rsquo: rsquo$1,
      rsquor,
      rthree,
      rtimes,
      rtri,
      rtrie,
      rtrif,
      rtriltri,
      ruluhar,
      rx,
      sacute,
      sbquo: sbquo$1,
      sc,
      scE,
      scap,
      scaron: scaron$1,
      sccue,
      sce,
      scedil,
      scirc,
      scnE,
      scnap,
      scnsim,
      scpolint,
      scsim,
      scy,
      sdot: sdot$1,
      sdotb,
      sdote,
      seArr,
      searhk,
      searr,
      searrow,
      sec,
      sect: sect$1,
      semi,
      seswar,
      setminus,
      setmn,
      sext,
      sfr,
      sfrown,
      sharp,
      shchcy,
      shcy,
      shortmid,
      shortparallel,
      sh,
      shy: shy$1,
      sigma: sigma$1,
      sigmaf: sigmaf$1,
      sigmav,
      sim: sim$1,
      simdot,
      sime,
      simeq,
      simg,
      simgE,
      siml,
      simlE,
      simne,
      simplus,
      simrarr,
      slarr,
      smallsetminus,
      smashp,
      smeparsl,
      smid,
      smile,
      smt,
      smte,
      smtes,
      softcy,
      sol,
      solb,
      solbar,
      sopf,
      spades: spades$1,
      spadesuit,
      spar,
      sqcap,
      sqcaps,
      sqcup,
      sqcups,
      sqsub,
      sqsube,
      sqsubset,
      sqsubseteq,
      sqsup,
      sqsupe,
      sqsupset,
      sqsupseteq,
      squ,
      square,
      squarf,
      squf,
      srarr,
      sscr,
      ssetmn,
      ssmile,
      sstarf,
      star,
      starf,
      straightepsilon,
      straightphi,
      strns,
      sub: sub$1,
      subE,
      subdot,
      sube: sube$1,
      subedot,
      submult,
      subnE,
      subne,
      subplus,
      subrarr,
      subset,
      subseteq,
      subseteqq,
      subsetneq,
      subsetneqq,
      subsim,
      subsub,
      subsup,
      succ,
      succapprox,
      succcurlyeq,
      succeq,
      succnapprox,
      succneqq,
      succnsim,
      succsim,
      sum: sum$1,
      sung,
      sup: sup$1,
      sup1: sup1$1,
      sup2: sup2$1,
      sup3: sup3$1,
      supE,
      supdot,
      supdsub,
      supe: supe$1,
      supedot,
      suphsol,
      suphsub,
      suplarr,
      supmult,
      supnE,
      supne,
      supplus,
      supset,
      supseteq,
      supseteqq,
      supsetneq,
      supsetneqq,
      supsim,
      supsub,
      supsup,
      swArr,
      swarhk,
      swarr,
      swarrow,
      swnwar,
      szli,
      szlig: szlig$1,
      target,
      tau: tau$1,
      tbrk,
      tcaron,
      tcedil,
      tcy,
      tdot,
      telrec,
      tfr,
      there4: there4$1,
      therefore,
      theta: theta$1,
      thetasym: thetasym$1,
      thetav,
      thickapprox,
      thicksim,
      thinsp: thinsp$1,
      thkap,
      thksim,
      thor,
      thorn: thorn$1,
      tilde: tilde$4,
      time,
      times: times$1,
      timesb,
      timesbar,
      timesd,
      tint,
      toea,
      top,
      topbot,
      topcir,
      topf,
      topfork,
      tosa,
      tprime,
      trade: trade$1,
      triangle,
      triangledown,
      triangleleft,
      trianglelefteq,
      triangleq,
      triangleright,
      trianglerighteq,
      tridot,
      trie,
      triminus,
      triplus,
      trisb,
      tritime,
      trpezium,
      tscr,
      tscy,
      tshcy,
      tstrok,
      twixt,
      twoheadleftarrow,
      twoheadrightarrow,
      uArr: uArr$1,
      uHar,
      uacut,
      uacute: uacute$1,
      uarr: uarr$1,
      ubrcy,
      ubreve,
      ucir,
      ucirc: ucirc$1,
      ucy,
      udarr,
      udblac,
      udhar,
      ufisht,
      ufr,
      ugrav,
      ugrave: ugrave$1,
      uharl,
      uharr,
      uhblk,
      ulcorn,
      ulcorner,
      ulcrop,
      ultri,
      umacr,
      um,
      uml: uml$1,
      uogon,
      uopf,
      uparrow,
      updownarrow,
      upharpoonleft,
      upharpoonright,
      uplus,
      upsi,
      upsih: upsih$1,
      upsilon: upsilon$1,
      upuparrows,
      urcorn,
      urcorner,
      urcrop,
      uring,
      urtri,
      uscr,
      utdot,
      utilde,
      utri,
      utrif,
      uuarr,
      uum,
      uuml: uuml$1,
      uwangle,
      vArr,
      vBar,
      vBarv,
      vDash,
      vangrt,
      varepsilon,
      varkappa,
      varnothing,
      varphi,
      varpi,
      varpropto,
      varr,
      varrho,
      varsigma,
      varsubsetneq,
      varsubsetneqq,
      varsupsetneq,
      varsupsetneqq,
      vartheta,
      vartriangleleft,
      vartriangleright,
      vcy,
      vdash,
      vee,
      veebar,
      veeeq,
      vellip,
      verbar,
      vert,
      vfr,
      vltri,
      vnsub,
      vnsup,
      vopf,
      vprop,
      vrtri,
      vscr,
      vsubnE,
      vsubne,
      vsupnE,
      vsupne,
      vzigzag,
      wcirc,
      wedbar,
      wedge,
      wedgeq,
      weierp: weierp$1,
      wfr,
      wopf,
      wp,
      wr,
      wreath,
      wscr,
      xcap,
      xcirc,
      xcup,
      xdtri,
      xfr,
      xhArr,
      xharr,
      xi: xi$1,
      xlArr,
      xlarr,
      xmap,
      xnis,
      xodot,
      xopf,
      xoplus,
      xotime,
      xrArr,
      xrarr,
      xscr,
      xsqcup,
      xuplus,
      xutri,
      xvee,
      xwedge,
      yacut,
      yacute: yacute$1,
      yacy,
      ycirc,
      ycy,
      ye,
      yen: yen$1,
      yfr,
      yicy,
      yopf,
      yscr,
      yucy,
      yum,
      yuml: yuml$1,
      zacute,
      zcaron,
      zcy,
      zdot,
      zeetrf,
      zeta: zeta$1,
      zfr,
      zhcy,
      zigrarr,
      zopf,
      zscr,
      zwj: zwj$1,
      zwnj: zwnj$1,
      "default": index$3
    });
    var characterEntities = getCjsExportFromNamespace(characterEntities$1);
    var decodeEntity_1 = decodeEntity;
    var own$c = {}.hasOwnProperty;
    function decodeEntity(characters2) {
      return own$c.call(characterEntities, characters2) ? characterEntities[characters2] : false;
    }
    var legacy = getCjsExportFromNamespace(characterEntitiesLegacy);
    var invalid = getCjsExportFromNamespace(characterReferenceInvalid);
    var parseEntities_1 = parseEntities;
    var own$b = {}.hasOwnProperty;
    var fromCharCode = String.fromCharCode;
    var noop2 = Function.prototype;
    var defaults$3 = {
      warning: null,
      reference: null,
      text: null,
      warningContext: null,
      referenceContext: null,
      textContext: null,
      position: {},
      additional: null,
      attribute: false,
      nonTerminated: true
    };
    var tab$e = 9;
    var lineFeed$j = 10;
    var formFeed = 12;
    var space$j = 32;
    var ampersand$1 = 38;
    var semicolon$1 = 59;
    var lessThan$8 = 60;
    var equalsTo$2 = 61;
    var numberSign$1 = 35;
    var uppercaseX = 88;
    var lowercaseX$1 = 120;
    var replacementCharacter = 65533;
    var name$1 = "named";
    var hexa = "hexadecimal";
    var deci = "decimal";
    var bases = {};
    bases[hexa] = 16;
    bases[deci] = 10;
    var tests = {};
    tests[name$1] = isAlphanumerical;
    tests[deci] = isDecimal;
    tests[hexa] = isHexadecimal;
    var namedNotTerminated = 1;
    var numericNotTerminated = 2;
    var namedEmpty = 3;
    var numericEmpty = 4;
    var namedUnknown = 5;
    var numericDisallowed = 6;
    var numericProhibited = 7;
    var messages = {};
    messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
    messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
    messages[namedEmpty] = "Named character references cannot be empty";
    messages[numericEmpty] = "Numeric character references cannot be empty";
    messages[namedUnknown] = "Named character references must be known";
    messages[numericDisallowed] = "Numeric character references cannot be disallowed";
    messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
    function parseEntities(value, options4) {
      var settings = {};
      var option2;
      var key;
      if (!options4) {
        options4 = {};
      }
      for (key in defaults$3) {
        option2 = options4[key];
        settings[key] = option2 === null || option2 === void 0 ? defaults$3[key] : option2;
      }
      if (settings.position.indent || settings.position.start) {
        settings.indent = settings.position.indent || [];
        settings.position = settings.position.start;
      }
      return parse$7(value, settings);
    }
    function parse$7(value, settings) {
      var additional = settings.additional;
      var nonTerminated = settings.nonTerminated;
      var handleText = settings.text;
      var handleReference = settings.reference;
      var handleWarning = settings.warning;
      var textContext = settings.textContext;
      var referenceContext = settings.referenceContext;
      var warningContext = settings.warningContext;
      var pos = settings.position;
      var indent = settings.indent || [];
      var length = value.length;
      var index3 = 0;
      var lines = -1;
      var column = pos.column || 1;
      var line2 = pos.line || 1;
      var queue = "";
      var result = [];
      var entityCharacters;
      var namedEntity;
      var terminated;
      var characters2;
      var character;
      var reference2;
      var following;
      var warning;
      var reason;
      var output;
      var entity;
      var begin;
      var start2;
      var type2;
      var test;
      var prev;
      var next;
      var diff;
      var end2;
      if (typeof additional === "string") {
        additional = additional.charCodeAt(0);
      }
      prev = now();
      warning = handleWarning ? parseError : noop2;
      index3--;
      length++;
      while (++index3 < length) {
        if (character === lineFeed$j) {
          column = indent[lines] || 1;
        }
        character = value.charCodeAt(index3);
        if (character === ampersand$1) {
          following = value.charCodeAt(index3 + 1);
          if (following === tab$e || following === lineFeed$j || following === formFeed || following === space$j || following === ampersand$1 || following === lessThan$8 || following !== following || additional && following === additional) {
            queue += fromCharCode(character);
            column++;
            continue;
          }
          start2 = index3 + 1;
          begin = start2;
          end2 = start2;
          if (following === numberSign$1) {
            end2 = ++begin;
            following = value.charCodeAt(end2);
            if (following === uppercaseX || following === lowercaseX$1) {
              type2 = hexa;
              end2 = ++begin;
            } else {
              type2 = deci;
            }
          } else {
            type2 = name$1;
          }
          entityCharacters = "";
          entity = "";
          characters2 = "";
          test = tests[type2];
          end2--;
          while (++end2 < length) {
            following = value.charCodeAt(end2);
            if (!test(following)) {
              break;
            }
            characters2 += fromCharCode(following);
            if (type2 === name$1 && own$b.call(legacy, characters2)) {
              entityCharacters = characters2;
              entity = legacy[characters2];
            }
          }
          terminated = value.charCodeAt(end2) === semicolon$1;
          if (terminated) {
            end2++;
            namedEntity = type2 === name$1 ? decodeEntity_1(characters2) : false;
            if (namedEntity) {
              entityCharacters = characters2;
              entity = namedEntity;
            }
          }
          diff = 1 + end2 - start2;
          if (!terminated && !nonTerminated)
            ;
          else if (!characters2) {
            if (type2 !== name$1) {
              warning(numericEmpty, diff);
            }
          } else if (type2 === name$1) {
            if (terminated && !entity) {
              warning(namedUnknown, 1);
            } else {
              if (entityCharacters !== characters2) {
                end2 = begin + entityCharacters.length;
                diff = 1 + end2 - begin;
                terminated = false;
              }
              if (!terminated) {
                reason = entityCharacters ? namedNotTerminated : namedEmpty;
                if (settings.attribute) {
                  following = value.charCodeAt(end2);
                  if (following === equalsTo$2) {
                    warning(reason, diff);
                    entity = null;
                  } else if (isAlphanumerical(following)) {
                    entity = null;
                  } else {
                    warning(reason, diff);
                  }
                } else {
                  warning(reason, diff);
                }
              }
            }
            reference2 = entity;
          } else {
            if (!terminated) {
              warning(numericNotTerminated, diff);
            }
            reference2 = parseInt(characters2, bases[type2]);
            if (prohibited(reference2)) {
              warning(numericProhibited, diff);
              reference2 = fromCharCode(replacementCharacter);
            } else if (reference2 in invalid) {
              warning(numericDisallowed, diff);
              reference2 = invalid[reference2];
            } else {
              output = "";
              if (disallowed(reference2)) {
                warning(numericDisallowed, diff);
              }
              if (reference2 > 65535) {
                reference2 -= 65536;
                output += fromCharCode(reference2 >>> (10 & 1023) | 55296);
                reference2 = 56320 | reference2 & 1023;
              }
              reference2 = output + fromCharCode(reference2);
            }
          }
          if (reference2) {
            flush();
            prev = now();
            index3 = end2 - 1;
            column += end2 - start2 + 1;
            result.push(reference2);
            next = now();
            next.offset++;
            if (handleReference) {
              handleReference.call(referenceContext, reference2, { start: prev, end: next }, value.slice(start2 - 1, end2));
            }
            prev = next;
          } else {
            characters2 = value.slice(start2 - 1, end2);
            queue += characters2;
            column += characters2.length;
            index3 = end2 - 1;
          }
        } else {
          if (character === 10) {
            line2++;
            lines++;
            column = 0;
          }
          if (character === character) {
            queue += fromCharCode(character);
            column++;
          } else {
            flush();
          }
        }
      }
      return result.join("");
      function now() {
        return {
          line: line2,
          column,
          offset: index3 + (pos.offset || 0)
        };
      }
      function parseError(code2, offset) {
        var position2 = now();
        position2.column += offset;
        position2.offset += offset;
        handleWarning.call(warningContext, messages[code2], position2, code2);
      }
      function flush() {
        if (queue) {
          result.push(queue);
          if (handleText) {
            handleText.call(textContext, queue, { start: prev, end: now() });
          }
          queue = "";
        }
      }
    }
    function prohibited(code2) {
      return code2 >= 55296 && code2 <= 57343 || code2 > 1114111;
    }
    function disallowed(code2) {
      return code2 >= 1 && code2 <= 8 || code2 === 11 || code2 >= 13 && code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 64976 && code2 <= 65007 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534;
    }
    var decode = factory$3;
    function factory$3(ctx) {
      decoder.raw = decodeRaw;
      return decoder;
      function normalize3(position2) {
        var offsets = ctx.offset;
        var line2 = position2.line;
        var result = [];
        while (++line2) {
          if (!(line2 in offsets)) {
            break;
          }
          result.push((offsets[line2] || 0) + 1);
        }
        return { start: position2, indent: result };
      }
      function decoder(value, position2, handler2) {
        parseEntities_1(value, {
          position: normalize3(position2),
          warning: handleWarning,
          text: handler2,
          reference: handler2,
          textContext: ctx,
          referenceContext: ctx
        });
      }
      function decodeRaw(value, position2, options4) {
        return parseEntities_1(value, immutable(options4, { position: normalize3(position2), warning: handleWarning }));
      }
      function handleWarning(reason, position2, code2) {
        if (code2 !== 3) {
          ctx.file.message(reason, position2);
        }
      }
    }
    var tokenizer$1 = factory$2;
    function factory$2(type2) {
      return tokenize2;
      function tokenize2(value, location) {
        var self2 = this;
        var offset = self2.offset;
        var tokens = [];
        var methods = self2[type2 + "Methods"];
        var tokenizers = self2[type2 + "Tokenizers"];
        var line2 = location.line;
        var column = location.column;
        var index3;
        var length;
        var method;
        var name2;
        var matched;
        var valueLength;
        if (!value) {
          return tokens;
        }
        eat.now = now;
        eat.file = self2.file;
        updatePosition("");
        while (value) {
          index3 = -1;
          length = methods.length;
          matched = false;
          while (++index3 < length) {
            name2 = methods[index3];
            method = tokenizers[name2];
            if (method && (!method.onlyAtStart || self2.atStart) && (!method.notInList || !self2.inList) && (!method.notInBlock || !self2.inBlock) && (!method.notInLink || !self2.inLink)) {
              valueLength = value.length;
              method.apply(self2, [eat, value]);
              matched = valueLength !== value.length;
              if (matched) {
                break;
              }
            }
          }
          if (!matched) {
            self2.file.fail(new Error("Infinite loop"), eat.now());
          }
        }
        self2.eof = now();
        return tokens;
        function updatePosition(subvalue) {
          var lastIndex = -1;
          var index4 = subvalue.indexOf("\n");
          while (index4 !== -1) {
            line2++;
            lastIndex = index4;
            index4 = subvalue.indexOf("\n", index4 + 1);
          }
          if (lastIndex === -1) {
            column += subvalue.length;
          } else {
            column = subvalue.length - lastIndex;
          }
          if (line2 in offset) {
            if (lastIndex !== -1) {
              column += offset[line2];
            } else if (column <= offset[line2]) {
              column = offset[line2] + 1;
            }
          }
        }
        function getOffset() {
          var indentation2 = [];
          var pos = line2 + 1;
          return function() {
            var last = line2 + 1;
            while (pos < last) {
              indentation2.push((offset[pos] || 0) + 1);
              pos++;
            }
            return indentation2;
          };
        }
        function now() {
          var pos = { line: line2, column };
          pos.offset = self2.toOffset(pos);
          return pos;
        }
        function Position(start2) {
          this.start = start2;
          this.end = now();
        }
        function validateEat(subvalue) {
          if (value.slice(0, subvalue.length) !== subvalue) {
            self2.file.fail(new Error("Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"), now());
          }
        }
        function position2() {
          var before2 = now();
          return update;
          function update(node, indent) {
            var previous = node.position;
            var start2 = previous ? previous.start : before2;
            var combined = [];
            var n = previous && previous.end.line;
            var l2 = before2.line;
            node.position = new Position(start2);
            if (previous && indent && previous.indent) {
              combined = previous.indent;
              if (n < l2) {
                while (++n < l2) {
                  combined.push((offset[n] || 0) + 1);
                }
                combined.push(before2.column);
              }
              indent = combined.concat(indent);
            }
            node.position.indent = indent || [];
            return node;
          }
        }
        function add(node, parent) {
          var children = parent ? parent.children : tokens;
          var previous = children[children.length - 1];
          var fn;
          if (previous && node.type === previous.type && (node.type === "text" || node.type === "blockquote") && mergeable(previous) && mergeable(node)) {
            fn = node.type === "text" ? mergeText : mergeBlockquote;
            node = fn.call(self2, previous, node);
          }
          if (node !== previous) {
            children.push(node);
          }
          if (self2.atStart && tokens.length !== 0) {
            self2.exitStart();
          }
          return node;
        }
        function eat(subvalue) {
          var indent = getOffset();
          var pos = position2();
          var current = now();
          validateEat(subvalue);
          apply.reset = reset;
          reset.test = test;
          apply.test = test;
          value = value.slice(subvalue.length);
          updatePosition(subvalue);
          indent = indent();
          return apply;
          function apply(node, parent) {
            return pos(add(pos(node), parent), indent);
          }
          function reset() {
            var node = apply.apply(null, arguments);
            line2 = current.line;
            column = current.column;
            value = subvalue + value;
            return node;
          }
          function test() {
            var result = pos({});
            line2 = current.line;
            column = current.column;
            value = subvalue + value;
            return result.position;
          }
        }
      }
    }
    function mergeable(node) {
      var start2;
      var end2;
      if (node.type !== "text" || !node.position) {
        return true;
      }
      start2 = node.position.start;
      end2 = node.position.end;
      return start2.line !== end2.line || end2.column - start2.column === node.value.length;
    }
    function mergeText(previous, node) {
      previous.value += node.value;
      return previous;
    }
    function mergeBlockquote(previous, node) {
      if (this.options.commonmark || this.options.gfm) {
        return node;
      }
      previous.children = previous.children.concat(node.children);
      return previous;
    }
    var markdownEscapes = escapes$1;
    var defaults$2 = [
      "\\",
      "`",
      "*",
      "{",
      "}",
      "[",
      "]",
      "(",
      ")",
      "#",
      "+",
      "-",
      ".",
      "!",
      "_",
      ">"
    ];
    var gfm = defaults$2.concat(["~", "|"]);
    var commonmark = gfm.concat([
      "\n",
      '"',
      "$",
      "%",
      "&",
      "'",
      ",",
      "/",
      ":",
      ";",
      "<",
      "=",
      "?",
      "@",
      "^"
    ]);
    escapes$1.default = defaults$2;
    escapes$1.gfm = gfm;
    escapes$1.commonmark = commonmark;
    function escapes$1(options4) {
      var settings = options4 || {};
      if (settings.commonmark) {
        return commonmark;
      }
      return settings.gfm ? gfm : defaults$2;
    }
    var blockElements = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "meta",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "pre",
      "section",
      "source",
      "title",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
    var defaults$1 = {
      position: true,
      gfm: true,
      commonmark: false,
      pedantic: false,
      blocks: blockElements
    };
    var setOptions_1 = setOptions;
    function setOptions(options4) {
      var self2 = this;
      var current = self2.options;
      var key;
      var value;
      if (options4 == null) {
        options4 = {};
      } else if (typeof options4 === "object") {
        options4 = immutable(options4);
      } else {
        throw new Error("Invalid value `" + options4 + "` for setting `options`");
      }
      for (key in defaults$1) {
        value = options4[key];
        if (value == null) {
          value = current[key];
        }
        if (key !== "blocks" && typeof value !== "boolean" || key === "blocks" && typeof value !== "object") {
          throw new Error("Invalid value `" + value + "` for setting `options." + key + "`");
        }
        options4[key] = value;
      }
      self2.options = options4;
      self2.escape = markdownEscapes(options4);
      return self2;
    }
    var convert_1 = convert$1;
    function convert$1(test) {
      if (test == null) {
        return ok$1;
      }
      if (typeof test === "string") {
        return typeFactory$1(test);
      }
      if (typeof test === "object") {
        return "length" in test ? anyFactory$1(test) : allFactory(test);
      }
      if (typeof test === "function") {
        return test;
      }
      throw new Error("Expected function, string, or object as test");
    }
    function allFactory(test) {
      return all2;
      function all2(node) {
        var key;
        for (key in test) {
          if (node[key] !== test[key])
            return false;
        }
        return true;
      }
    }
    function anyFactory$1(tests2) {
      var checks2 = [];
      var index3 = -1;
      while (++index3 < tests2.length) {
        checks2[index3] = convert$1(tests2[index3]);
      }
      return any;
      function any() {
        var index4 = -1;
        while (++index4 < checks2.length) {
          if (checks2[index4].apply(this, arguments)) {
            return true;
          }
        }
        return false;
      }
    }
    function typeFactory$1(test) {
      return type2;
      function type2(node) {
        return Boolean(node && node.type === test);
      }
    }
    function ok$1() {
      return true;
    }
    var color_1 = color;
    function color(d2) {
      return "[33m" + d2 + "[39m";
    }
    var unistUtilVisitParents = visitParents;
    var CONTINUE$1 = true;
    var SKIP$1 = "skip";
    var EXIT$1 = false;
    visitParents.CONTINUE = CONTINUE$1;
    visitParents.SKIP = SKIP$1;
    visitParents.EXIT = EXIT$1;
    function visitParents(tree, test, visitor, reverse) {
      var step;
      var is2;
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      is2 = convert_1(test);
      step = reverse ? -1 : 1;
      factory2(tree, null, [])();
      function factory2(node, index3, parents) {
        var value = typeof node === "object" && node !== null ? node : {};
        var name2;
        if (typeof value.type === "string") {
          name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
          visit2.displayName = "node (" + color_1(value.type + (name2 ? "<" + name2 + ">" : "")) + ")";
        }
        return visit2;
        function visit2() {
          var grandparents = parents.concat(node);
          var result = [];
          var subresult;
          var offset;
          if (!test || is2(node, index3, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node, parents));
            if (result[0] === EXIT$1) {
              return result;
            }
          }
          if (node.children && result[0] !== SKIP$1) {
            offset = (reverse ? node.children.length : -1) + step;
            while (offset > -1 && offset < node.children.length) {
              subresult = factory2(node.children[offset], offset, grandparents)();
              if (subresult[0] === EXIT$1) {
                return subresult;
              }
              offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
            }
          }
          return result;
        }
      }
    }
    function toResult(value) {
      if (value !== null && typeof value === "object" && "length" in value) {
        return value;
      }
      if (typeof value === "number") {
        return [CONTINUE$1, value];
      }
      return [value];
    }
    var unistUtilVisit = visit;
    var CONTINUE = unistUtilVisitParents.CONTINUE;
    var SKIP = unistUtilVisitParents.SKIP;
    var EXIT = unistUtilVisitParents.EXIT;
    visit.CONTINUE = CONTINUE;
    visit.SKIP = SKIP;
    visit.EXIT = EXIT;
    function visit(tree, test, visitor, reverse) {
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      unistUtilVisitParents(tree, test, overload, reverse);
      function overload(node, parents) {
        var parent = parents[parents.length - 1];
        var index3 = parent ? parent.children.indexOf(node) : null;
        return visitor(node, index3, parent);
      }
    }
    var unistUtilRemovePosition = removePosition;
    function removePosition(node, force) {
      unistUtilVisit(node, force ? hard : soft);
      return node;
    }
    function hard(node) {
      delete node.position;
    }
    function soft(node) {
      node.position = void 0;
    }
    var parse_1$2 = parse$6;
    var lineFeed$i = "\n";
    var lineBreaksExpression = /\r\n|\r/g;
    function parse$6() {
      var self2 = this;
      var value = String(self2.file);
      var start2 = { line: 1, column: 1, offset: 0 };
      var content = immutable(start2);
      var node;
      value = value.replace(lineBreaksExpression, lineFeed$i);
      if (value.charCodeAt(0) === 65279) {
        value = value.slice(1);
        content.column++;
        content.offset++;
      }
      node = {
        type: "root",
        children: self2.tokenizeBlock(value, content),
        position: { start: start2, end: self2.eof || immutable(start2) }
      };
      if (!self2.options.position) {
        unistUtilRemovePosition(node, true);
      }
      return node;
    }
    var reBlankLine = /^[ \t]*(\n|$)/;
    var blankLine_1 = blankLine;
    function blankLine(eat, value, silent) {
      var match;
      var subvalue = "";
      var index3 = 0;
      var length = value.length;
      while (index3 < length) {
        match = reBlankLine.exec(value.slice(index3));
        if (match == null) {
          break;
        }
        index3 += match[0].length;
        subvalue += match[0];
      }
      if (subvalue === "") {
        return;
      }
      if (silent) {
        return true;
      }
      eat(subvalue);
    }
    var res = "";
    var cache;
    var repeatString = repeat$1;
    function repeat$1(str3, num2) {
      if (typeof str3 !== "string") {
        throw new TypeError("expected a string");
      }
      if (num2 === 1)
        return str3;
      if (num2 === 2)
        return str3 + str3;
      var max = str3.length * num2;
      if (cache !== str3 || typeof cache === "undefined") {
        cache = str3;
        res = "";
      } else if (res.length >= max) {
        return res.substr(0, max);
      }
      while (max > res.length && num2 > 1) {
        if (num2 & 1) {
          res += str3;
        }
        num2 >>= 1;
        str3 += str3;
      }
      res += str3;
      res = res.substr(0, max);
      return res;
    }
    var trimTrailingLines_1 = trimTrailingLines;
    var line = "\n";
    function trimTrailingLines(value) {
      var val = String(value);
      var index3 = val.length;
      while (val.charAt(--index3) === line) {
      }
      return val.slice(0, index3 + 1);
    }
    var codeIndented = indentedCode$1;
    var lineFeed$h = "\n";
    var tab$d = "	";
    var space$i = " ";
    var tabSize$4 = 4;
    var codeIndent = repeatString(space$i, tabSize$4);
    function indentedCode$1(eat, value, silent) {
      var index3 = -1;
      var length = value.length;
      var subvalue = "";
      var content = "";
      var subvalueQueue = "";
      var contentQueue = "";
      var character;
      var blankQueue;
      var indent;
      while (++index3 < length) {
        character = value.charAt(index3);
        if (indent) {
          indent = false;
          subvalue += subvalueQueue;
          content += contentQueue;
          subvalueQueue = "";
          contentQueue = "";
          if (character === lineFeed$h) {
            subvalueQueue = character;
            contentQueue = character;
          } else {
            subvalue += character;
            content += character;
            while (++index3 < length) {
              character = value.charAt(index3);
              if (!character || character === lineFeed$h) {
                contentQueue = character;
                subvalueQueue = character;
                break;
              }
              subvalue += character;
              content += character;
            }
          }
        } else if (character === space$i && value.charAt(index3 + 1) === character && value.charAt(index3 + 2) === character && value.charAt(index3 + 3) === character) {
          subvalueQueue += codeIndent;
          index3 += 3;
          indent = true;
        } else if (character === tab$d) {
          subvalueQueue += character;
          indent = true;
        } else {
          blankQueue = "";
          while (character === tab$d || character === space$i) {
            blankQueue += character;
            character = value.charAt(++index3);
          }
          if (character !== lineFeed$h) {
            break;
          }
          subvalueQueue += blankQueue + character;
          contentQueue += character;
        }
      }
      if (content) {
        if (silent) {
          return true;
        }
        return eat(subvalue)({
          type: "code",
          lang: null,
          meta: null,
          value: trimTrailingLines_1(content)
        });
      }
    }
    var codeFenced = fencedCode;
    var lineFeed$g = "\n";
    var tab$c = "	";
    var space$h = " ";
    var tilde$3 = "~";
    var graveAccent$2 = "`";
    var minFenceCount = 3;
    var tabSize$3 = 4;
    function fencedCode(eat, value, silent) {
      var self2 = this;
      var gfm2 = self2.options.gfm;
      var length = value.length + 1;
      var index3 = 0;
      var subvalue = "";
      var fenceCount;
      var marker2;
      var character;
      var flag;
      var lang2;
      var meta2;
      var queue;
      var content;
      var exdentedContent;
      var closing2;
      var exdentedClosing;
      var indent;
      var now;
      if (!gfm2) {
        return;
      }
      while (index3 < length) {
        character = value.charAt(index3);
        if (character !== space$h && character !== tab$c) {
          break;
        }
        subvalue += character;
        index3++;
      }
      indent = index3;
      character = value.charAt(index3);
      if (character !== tilde$3 && character !== graveAccent$2) {
        return;
      }
      index3++;
      marker2 = character;
      fenceCount = 1;
      subvalue += character;
      while (index3 < length) {
        character = value.charAt(index3);
        if (character !== marker2) {
          break;
        }
        subvalue += character;
        fenceCount++;
        index3++;
      }
      if (fenceCount < minFenceCount) {
        return;
      }
      while (index3 < length) {
        character = value.charAt(index3);
        if (character !== space$h && character !== tab$c) {
          break;
        }
        subvalue += character;
        index3++;
      }
      flag = "";
      queue = "";
      while (index3 < length) {
        character = value.charAt(index3);
        if (character === lineFeed$g || marker2 === graveAccent$2 && character === marker2) {
          break;
        }
        if (character === space$h || character === tab$c) {
          queue += character;
        } else {
          flag += queue + character;
          queue = "";
        }
        index3++;
      }
      character = value.charAt(index3);
      if (character && character !== lineFeed$g) {
        return;
      }
      if (silent) {
        return true;
      }
      now = eat.now();
      now.column += subvalue.length;
      now.offset += subvalue.length;
      subvalue += flag;
      flag = self2.decode.raw(self2.unescape(flag), now);
      if (queue) {
        subvalue += queue;
      }
      queue = "";
      closing2 = "";
      exdentedClosing = "";
      content = "";
      exdentedContent = "";
      var skip = true;
      while (index3 < length) {
        character = value.charAt(index3);
        content += closing2;
        exdentedContent += exdentedClosing;
        closing2 = "";
        exdentedClosing = "";
        if (character !== lineFeed$g) {
          content += character;
          exdentedClosing += character;
          index3++;
          continue;
        }
        if (skip) {
          subvalue += character;
          skip = false;
        } else {
          closing2 += character;
          exdentedClosing += character;
        }
        queue = "";
        index3++;
        while (index3 < length) {
          character = value.charAt(index3);
          if (character !== space$h) {
            break;
          }
          queue += character;
          index3++;
        }
        closing2 += queue;
        exdentedClosing += queue.slice(indent);
        if (queue.length >= tabSize$3) {
          continue;
        }
        queue = "";
        while (index3 < length) {
          character = value.charAt(index3);
          if (character !== marker2) {
            break;
          }
          queue += character;
          index3++;
        }
        closing2 += queue;
        exdentedClosing += queue;
        if (queue.length < fenceCount) {
          continue;
        }
        queue = "";
        while (index3 < length) {
          character = value.charAt(index3);
          if (character !== space$h && character !== tab$c) {
            break;
          }
          closing2 += character;
          exdentedClosing += character;
          index3++;
        }
        if (!character || character === lineFeed$g) {
          break;
        }
      }
      subvalue += content + closing2;
      index3 = -1;
      length = flag.length;
      while (++index3 < length) {
        character = flag.charAt(index3);
        if (character === space$h || character === tab$c) {
          if (!lang2) {
            lang2 = flag.slice(0, index3);
          }
        } else if (lang2) {
          meta2 = flag.slice(index3);
          break;
        }
      }
      return eat(subvalue)({
        type: "code",
        lang: lang2 || flag || null,
        meta: meta2 || null,
        value: exdentedContent
      });
    }
    var trim_1 = createCommonjsModule(function(module3, exports3) {
      exports3 = module3.exports = trim;
      function trim(str3) {
        return str3.replace(/^\s*|\s*$/g, "");
      }
      exports3.left = function(str3) {
        return str3.replace(/^\s*/, "");
      };
      exports3.right = function(str3) {
        return str3.replace(/\s*$/, "");
      };
    });
    trim_1.left;
    trim_1.right;
    var interrupt_1 = interrupt;
    function interrupt(interruptors, tokenizers, ctx, parameters) {
      var length = interruptors.length;
      var index3 = -1;
      var interruptor;
      var config;
      while (++index3 < length) {
        interruptor = interruptors[index3];
        config = interruptor[1] || {};
        if (config.pedantic !== void 0 && config.pedantic !== ctx.options.pedantic) {
          continue;
        }
        if (config.commonmark !== void 0 && config.commonmark !== ctx.options.commonmark) {
          continue;
        }
        if (tokenizers[interruptor[0]].apply(ctx, parameters)) {
          return true;
        }
      }
      return false;
    }
    var blockquote_1$1 = blockquote$1;
    var lineFeed$f = "\n";
    var tab$b = "	";
    var space$g = " ";
    var greaterThan$4 = ">";
    function blockquote$1(eat, value, silent) {
      var self2 = this;
      var offsets = self2.offset;
      var tokenizers = self2.blockTokenizers;
      var interruptors = self2.interruptBlockquote;
      var now = eat.now();
      var currentLine = now.line;
      var length = value.length;
      var values2 = [];
      var contents = [];
      var indents = [];
      var add;
      var index3 = 0;
      var character;
      var rest;
      var nextIndex;
      var content;
      var line2;
      var startIndex;
      var prefixed;
      var exit;
      while (index3 < length) {
        character = value.charAt(index3);
        if (character !== space$g && character !== tab$b) {
          break;
        }
        index3++;
      }
      if (value.charAt(index3) !== greaterThan$4) {
        return;
      }
      if (silent) {
        return true;
      }
      index3 = 0;
      while (index3 < length) {
        nextIndex = value.indexOf(lineFeed$f, index3);
        startIndex = index3;
        prefixed = false;
        if (nextIndex === -1) {
          nextIndex = length;
        }
        while (index3 < length) {
          character = value.charAt(index3);
          if (character !== space$g && character !== tab$b) {
            break;
          }
          index3++;
        }
        if (value.charAt(index3) === greaterThan$4) {
          index3++;
          prefixed = true;
          if (value.charAt(index3) === space$g) {
            index3++;
          }
        } else {
          index3 = startIndex;
        }
        content = value.slice(index3, nextIndex);
        if (!prefixed && !trim_1(content)) {
          index3 = startIndex;
          break;
        }
        if (!prefixed) {
          rest = value.slice(index3);
          if (interrupt_1(interruptors, tokenizers, self2, [eat, rest, true])) {
            break;
          }
        }
        line2 = startIndex === index3 ? content : value.slice(startIndex, nextIndex);
        indents.push(index3 - startIndex);
        values2.push(line2);
        contents.push(content);
        index3 = nextIndex + 1;
      }
      index3 = -1;
      length = indents.length;
      add = eat(values2.join(lineFeed$f));
      while (++index3 < length) {
        offsets[currentLine] = (offsets[currentLine] || 0) + indents[index3];
        currentLine++;
      }
      exit = self2.enterBlock();
      contents = self2.tokenizeBlock(contents.join(lineFeed$f), now);
      exit();
      return add({ type: "blockquote", children: contents });
    }
    var headingAtx = atxHeading;
    var lineFeed$e = "\n";
    var tab$a = "	";
    var space$f = " ";
    var numberSign = "#";
    var maxFenceCount = 6;
    function atxHeading(eat, value, silent) {
      var self2 = this;
      var pedantic = self2.options.pedantic;
      var length = value.length + 1;
      var index3 = -1;
      var now = eat.now();
      var subvalue = "";
      var content = "";
      var character;
      var queue;
      var depth;
      while (++index3 < length) {
        character = value.charAt(index3);
        if (character !== space$f && character !== tab$a) {
          index3--;
          break;
        }
        subvalue += character;
      }
      depth = 0;
      while (++index3 <= length) {
        character = value.charAt(index3);
        if (character !== numberSign) {
          index3--;
          break;
        }
        subvalue += character;
        depth++;
      }
      if (depth > maxFenceCount) {
        return;
      }
      if (!depth || !pedantic && value.charAt(index3 + 1) === numberSign) {
        return;
      }
      length = value.length + 1;
      queue = "";
      while (++index3 < length) {
        character = value.charAt(index3);
        if (character !== space$f && character !== tab$a) {
          index3--;
          break;
        }
        queue += character;
      }
      if (!pedantic && queue.length === 0 && character && character !== lineFeed$e) {
        return;
      }
      if (silent) {
        return true;
      }
      subvalue += queue;
      queue = "";
      content = "";
      while (++index3 < length) {
        character = value.charAt(index3);
        if (!character || character === lineFeed$e) {
          break;
        }
        if (character !== space$f && character !== tab$a && character !== numberSign) {
          content += queue + character;
          queue = "";
          continue;
        }
        while (character === space$f || character === tab$a) {
          queue += character;
          character = value.charAt(++index3);
        }
        if (!pedantic && content && !queue && character === numberSign) {
          content += character;
          continue;
        }
        while (character === numberSign) {
          queue += character;
          character = value.charAt(++index3);
        }
        while (character === space$f || character === tab$a) {
          queue += character;
          character = value.charAt(++index3);
        }
        index3--;
      }
      now.column += subvalue.length;
      now.offset += subvalue.length;
      subvalue += content + queue;
      return eat(subvalue)({
        type: "heading",
        depth,
        children: self2.tokenizeInline(content, now)
      });
    }
    var thematicBreak_1$1 = thematicBreak$1;
    var tab$9 = "	";
    var lineFeed$d = "\n";
    var space$e = " ";
    var asterisk$4 = "*";
    var dash$7 = "-";
    var underscore$6 = "_";
    var maxCount = 3;
    function thematicBreak$1(eat, value, silent) {
      var index3 = -1;
      var length = value.length + 1;
      var subvalue = "";
      var character;
      var marker2;
      var markerCount;
      var queue;
      while (++index3 < length) {
        character = value.charAt(index3);
        if (character !== tab$9 && character !== space$e) {
          break;
        }
        subvalue += character;
      }
      if (character !== asterisk$4 && character !== dash$7 && character !== underscore$6) {
        return;
      }
      marker2 = character;
      subvalue += character;
      markerCount = 1;
      queue = "";
      while (++index3 < length) {
        character = value.charAt(index3);
        if (character === marker2) {
          markerCount++;
          subvalue += queue + marker2;
          queue = "";
        } else if (character === space$e) {
          queue += character;
        } else if (markerCount >= maxCount && (!character || character === lineFeed$d)) {
          subvalue += queue;
          if (silent) {
            return true;
          }
          return eat(subvalue)({ type: "thematicBreak" });
        } else {
          return;
        }
      }
    }
    var getIndentation = indentation$1;
    var tab$8 = "	";
    var space$d = " ";
    var spaceSize = 1;
    var tabSize$2 = 4;
    function indentation$1(value) {
      var index3 = 0;
      var indent = 0;
      var character = value.charAt(index3);
      var stops = {};
      var size;
      var lastIndent = 0;
      while (character === tab$8 || character === space$d) {
        size = character === tab$8 ? tabSize$2 : spaceSize;
        indent += size;
        if (size > 1) {
          indent = Math.floor(indent / size) * size;
        }
        while (lastIndent < indent) {
          stops[++lastIndent] = index3;
        }
        character = value.charAt(++index3);
      }
      return { indent, stops };
    }
    var removeIndentation = indentation;
    var lineFeed$c = "\n";
    var space$c = " ";
    var exclamationMark$4 = "!";
    function indentation(value, maximum) {
      var values2 = value.split(lineFeed$c);
      var position2 = values2.length + 1;
      var minIndent = Infinity;
      var matrix = [];
      var index3;
      var indentation2;
      var stops;
      values2.unshift(repeatString(space$c, maximum) + exclamationMark$4);
      while (position2--) {
        indentation2 = getIndentation(values2[position2]);
        matrix[position2] = indentation2.stops;
        if (trim_1(values2[position2]).length === 0) {
          continue;
        }
        if (indentation2.indent) {
          if (indentation2.indent > 0 && indentation2.indent < minIndent) {
            minIndent = indentation2.indent;
          }
        } else {
          minIndent = Infinity;
          break;
        }
      }
      if (minIndent !== Infinity) {
        position2 = values2.length;
        while (position2--) {
          stops = matrix[position2];
          index3 = minIndent;
          while (index3 && !(index3 in stops)) {
            index3--;
          }
          values2[position2] = values2[position2].slice(stops[index3] + 1);
        }
      }
      values2.shift();
      return values2.join(lineFeed$c);
    }
    var list_1$1 = list$1;
    var asterisk$3 = "*";
    var underscore$5 = "_";
    var plusSign$2 = "+";
    var dash$6 = "-";
    var dot$3 = ".";
    var space$b = " ";
    var lineFeed$b = "\n";
    var tab$7 = "	";
    var rightParenthesis$3 = ")";
    var lowercaseX = "x";
    var tabSize$1 = 4;
    var looseListItemExpression = /\n\n(?!\s*$)/;
    var taskItemExpression = /^\[([ X\tx])][ \t]/;
    var bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
    var pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
    var initialIndentExpression = /^( {1,4}|\t)?/gm;
    function list$1(eat, value, silent) {
      var self2 = this;
      var commonmark2 = self2.options.commonmark;
      var pedantic = self2.options.pedantic;
      var tokenizers = self2.blockTokenizers;
      var interuptors = self2.interruptList;
      var index3 = 0;
      var length = value.length;
      var start2 = null;
      var size;
      var queue;
      var ordered;
      var character;
      var marker2;
      var nextIndex;
      var startIndex;
      var prefixed;
      var currentMarker;
      var content;
      var line2;
      var previousEmpty;
      var empty3;
      var items;
      var allLines;
      var emptyLines;
      var item;
      var enterTop;
      var exitBlockquote;
      var spread = false;
      var node;
      var now;
      var end2;
      var indented;
      while (index3 < length) {
        character = value.charAt(index3);
        if (character !== tab$7 && character !== space$b) {
          break;
        }
        index3++;
      }
      character = value.charAt(index3);
      if (character === asterisk$3 || character === plusSign$2 || character === dash$6) {
        marker2 = character;
        ordered = false;
      } else {
        ordered = true;
        queue = "";
        while (index3 < length) {
          character = value.charAt(index3);
          if (!isDecimal(character)) {
            break;
          }
          queue += character;
          index3++;
        }
        character = value.charAt(index3);
        if (!queue || !(character === dot$3 || commonmark2 && character === rightParenthesis$3)) {
          return;
        }
        if (silent && queue !== "1") {
          return;
        }
        start2 = parseInt(queue, 10);
        marker2 = character;
      }
      character = value.charAt(++index3);
      if (character !== space$b && character !== tab$7 && (pedantic || character !== lineFeed$b && character !== "")) {
        return;
      }
      if (silent) {
        return true;
      }
      index3 = 0;
      items = [];
      allLines = [];
      emptyLines = [];
      while (index3 < length) {
        nextIndex = value.indexOf(lineFeed$b, index3);
        startIndex = index3;
        prefixed = false;
        indented = false;
        if (nextIndex === -1) {
          nextIndex = length;
        }
        size = 0;
        while (index3 < length) {
          character = value.charAt(index3);
          if (character === tab$7) {
            size += tabSize$1 - size % tabSize$1;
          } else if (character === space$b) {
            size++;
          } else {
            break;
          }
          index3++;
        }
        if (item && size >= item.indent) {
          indented = true;
        }
        character = value.charAt(index3);
        currentMarker = null;
        if (!indented) {
          if (character === asterisk$3 || character === plusSign$2 || character === dash$6) {
            currentMarker = character;
            index3++;
            size++;
          } else {
            queue = "";
            while (index3 < length) {
              character = value.charAt(index3);
              if (!isDecimal(character)) {
                break;
              }
              queue += character;
              index3++;
            }
            character = value.charAt(index3);
            index3++;
            if (queue && (character === dot$3 || commonmark2 && character === rightParenthesis$3)) {
              currentMarker = character;
              size += queue.length + 1;
            }
          }
          if (currentMarker) {
            character = value.charAt(index3);
            if (character === tab$7) {
              size += tabSize$1 - size % tabSize$1;
              index3++;
            } else if (character === space$b) {
              end2 = index3 + tabSize$1;
              while (index3 < end2) {
                if (value.charAt(index3) !== space$b) {
                  break;
                }
                index3++;
                size++;
              }
              if (index3 === end2 && value.charAt(index3) === space$b) {
                index3 -= tabSize$1 - 1;
                size -= tabSize$1 - 1;
              }
            } else if (character !== lineFeed$b && character !== "") {
              currentMarker = null;
            }
          }
        }
        if (currentMarker) {
          if (!pedantic && marker2 !== currentMarker) {
            break;
          }
          prefixed = true;
        } else {
          if (!commonmark2 && !indented && value.charAt(startIndex) === space$b) {
            indented = true;
          } else if (commonmark2 && item) {
            indented = size >= item.indent || size > tabSize$1;
          }
          prefixed = false;
          index3 = startIndex;
        }
        line2 = value.slice(startIndex, nextIndex);
        content = startIndex === index3 ? line2 : value.slice(index3, nextIndex);
        if (currentMarker === asterisk$3 || currentMarker === underscore$5 || currentMarker === dash$6) {
          if (tokenizers.thematicBreak.call(self2, eat, line2, true)) {
            break;
          }
        }
        previousEmpty = empty3;
        empty3 = !prefixed && !trim_1(content).length;
        if (indented && item) {
          item.value = item.value.concat(emptyLines, line2);
          allLines = allLines.concat(emptyLines, line2);
          emptyLines = [];
        } else if (prefixed) {
          if (emptyLines.length !== 0) {
            spread = true;
            item.value.push("");
            item.trail = emptyLines.concat();
          }
          item = {
            value: [line2],
            indent: size,
            trail: []
          };
          items.push(item);
          allLines = allLines.concat(emptyLines, line2);
          emptyLines = [];
        } else if (empty3) {
          if (previousEmpty && !commonmark2) {
            break;
          }
          emptyLines.push(line2);
        } else {
          if (previousEmpty) {
            break;
          }
          if (interrupt_1(interuptors, tokenizers, self2, [eat, line2, true])) {
            break;
          }
          item.value = item.value.concat(emptyLines, line2);
          allLines = allLines.concat(emptyLines, line2);
          emptyLines = [];
        }
        index3 = nextIndex + 1;
      }
      node = eat(allLines.join(lineFeed$b)).reset({
        type: "list",
        ordered,
        start: start2,
        spread,
        children: []
      });
      enterTop = self2.enterList();
      exitBlockquote = self2.enterBlock();
      index3 = -1;
      length = items.length;
      while (++index3 < length) {
        item = items[index3].value.join(lineFeed$b);
        now = eat.now();
        eat(item)(listItem$2(self2, item, now), node);
        item = items[index3].trail.join(lineFeed$b);
        if (index3 !== length - 1) {
          item += lineFeed$b;
        }
        eat(item);
      }
      enterTop();
      exitBlockquote();
      return node;
    }
    function listItem$2(ctx, value, position2) {
      var offsets = ctx.offset;
      var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;
      var checked = null;
      var task;
      var indent;
      value = fn.apply(null, arguments);
      if (ctx.options.gfm) {
        task = value.match(taskItemExpression);
        if (task) {
          indent = task[0].length;
          checked = task[1].toLowerCase() === lowercaseX;
          offsets[position2.line] += indent;
          value = value.slice(indent);
        }
      }
      return {
        type: "listItem",
        spread: looseListItemExpression.test(value),
        checked,
        children: ctx.tokenizeBlock(value, position2)
      };
    }
    function pedanticListItem(ctx, value, position2) {
      var offsets = ctx.offset;
      var line2 = position2.line;
      value = value.replace(pedanticBulletExpression, replacer);
      line2 = position2.line;
      return value.replace(initialIndentExpression, replacer);
      function replacer($0) {
        offsets[line2] = (offsets[line2] || 0) + $0.length;
        line2++;
        return "";
      }
    }
    function normalListItem(ctx, value, position2) {
      var offsets = ctx.offset;
      var line2 = position2.line;
      var max;
      var bullet2;
      var rest;
      var lines;
      var trimmedLines;
      var index3;
      var length;
      value = value.replace(bulletExpression, replacer);
      lines = value.split(lineFeed$b);
      trimmedLines = removeIndentation(value, getIndentation(max).indent).split(lineFeed$b);
      trimmedLines[0] = rest;
      offsets[line2] = (offsets[line2] || 0) + bullet2.length;
      line2++;
      index3 = 0;
      length = lines.length;
      while (++index3 < length) {
        offsets[line2] = (offsets[line2] || 0) + lines[index3].length - trimmedLines[index3].length;
        line2++;
      }
      return trimmedLines.join(lineFeed$b);
      function replacer($0, $1, $2, $3, $4) {
        bullet2 = $1 + $2 + $3;
        rest = $4;
        if (Number($2) < 10 && bullet2.length % 2 === 1) {
          $2 = space$b + $2;
        }
        max = $1 + repeatString(space$b, $2.length) + $3;
        return max + rest;
      }
    }
    var headingSetext = setextHeading;
    var lineFeed$a = "\n";
    var tab$6 = "	";
    var space$a = " ";
    var equalsTo$1 = "=";
    var dash$5 = "-";
    var maxIndent = 3;
    var equalsToDepth = 1;
    var dashDepth = 2;
    function setextHeading(eat, value, silent) {
      var self2 = this;
      var now = eat.now();
      var length = value.length;
      var index3 = -1;
      var subvalue = "";
      var content;
      var queue;
      var character;
      var marker2;
      var depth;
      while (++index3 < length) {
        character = value.charAt(index3);
        if (character !== space$a || index3 >= maxIndent) {
          index3--;
          break;
        }
        subvalue += character;
      }
      content = "";
      queue = "";
      while (++index3 < length) {
        character = value.charAt(index3);
        if (character === lineFeed$a) {
          index3--;
          break;
        }
        if (character === space$a || character === tab$6) {
          queue += character;
        } else {
          content += queue + character;
          queue = "";
        }
      }
      now.column += subvalue.length;
      now.offset += subvalue.length;
      subvalue += content + queue;
      character = value.charAt(++index3);
      marker2 = value.charAt(++index3);
      if (character !== lineFeed$a || marker2 !== equalsTo$1 && marker2 !== dash$5) {
        return;
      }
      subvalue += character;
      queue = marker2;
      depth = marker2 === equalsTo$1 ? equalsToDepth : dashDepth;
      while (++index3 < length) {
        character = value.charAt(index3);
        if (character !== marker2) {
          if (character !== lineFeed$a) {
            return;
          }
          index3--;
          break;
        }
        queue += character;
      }
      if (silent) {
        return true;
      }
      return eat(subvalue + queue)({
        type: "heading",
        depth,
        children: self2.tokenizeInline(content, now)
      });
    }
    var attributeName$2 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted$2 = "[^\"'=<>`\\u0000-\\u0020]+";
    var singleQuoted$2 = "'[^']*'";
    var doubleQuoted$2 = '"[^"]*"';
    var attributeValue$2 = "(?:" + unquoted$2 + "|" + singleQuoted$2 + "|" + doubleQuoted$2 + ")";
    var attribute$2 = "(?:\\s+" + attributeName$2 + "(?:\\s*=\\s*" + attributeValue$2 + ")?)";
    var openTag$1 = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute$2 + "*\\s*\\/?>";
    var closeTag$1 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment$1 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?].*?[?]>";
    var declaration = "<![A-Za-z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var openCloseTag$2 = new RegExp("^(?:" + openTag$1 + "|" + closeTag$1 + ")");
    var tag$2 = new RegExp("^(?:" + openTag$1 + "|" + closeTag$1 + "|" + comment$1 + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var html$4 = {
      openCloseTag: openCloseTag$2,
      tag: tag$2
    };
    var openCloseTag$1 = html$4.openCloseTag;
    var htmlBlock = blockHtml$1;
    var tab$5 = "	";
    var space$9 = " ";
    var lineFeed$9 = "\n";
    var lessThan$7 = "<";
    var rawOpenExpression$1 = /^<(script|pre|style)(?=(\s|>|$))/i;
    var rawCloseExpression$1 = /<\/(script|pre|style)>/i;
    var commentOpenExpression$1 = /^<!--/;
    var commentCloseExpression$1 = /-->/;
    var instructionOpenExpression$1 = /^<\?/;
    var instructionCloseExpression$1 = /\?>/;
    var directiveOpenExpression$1 = /^<![A-Za-z]/;
    var directiveCloseExpression$1 = />/;
    var cdataOpenExpression$1 = /^<!\[CDATA\[/;
    var cdataCloseExpression$1 = /]]>/;
    var elementCloseExpression$1 = /^$/;
    var otherElementOpenExpression$1 = new RegExp(openCloseTag$1.source + "\\s*$");
    function blockHtml$1(eat, value, silent) {
      var self2 = this;
      var blocks = self2.options.blocks.join("|");
      var elementOpenExpression = new RegExp("^</?(" + blocks + ")(?=(\\s|/?>|$))", "i");
      var length = value.length;
      var index3 = 0;
      var next;
      var line2;
      var offset;
      var character;
      var count;
      var sequence;
      var subvalue;
      var sequences = [
        [rawOpenExpression$1, rawCloseExpression$1, true],
        [commentOpenExpression$1, commentCloseExpression$1, true],
        [instructionOpenExpression$1, instructionCloseExpression$1, true],
        [directiveOpenExpression$1, directiveCloseExpression$1, true],
        [cdataOpenExpression$1, cdataCloseExpression$1, true],
        [elementOpenExpression, elementCloseExpression$1, true],
        [otherElementOpenExpression$1, elementCloseExpression$1, false]
      ];
      while (index3 < length) {
        character = value.charAt(index3);
        if (character !== tab$5 && character !== space$9) {
          break;
        }
        index3++;
      }
      if (value.charAt(index3) !== lessThan$7) {
        return;
      }
      next = value.indexOf(lineFeed$9, index3 + 1);
      next = next === -1 ? length : next;
      line2 = value.slice(index3, next);
      offset = -1;
      count = sequences.length;
      while (++offset < count) {
        if (sequences[offset][0].test(line2)) {
          sequence = sequences[offset];
          break;
        }
      }
      if (!sequence) {
        return;
      }
      if (silent) {
        return sequence[2];
      }
      index3 = next;
      if (!sequence[1].test(line2)) {
        while (index3 < length) {
          next = value.indexOf(lineFeed$9, index3 + 1);
          next = next === -1 ? length : next;
          line2 = value.slice(index3 + 1, next);
          if (sequence[1].test(line2)) {
            if (line2) {
              index3 = next;
            }
            break;
          }
          index3 = next;
        }
      }
      subvalue = value.slice(0, index3);
      return eat(subvalue)({ type: "html", value: subvalue });
    }
    var isWhitespaceCharacter = whitespace$1;
    var fromCode$1 = String.fromCharCode;
    var re$2 = /\s/;
    function whitespace$1(character) {
      return re$2.test(typeof character === "number" ? fromCode$1(character) : character.charAt(0));
    }
    var collapseWhiteSpace = collapse;
    function collapse(value) {
      return String(value).replace(/\s+/g, " ");
    }
    var normalize_1$1 = normalize$1;
    function normalize$1(value) {
      return collapseWhiteSpace(value).toLowerCase();
    }
    var definition_1 = definition;
    var quotationMark$2 = '"';
    var apostrophe$3 = "'";
    var backslash$6 = "\\";
    var lineFeed$8 = "\n";
    var tab$4 = "	";
    var space$8 = " ";
    var leftSquareBracket$2 = "[";
    var rightSquareBracket$2 = "]";
    var leftParenthesis$1 = "(";
    var rightParenthesis$2 = ")";
    var colon$2 = ":";
    var lessThan$6 = "<";
    var greaterThan$3 = ">";
    function definition(eat, value, silent) {
      var self2 = this;
      var commonmark2 = self2.options.commonmark;
      var index3 = 0;
      var length = value.length;
      var subvalue = "";
      var beforeURL;
      var beforeTitle;
      var queue;
      var character;
      var test;
      var identifier;
      var url2;
      var title;
      while (index3 < length) {
        character = value.charAt(index3);
        if (character !== space$8 && character !== tab$4) {
          break;
        }
        subvalue += character;
        index3++;
      }
      character = value.charAt(index3);
      if (character !== leftSquareBracket$2) {
        return;
      }
      index3++;
      subvalue += character;
      queue = "";
      while (index3 < length) {
        character = value.charAt(index3);
        if (character === rightSquareBracket$2) {
          break;
        } else if (character === backslash$6) {
          queue += character;
          index3++;
          character = value.charAt(index3);
        }
        queue += character;
        index3++;
      }
      if (!queue || value.charAt(index3) !== rightSquareBracket$2 || value.charAt(index3 + 1) !== colon$2) {
        return;
      }
      identifier = queue;
      subvalue += queue + rightSquareBracket$2 + colon$2;
      index3 = subvalue.length;
      queue = "";
      while (index3 < length) {
        character = value.charAt(index3);
        if (character !== tab$4 && character !== space$8 && character !== lineFeed$8) {
          break;
        }
        subvalue += character;
        index3++;
      }
      character = value.charAt(index3);
      queue = "";
      beforeURL = subvalue;
      if (character === lessThan$6) {
        index3++;
        while (index3 < length) {
          character = value.charAt(index3);
          if (!isEnclosedURLCharacter(character)) {
            break;
          }
          queue += character;
          index3++;
        }
        character = value.charAt(index3);
        if (character === isEnclosedURLCharacter.delimiter) {
          subvalue += lessThan$6 + queue + character;
          index3++;
        } else {
          if (commonmark2) {
            return;
          }
          index3 -= queue.length + 1;
          queue = "";
        }
      }
      if (!queue) {
        while (index3 < length) {
          character = value.charAt(index3);
          if (!isUnclosedURLCharacter(character)) {
            break;
          }
          queue += character;
          index3++;
        }
        subvalue += queue;
      }
      if (!queue) {
        return;
      }
      url2 = queue;
      queue = "";
      while (index3 < length) {
        character = value.charAt(index3);
        if (character !== tab$4 && character !== space$8 && character !== lineFeed$8) {
          break;
        }
        queue += character;
        index3++;
      }
      character = value.charAt(index3);
      test = null;
      if (character === quotationMark$2) {
        test = quotationMark$2;
      } else if (character === apostrophe$3) {
        test = apostrophe$3;
      } else if (character === leftParenthesis$1) {
        test = rightParenthesis$2;
      }
      if (!test) {
        queue = "";
        index3 = subvalue.length;
      } else if (queue) {
        subvalue += queue + character;
        index3 = subvalue.length;
        queue = "";
        while (index3 < length) {
          character = value.charAt(index3);
          if (character === test) {
            break;
          }
          if (character === lineFeed$8) {
            index3++;
            character = value.charAt(index3);
            if (character === lineFeed$8 || character === test) {
              return;
            }
            queue += lineFeed$8;
          }
          queue += character;
          index3++;
        }
        character = value.charAt(index3);
        if (character !== test) {
          return;
        }
        beforeTitle = subvalue;
        subvalue += queue + character;
        index3++;
        title = queue;
        queue = "";
      } else {
        return;
      }
      while (index3 < length) {
        character = value.charAt(index3);
        if (character !== tab$4 && character !== space$8) {
          break;
        }
        subvalue += character;
        index3++;
      }
      character = value.charAt(index3);
      if (!character || character === lineFeed$8) {
        if (silent) {
          return true;
        }
        beforeURL = eat(beforeURL).test().end;
        url2 = self2.decode.raw(self2.unescape(url2), beforeURL, { nonTerminated: false });
        if (title) {
          beforeTitle = eat(beforeTitle).test().end;
          title = self2.decode.raw(self2.unescape(title), beforeTitle);
        }
        return eat(subvalue)({
          type: "definition",
          identifier: normalize_1$1(identifier),
          label: identifier,
          title: title || null,
          url: url2
        });
      }
    }
    function isEnclosedURLCharacter(character) {
      return character !== greaterThan$3 && character !== leftSquareBracket$2 && character !== rightSquareBracket$2;
    }
    isEnclosedURLCharacter.delimiter = greaterThan$3;
    function isUnclosedURLCharacter(character) {
      return character !== leftSquareBracket$2 && character !== rightSquareBracket$2 && !isWhitespaceCharacter(character);
    }
    var table_1$1 = table$1;
    var tab$3 = "	";
    var lineFeed$7 = "\n";
    var space$7 = " ";
    var dash$4 = "-";
    var colon$1 = ":";
    var backslash$5 = "\\";
    var verticalBar = "|";
    var minColumns = 1;
    var minRows = 2;
    var left = "left";
    var center = "center";
    var right = "right";
    function table$1(eat, value, silent) {
      var self2 = this;
      var index3;
      var alignments;
      var alignment;
      var subvalue;
      var row;
      var length;
      var lines;
      var queue;
      var character;
      var hasDash;
      var align;
      var cell;
      var preamble;
      var now;
      var position2;
      var lineCount;
      var line2;
      var rows;
      var table2;
      var lineIndex;
      var pipeIndex;
      var first2;
      if (!self2.options.gfm) {
        return;
      }
      index3 = 0;
      lineCount = 0;
      length = value.length + 1;
      lines = [];
      while (index3 < length) {
        lineIndex = value.indexOf(lineFeed$7, index3);
        pipeIndex = value.indexOf(verticalBar, index3 + 1);
        if (lineIndex === -1) {
          lineIndex = value.length;
        }
        if (pipeIndex === -1 || pipeIndex > lineIndex) {
          if (lineCount < minRows) {
            return;
          }
          break;
        }
        lines.push(value.slice(index3, lineIndex));
        lineCount++;
        index3 = lineIndex + 1;
      }
      subvalue = lines.join(lineFeed$7);
      alignments = lines.splice(1, 1)[0] || [];
      index3 = 0;
      length = alignments.length;
      lineCount--;
      alignment = false;
      align = [];
      while (index3 < length) {
        character = alignments.charAt(index3);
        if (character === verticalBar) {
          hasDash = null;
          if (alignment === false) {
            if (first2 === false) {
              return;
            }
          } else {
            align.push(alignment);
            alignment = false;
          }
          first2 = false;
        } else if (character === dash$4) {
          hasDash = true;
          alignment = alignment || null;
        } else if (character === colon$1) {
          if (alignment === left) {
            alignment = center;
          } else if (hasDash && alignment === null) {
            alignment = right;
          } else {
            alignment = left;
          }
        } else if (!isWhitespaceCharacter(character)) {
          return;
        }
        index3++;
      }
      if (alignment !== false) {
        align.push(alignment);
      }
      if (align.length < minColumns) {
        return;
      }
      if (silent) {
        return true;
      }
      position2 = -1;
      rows = [];
      table2 = eat(subvalue).reset({ type: "table", align, children: rows });
      while (++position2 < lineCount) {
        line2 = lines[position2];
        row = { type: "tableRow", children: [] };
        if (position2) {
          eat(lineFeed$7);
        }
        eat(line2).reset(row, table2);
        length = line2.length + 1;
        index3 = 0;
        queue = "";
        cell = "";
        preamble = true;
        while (index3 < length) {
          character = line2.charAt(index3);
          if (character === tab$3 || character === space$7) {
            if (cell) {
              queue += character;
            } else {
              eat(character);
            }
            index3++;
            continue;
          }
          if (character === "" || character === verticalBar) {
            if (preamble) {
              eat(character);
            } else {
              if ((cell || character) && !preamble) {
                subvalue = cell;
                if (queue.length > 1) {
                  if (character) {
                    subvalue += queue.slice(0, -1);
                    queue = queue.charAt(queue.length - 1);
                  } else {
                    subvalue += queue;
                    queue = "";
                  }
                }
                now = eat.now();
                eat(subvalue)({ type: "tableCell", children: self2.tokenizeInline(cell, now) }, row);
              }
              eat(queue + character);
              queue = "";
              cell = "";
            }
          } else {
            if (queue) {
              cell += queue;
              queue = "";
            }
            cell += character;
            if (character === backslash$5 && index3 !== length - 2) {
              cell += line2.charAt(index3 + 1);
              index3++;
            }
          }
          preamble = false;
          index3++;
        }
        if (!position2) {
          eat(lineFeed$7 + alignments);
        }
      }
      return table2;
    }
    var paragraph_1$1 = paragraph$1;
    var tab$2 = "	";
    var lineFeed$6 = "\n";
    var space$6 = " ";
    var tabSize = 4;
    function paragraph$1(eat, value, silent) {
      var self2 = this;
      var settings = self2.options;
      var commonmark2 = settings.commonmark;
      var tokenizers = self2.blockTokenizers;
      var interruptors = self2.interruptParagraph;
      var index3 = value.indexOf(lineFeed$6);
      var length = value.length;
      var position2;
      var subvalue;
      var character;
      var size;
      var now;
      while (index3 < length) {
        if (index3 === -1) {
          index3 = length;
          break;
        }
        if (value.charAt(index3 + 1) === lineFeed$6) {
          break;
        }
        if (commonmark2) {
          size = 0;
          position2 = index3 + 1;
          while (position2 < length) {
            character = value.charAt(position2);
            if (character === tab$2) {
              size = tabSize;
              break;
            } else if (character === space$6) {
              size++;
            } else {
              break;
            }
            position2++;
          }
          if (size >= tabSize && character !== lineFeed$6) {
            index3 = value.indexOf(lineFeed$6, index3 + 1);
            continue;
          }
        }
        subvalue = value.slice(index3 + 1);
        if (interrupt_1(interruptors, tokenizers, self2, [eat, subvalue, true])) {
          break;
        }
        position2 = index3;
        index3 = value.indexOf(lineFeed$6, index3 + 1);
        if (index3 !== -1 && trim_1(value.slice(position2, index3)) === "") {
          index3 = position2;
          break;
        }
      }
      subvalue = value.slice(0, index3);
      if (silent) {
        return true;
      }
      now = eat.now();
      subvalue = trimTrailingLines_1(subvalue);
      return eat(subvalue)({
        type: "paragraph",
        children: self2.tokenizeInline(subvalue, now)
      });
    }
    var _escape$1 = locate$9;
    function locate$9(value, fromIndex) {
      return value.indexOf("\\", fromIndex);
    }
    var _escape = escape$1;
    escape$1.locator = _escape$1;
    var lineFeed$5 = "\n";
    var backslash$4 = "\\";
    function escape$1(eat, value, silent) {
      var self2 = this;
      var character;
      var node;
      if (value.charAt(0) === backslash$4) {
        character = value.charAt(1);
        if (self2.escape.indexOf(character) !== -1) {
          if (silent) {
            return true;
          }
          if (character === lineFeed$5) {
            node = { type: "break" };
          } else {
            node = { type: "text", value: character };
          }
          return eat(backslash$4 + character)(node);
        }
      }
    }
    var tag$1 = locate$8;
    function locate$8(value, fromIndex) {
      return value.indexOf("<", fromIndex);
    }
    var autoLink_1 = autoLink;
    autoLink.locator = tag$1;
    autoLink.notInLink = true;
    var lessThan$5 = "<";
    var greaterThan$2 = ">";
    var atSign$1 = "@";
    var slash$3 = "/";
    var mailto = "mailto:";
    var mailtoLength = mailto.length;
    function autoLink(eat, value, silent) {
      var self2 = this;
      var subvalue = "";
      var length = value.length;
      var index3 = 0;
      var queue = "";
      var hasAtCharacter = false;
      var link2 = "";
      var character;
      var now;
      var content;
      var tokenizers;
      var exit;
      if (value.charAt(0) !== lessThan$5) {
        return;
      }
      index3++;
      subvalue = lessThan$5;
      while (index3 < length) {
        character = value.charAt(index3);
        if (isWhitespaceCharacter(character) || character === greaterThan$2 || character === atSign$1 || character === ":" && value.charAt(index3 + 1) === slash$3) {
          break;
        }
        queue += character;
        index3++;
      }
      if (!queue) {
        return;
      }
      link2 += queue;
      queue = "";
      character = value.charAt(index3);
      link2 += character;
      index3++;
      if (character === atSign$1) {
        hasAtCharacter = true;
      } else {
        if (character !== ":" || value.charAt(index3 + 1) !== slash$3) {
          return;
        }
        link2 += slash$3;
        index3++;
      }
      while (index3 < length) {
        character = value.charAt(index3);
        if (isWhitespaceCharacter(character) || character === greaterThan$2) {
          break;
        }
        queue += character;
        index3++;
      }
      character = value.charAt(index3);
      if (!queue || character !== greaterThan$2) {
        return;
      }
      if (silent) {
        return true;
      }
      link2 += queue;
      content = link2;
      subvalue += link2 + character;
      now = eat.now();
      now.column++;
      now.offset++;
      if (hasAtCharacter) {
        if (link2.slice(0, mailtoLength).toLowerCase() === mailto) {
          content = content.slice(mailtoLength);
          now.column += mailtoLength;
          now.offset += mailtoLength;
        } else {
          link2 = mailto + link2;
        }
      }
      tokenizers = self2.inlineTokenizers;
      self2.inlineTokenizers = { text: tokenizers.text };
      exit = self2.enterLink();
      content = self2.tokenizeInline(content, now);
      self2.inlineTokenizers = tokenizers;
      exit();
      return eat(subvalue)({
        type: "link",
        title: null,
        url: parseEntities_1(link2, { nonTerminated: false }),
        children: content
      });
    }
    var ccount_1 = ccount;
    function ccount(value, character) {
      var val = String(value);
      var count = 0;
      var index3;
      if (typeof character !== "string" || character.length !== 1) {
        throw new Error("Expected character");
      }
      index3 = val.indexOf(character);
      while (index3 !== -1) {
        count++;
        index3 = val.indexOf(character, index3 + 1);
      }
      return count;
    }
    var url$1 = locate$7;
    var values = ["www.", "http://", "https://"];
    function locate$7(value, fromIndex) {
      var min = -1;
      var index3;
      var length;
      var position2;
      if (!this.options.gfm) {
        return min;
      }
      length = values.length;
      index3 = -1;
      while (++index3 < length) {
        position2 = value.indexOf(values[index3], fromIndex);
        if (position2 !== -1 && (min === -1 || position2 < min)) {
          min = position2;
        }
      }
      return min;
    }
    var url_1 = url;
    url.locator = url$1;
    url.notInLink = true;
    var exclamationMark$3 = 33;
    var ampersand = 38;
    var rightParenthesis$1 = 41;
    var asterisk$2 = 42;
    var comma$1 = 44;
    var dash$3 = 45;
    var dot$2 = 46;
    var colon = 58;
    var semicolon = 59;
    var questionMark$1 = 63;
    var lessThan$4 = 60;
    var underscore$4 = 95;
    var tilde$2 = 126;
    var leftParenthesisCharacter = "(";
    var rightParenthesisCharacter = ")";
    function url(eat, value, silent) {
      var self2 = this;
      var gfm2 = self2.options.gfm;
      var tokenizers = self2.inlineTokenizers;
      var length = value.length;
      var previousDot = -1;
      var protocolless = false;
      var dots;
      var lastTwoPartsStart;
      var start2;
      var index3;
      var pathStart;
      var path3;
      var code2;
      var end2;
      var leftCount;
      var rightCount;
      var content;
      var children;
      var url2;
      var exit;
      if (!gfm2) {
        return;
      }
      if (value.slice(0, 4) === "www.") {
        protocolless = true;
        index3 = 4;
      } else if (value.slice(0, 7).toLowerCase() === "http://") {
        index3 = 7;
      } else if (value.slice(0, 8).toLowerCase() === "https://") {
        index3 = 8;
      } else {
        return;
      }
      previousDot = index3 - 1;
      start2 = index3;
      dots = [];
      while (index3 < length) {
        code2 = value.charCodeAt(index3);
        if (code2 === dot$2) {
          if (previousDot === index3 - 1) {
            break;
          }
          dots.push(index3);
          previousDot = index3;
          index3++;
          continue;
        }
        if (isDecimal(code2) || isAlphabetical(code2) || code2 === dash$3 || code2 === underscore$4) {
          index3++;
          continue;
        }
        break;
      }
      if (code2 === dot$2) {
        dots.pop();
        index3--;
      }
      if (dots[0] === void 0) {
        return;
      }
      lastTwoPartsStart = dots.length < 2 ? start2 : dots[dots.length - 2] + 1;
      if (value.slice(lastTwoPartsStart, index3).indexOf("_") !== -1) {
        return;
      }
      if (silent) {
        return true;
      }
      end2 = index3;
      pathStart = index3;
      while (index3 < length) {
        code2 = value.charCodeAt(index3);
        if (isWhitespaceCharacter(code2) || code2 === lessThan$4) {
          break;
        }
        index3++;
        if (code2 === exclamationMark$3 || code2 === asterisk$2 || code2 === comma$1 || code2 === dot$2 || code2 === colon || code2 === questionMark$1 || code2 === underscore$4 || code2 === tilde$2)
          ;
        else {
          end2 = index3;
        }
      }
      index3 = end2;
      if (value.charCodeAt(index3 - 1) === rightParenthesis$1) {
        path3 = value.slice(pathStart, index3);
        leftCount = ccount_1(path3, leftParenthesisCharacter);
        rightCount = ccount_1(path3, rightParenthesisCharacter);
        while (rightCount > leftCount) {
          index3 = pathStart + path3.lastIndexOf(rightParenthesisCharacter);
          path3 = value.slice(pathStart, index3);
          rightCount--;
        }
      }
      if (value.charCodeAt(index3 - 1) === semicolon) {
        index3--;
        if (isAlphabetical(value.charCodeAt(index3 - 1))) {
          end2 = index3 - 2;
          while (isAlphabetical(value.charCodeAt(end2))) {
            end2--;
          }
          if (value.charCodeAt(end2) === ampersand) {
            index3 = end2;
          }
        }
      }
      content = value.slice(0, index3);
      url2 = parseEntities_1(content, { nonTerminated: false });
      if (protocolless) {
        url2 = "http://" + url2;
      }
      exit = self2.enterLink();
      self2.inlineTokenizers = { text: tokenizers.text };
      children = self2.tokenizeInline(content, eat.now());
      self2.inlineTokenizers = tokenizers;
      exit();
      return eat(content)({ type: "link", title: null, url: url2, children });
    }
    var plusSign$1 = 43;
    var dash$2 = 45;
    var dot$1 = 46;
    var underscore$3 = 95;
    var email$1 = locate$6;
    function locate$6(value, fromIndex) {
      var self2 = this;
      var at;
      var position2;
      if (!this.options.gfm) {
        return -1;
      }
      at = value.indexOf("@", fromIndex);
      if (at === -1) {
        return -1;
      }
      position2 = at;
      if (position2 === fromIndex || !isGfmAtext(value.charCodeAt(position2 - 1))) {
        return locate$6.call(self2, value, at + 1);
      }
      while (position2 > fromIndex && isGfmAtext(value.charCodeAt(position2 - 1))) {
        position2--;
      }
      return position2;
    }
    function isGfmAtext(code2) {
      return isDecimal(code2) || isAlphabetical(code2) || code2 === plusSign$1 || code2 === dash$2 || code2 === dot$1 || code2 === underscore$3;
    }
    var email_1 = email;
    email.locator = email$1;
    email.notInLink = true;
    var plusSign = 43;
    var dash$1 = 45;
    var dot = 46;
    var atSign = 64;
    var underscore$2 = 95;
    function email(eat, value, silent) {
      var self2 = this;
      var gfm2 = self2.options.gfm;
      var tokenizers = self2.inlineTokenizers;
      var index3 = 0;
      var length = value.length;
      var firstDot = -1;
      var code2;
      var content;
      var children;
      var exit;
      if (!gfm2) {
        return;
      }
      code2 = value.charCodeAt(index3);
      while (isDecimal(code2) || isAlphabetical(code2) || code2 === plusSign || code2 === dash$1 || code2 === dot || code2 === underscore$2) {
        code2 = value.charCodeAt(++index3);
      }
      if (index3 === 0) {
        return;
      }
      if (code2 !== atSign) {
        return;
      }
      index3++;
      while (index3 < length) {
        code2 = value.charCodeAt(index3);
        if (isDecimal(code2) || isAlphabetical(code2) || code2 === dash$1 || code2 === dot || code2 === underscore$2) {
          index3++;
          if (firstDot === -1 && code2 === dot) {
            firstDot = index3;
          }
          continue;
        }
        break;
      }
      if (firstDot === -1 || firstDot === index3 || code2 === dash$1 || code2 === underscore$2) {
        return;
      }
      if (code2 === dot) {
        index3--;
      }
      content = value.slice(0, index3);
      if (silent) {
        return true;
      }
      exit = self2.enterLink();
      self2.inlineTokenizers = { text: tokenizers.text };
      children = self2.tokenizeInline(content, eat.now());
      self2.inlineTokenizers = tokenizers;
      exit();
      return eat(content)({
        type: "link",
        title: null,
        url: "mailto:" + parseEntities_1(content, { nonTerminated: false }),
        children
      });
    }
    var tag = html$4.tag;
    var htmlInline = inlineHTML;
    inlineHTML.locator = tag$1;
    var lessThan$3 = "<";
    var questionMark = "?";
    var exclamationMark$2 = "!";
    var slash$2 = "/";
    var htmlLinkOpenExpression = /^<a /i;
    var htmlLinkCloseExpression = /^<\/a>/i;
    function inlineHTML(eat, value, silent) {
      var self2 = this;
      var length = value.length;
      var character;
      var subvalue;
      if (value.charAt(0) !== lessThan$3 || length < 3) {
        return;
      }
      character = value.charAt(1);
      if (!isAlphabetical(character) && character !== questionMark && character !== exclamationMark$2 && character !== slash$2) {
        return;
      }
      subvalue = value.match(tag);
      if (!subvalue) {
        return;
      }
      if (silent) {
        return true;
      }
      subvalue = subvalue[0];
      if (!self2.inLink && htmlLinkOpenExpression.test(subvalue)) {
        self2.inLink = true;
      } else if (self2.inLink && htmlLinkCloseExpression.test(subvalue)) {
        self2.inLink = false;
      }
      return eat(subvalue)({ type: "html", value: subvalue });
    }
    var link$3 = locate$5;
    function locate$5(value, fromIndex) {
      var link2 = value.indexOf("[", fromIndex);
      var image2 = value.indexOf("![", fromIndex);
      if (image2 === -1) {
        return link2;
      }
      return link2 < image2 ? link2 : image2;
    }
    var link_1$1 = link$2;
    link$2.locator = link$3;
    var lineFeed$4 = "\n";
    var exclamationMark$1 = "!";
    var quotationMark$1 = '"';
    var apostrophe$2 = "'";
    var leftParenthesis = "(";
    var rightParenthesis = ")";
    var lessThan$2 = "<";
    var greaterThan$1 = ">";
    var leftSquareBracket$1 = "[";
    var backslash$3 = "\\";
    var rightSquareBracket$1 = "]";
    var graveAccent$1 = "`";
    function link$2(eat, value, silent) {
      var self2 = this;
      var subvalue = "";
      var index3 = 0;
      var character = value.charAt(0);
      var pedantic = self2.options.pedantic;
      var commonmark2 = self2.options.commonmark;
      var gfm2 = self2.options.gfm;
      var closed;
      var count;
      var opening2;
      var beforeURL;
      var beforeTitle;
      var subqueue;
      var hasMarker;
      var isImage;
      var content;
      var marker2;
      var length;
      var title;
      var depth;
      var queue;
      var url2;
      var now;
      var exit;
      var node;
      if (character === exclamationMark$1) {
        isImage = true;
        subvalue = character;
        character = value.charAt(++index3);
      }
      if (character !== leftSquareBracket$1) {
        return;
      }
      if (!isImage && self2.inLink) {
        return;
      }
      subvalue += character;
      queue = "";
      index3++;
      length = value.length;
      now = eat.now();
      depth = 0;
      now.column += index3;
      now.offset += index3;
      while (index3 < length) {
        character = value.charAt(index3);
        subqueue = character;
        if (character === graveAccent$1) {
          count = 1;
          while (value.charAt(index3 + 1) === graveAccent$1) {
            subqueue += character;
            index3++;
            count++;
          }
          if (!opening2) {
            opening2 = count;
          } else if (count >= opening2) {
            opening2 = 0;
          }
        } else if (character === backslash$3) {
          index3++;
          subqueue += value.charAt(index3);
        } else if ((!opening2 || gfm2) && character === leftSquareBracket$1) {
          depth++;
        } else if ((!opening2 || gfm2) && character === rightSquareBracket$1) {
          if (depth) {
            depth--;
          } else {
            if (value.charAt(index3 + 1) !== leftParenthesis) {
              return;
            }
            subqueue += leftParenthesis;
            closed = true;
            index3++;
            break;
          }
        }
        queue += subqueue;
        subqueue = "";
        index3++;
      }
      if (!closed) {
        return;
      }
      content = queue;
      subvalue += queue + subqueue;
      index3++;
      while (index3 < length) {
        character = value.charAt(index3);
        if (!isWhitespaceCharacter(character)) {
          break;
        }
        subvalue += character;
        index3++;
      }
      character = value.charAt(index3);
      queue = "";
      beforeURL = subvalue;
      if (character === lessThan$2) {
        index3++;
        beforeURL += lessThan$2;
        while (index3 < length) {
          character = value.charAt(index3);
          if (character === greaterThan$1) {
            break;
          }
          if (commonmark2 && character === lineFeed$4) {
            return;
          }
          queue += character;
          index3++;
        }
        if (value.charAt(index3) !== greaterThan$1) {
          return;
        }
        subvalue += lessThan$2 + queue + greaterThan$1;
        url2 = queue;
        index3++;
      } else {
        character = null;
        subqueue = "";
        while (index3 < length) {
          character = value.charAt(index3);
          if (subqueue && (character === quotationMark$1 || character === apostrophe$2 || commonmark2 && character === leftParenthesis)) {
            break;
          }
          if (isWhitespaceCharacter(character)) {
            if (!pedantic) {
              break;
            }
            subqueue += character;
          } else {
            if (character === leftParenthesis) {
              depth++;
            } else if (character === rightParenthesis) {
              if (depth === 0) {
                break;
              }
              depth--;
            }
            queue += subqueue;
            subqueue = "";
            if (character === backslash$3) {
              queue += backslash$3;
              character = value.charAt(++index3);
            }
            queue += character;
          }
          index3++;
        }
        subvalue += queue;
        url2 = queue;
        index3 = subvalue.length;
      }
      queue = "";
      while (index3 < length) {
        character = value.charAt(index3);
        if (!isWhitespaceCharacter(character)) {
          break;
        }
        queue += character;
        index3++;
      }
      character = value.charAt(index3);
      subvalue += queue;
      if (queue && (character === quotationMark$1 || character === apostrophe$2 || commonmark2 && character === leftParenthesis)) {
        index3++;
        subvalue += character;
        queue = "";
        marker2 = character === leftParenthesis ? rightParenthesis : character;
        beforeTitle = subvalue;
        if (commonmark2) {
          while (index3 < length) {
            character = value.charAt(index3);
            if (character === marker2) {
              break;
            }
            if (character === backslash$3) {
              queue += backslash$3;
              character = value.charAt(++index3);
            }
            index3++;
            queue += character;
          }
          character = value.charAt(index3);
          if (character !== marker2) {
            return;
          }
          title = queue;
          subvalue += queue + character;
          index3++;
          while (index3 < length) {
            character = value.charAt(index3);
            if (!isWhitespaceCharacter(character)) {
              break;
            }
            subvalue += character;
            index3++;
          }
        } else {
          subqueue = "";
          while (index3 < length) {
            character = value.charAt(index3);
            if (character === marker2) {
              if (hasMarker) {
                queue += marker2 + subqueue;
                subqueue = "";
              }
              hasMarker = true;
            } else if (!hasMarker) {
              queue += character;
            } else if (character === rightParenthesis) {
              subvalue += queue + marker2 + subqueue;
              title = queue;
              break;
            } else if (isWhitespaceCharacter(character)) {
              subqueue += character;
            } else {
              queue += marker2 + subqueue + character;
              subqueue = "";
              hasMarker = false;
            }
            index3++;
          }
        }
      }
      if (value.charAt(index3) !== rightParenthesis) {
        return;
      }
      if (silent) {
        return true;
      }
      subvalue += rightParenthesis;
      url2 = self2.decode.raw(self2.unescape(url2), eat(beforeURL).test().end, {
        nonTerminated: false
      });
      if (title) {
        beforeTitle = eat(beforeTitle).test().end;
        title = self2.decode.raw(self2.unescape(title), beforeTitle);
      }
      node = {
        type: isImage ? "image" : "link",
        title: title || null,
        url: url2
      };
      if (isImage) {
        node.alt = self2.decode.raw(self2.unescape(content), now) || null;
      } else {
        exit = self2.enterLink();
        node.children = self2.tokenizeInline(content, now);
        exit();
      }
      return eat(subvalue)(node);
    }
    var reference_1 = reference;
    reference.locator = link$3;
    var link$1 = "link";
    var image$2 = "image";
    var shortcut = "shortcut";
    var collapsed = "collapsed";
    var full = "full";
    var exclamationMark = "!";
    var leftSquareBracket = "[";
    var backslash$2 = "\\";
    var rightSquareBracket = "]";
    function reference(eat, value, silent) {
      var self2 = this;
      var commonmark2 = self2.options.commonmark;
      var character = value.charAt(0);
      var index3 = 0;
      var length = value.length;
      var subvalue = "";
      var intro = "";
      var type2 = link$1;
      var referenceType = shortcut;
      var content;
      var identifier;
      var now;
      var node;
      var exit;
      var queue;
      var bracketed;
      var depth;
      if (character === exclamationMark) {
        type2 = image$2;
        intro = character;
        character = value.charAt(++index3);
      }
      if (character !== leftSquareBracket) {
        return;
      }
      index3++;
      intro += character;
      queue = "";
      depth = 0;
      while (index3 < length) {
        character = value.charAt(index3);
        if (character === leftSquareBracket) {
          bracketed = true;
          depth++;
        } else if (character === rightSquareBracket) {
          if (!depth) {
            break;
          }
          depth--;
        }
        if (character === backslash$2) {
          queue += backslash$2;
          character = value.charAt(++index3);
        }
        queue += character;
        index3++;
      }
      subvalue = queue;
      content = queue;
      character = value.charAt(index3);
      if (character !== rightSquareBracket) {
        return;
      }
      index3++;
      subvalue += character;
      queue = "";
      if (!commonmark2) {
        while (index3 < length) {
          character = value.charAt(index3);
          if (!isWhitespaceCharacter(character)) {
            break;
          }
          queue += character;
          index3++;
        }
      }
      character = value.charAt(index3);
      if (character === leftSquareBracket) {
        identifier = "";
        queue += character;
        index3++;
        while (index3 < length) {
          character = value.charAt(index3);
          if (character === leftSquareBracket || character === rightSquareBracket) {
            break;
          }
          if (character === backslash$2) {
            identifier += backslash$2;
            character = value.charAt(++index3);
          }
          identifier += character;
          index3++;
        }
        character = value.charAt(index3);
        if (character === rightSquareBracket) {
          referenceType = identifier ? full : collapsed;
          queue += identifier + character;
          index3++;
        } else {
          identifier = "";
        }
        subvalue += queue;
        queue = "";
      } else {
        if (!content) {
          return;
        }
        identifier = content;
      }
      if (referenceType !== full && bracketed) {
        return;
      }
      subvalue = intro + subvalue;
      if (type2 === link$1 && self2.inLink) {
        return null;
      }
      if (silent) {
        return true;
      }
      now = eat.now();
      now.column += intro.length;
      now.offset += intro.length;
      identifier = referenceType === full ? identifier : content;
      node = {
        type: type2 + "Reference",
        identifier: normalize_1$1(identifier),
        label: identifier,
        referenceType
      };
      if (type2 === link$1) {
        exit = self2.enterLink();
        node.children = self2.tokenizeInline(content, now);
        exit();
      } else {
        node.alt = self2.decode.raw(self2.unescape(content), now) || null;
      }
      return eat(subvalue)(node);
    }
    var strong$2 = locate$4;
    function locate$4(value, fromIndex) {
      var asterisk2 = value.indexOf("**", fromIndex);
      var underscore2 = value.indexOf("__", fromIndex);
      if (underscore2 === -1) {
        return asterisk2;
      }
      if (asterisk2 === -1) {
        return underscore2;
      }
      return underscore2 < asterisk2 ? underscore2 : asterisk2;
    }
    var strong_1$1 = strong$1;
    strong$1.locator = strong$2;
    var backslash$1 = "\\";
    var asterisk$1 = "*";
    var underscore$1 = "_";
    function strong$1(eat, value, silent) {
      var self2 = this;
      var index3 = 0;
      var character = value.charAt(index3);
      var now;
      var pedantic;
      var marker2;
      var queue;
      var subvalue;
      var length;
      var previous;
      if (character !== asterisk$1 && character !== underscore$1 || value.charAt(++index3) !== character) {
        return;
      }
      pedantic = self2.options.pedantic;
      marker2 = character;
      subvalue = marker2 + marker2;
      length = value.length;
      index3++;
      queue = "";
      character = "";
      if (pedantic && isWhitespaceCharacter(value.charAt(index3))) {
        return;
      }
      while (index3 < length) {
        previous = character;
        character = value.charAt(index3);
        if (character === marker2 && value.charAt(index3 + 1) === marker2 && (!pedantic || !isWhitespaceCharacter(previous))) {
          character = value.charAt(index3 + 2);
          if (character !== marker2) {
            if (!trim_1(queue)) {
              return;
            }
            if (silent) {
              return true;
            }
            now = eat.now();
            now.column += 2;
            now.offset += 2;
            return eat(subvalue + queue + subvalue)({
              type: "strong",
              children: self2.tokenizeInline(queue, now)
            });
          }
        }
        if (!pedantic && character === backslash$1) {
          queue += character;
          character = value.charAt(++index3);
        }
        queue += character;
        index3++;
      }
    }
    var isWordCharacter = wordCharacter;
    var fromCode = String.fromCharCode;
    var re$1 = /\w/;
    function wordCharacter(character) {
      return re$1.test(typeof character === "number" ? fromCode(character) : character.charAt(0));
    }
    var emphasis$2 = locate$3;
    function locate$3(value, fromIndex) {
      var asterisk2 = value.indexOf("*", fromIndex);
      var underscore2 = value.indexOf("_", fromIndex);
      if (underscore2 === -1) {
        return asterisk2;
      }
      if (asterisk2 === -1) {
        return underscore2;
      }
      return underscore2 < asterisk2 ? underscore2 : asterisk2;
    }
    var emphasis_1$1 = emphasis$1;
    emphasis$1.locator = emphasis$2;
    var asterisk = "*";
    var underscore = "_";
    var backslash = "\\";
    function emphasis$1(eat, value, silent) {
      var self2 = this;
      var index3 = 0;
      var character = value.charAt(index3);
      var now;
      var pedantic;
      var marker2;
      var queue;
      var subvalue;
      var length;
      var previous;
      if (character !== asterisk && character !== underscore) {
        return;
      }
      pedantic = self2.options.pedantic;
      subvalue = character;
      marker2 = character;
      length = value.length;
      index3++;
      queue = "";
      character = "";
      if (pedantic && isWhitespaceCharacter(value.charAt(index3))) {
        return;
      }
      while (index3 < length) {
        previous = character;
        character = value.charAt(index3);
        if (character === marker2 && (!pedantic || !isWhitespaceCharacter(previous))) {
          character = value.charAt(++index3);
          if (character !== marker2) {
            if (!trim_1(queue) || previous === marker2) {
              return;
            }
            if (!pedantic && marker2 === underscore && isWordCharacter(character)) {
              queue += marker2;
              continue;
            }
            if (silent) {
              return true;
            }
            now = eat.now();
            now.column++;
            now.offset++;
            return eat(subvalue + queue + marker2)({
              type: "emphasis",
              children: self2.tokenizeInline(queue, now)
            });
          }
          queue += marker2;
        }
        if (!pedantic && character === backslash) {
          queue += character;
          character = value.charAt(++index3);
        }
        queue += character;
        index3++;
      }
    }
    var _delete$2 = locate$2;
    function locate$2(value, fromIndex) {
      return value.indexOf("~~", fromIndex);
    }
    var _delete$1 = strikethrough$1;
    strikethrough$1.locator = _delete$2;
    var tilde$1 = "~";
    var fence$1 = "~~";
    function strikethrough$1(eat, value, silent) {
      var self2 = this;
      var character = "";
      var previous = "";
      var preceding = "";
      var subvalue = "";
      var index3;
      var length;
      var now;
      if (!self2.options.gfm || value.charAt(0) !== tilde$1 || value.charAt(1) !== tilde$1 || isWhitespaceCharacter(value.charAt(2))) {
        return;
      }
      index3 = 1;
      length = value.length;
      now = eat.now();
      now.column += 2;
      now.offset += 2;
      while (++index3 < length) {
        character = value.charAt(index3);
        if (character === tilde$1 && previous === tilde$1 && (!preceding || !isWhitespaceCharacter(preceding))) {
          if (silent) {
            return true;
          }
          return eat(fence$1 + subvalue + fence$1)({
            type: "delete",
            children: self2.tokenizeInline(subvalue, now)
          });
        }
        subvalue += previous;
        preceding = previous;
        previous = character;
      }
    }
    var codeInline$1 = locate$1;
    function locate$1(value, fromIndex) {
      return value.indexOf("`", fromIndex);
    }
    var codeInline = inlineCode$1;
    inlineCode$1.locator = codeInline$1;
    var lineFeed$3 = 10;
    var space$5 = 32;
    var graveAccent = 96;
    function inlineCode$1(eat, value, silent) {
      var length = value.length;
      var index3 = 0;
      var openingFenceEnd;
      var closingFenceStart;
      var closingFenceEnd;
      var code2;
      var next;
      var found;
      while (index3 < length) {
        if (value.charCodeAt(index3) !== graveAccent) {
          break;
        }
        index3++;
      }
      if (index3 === 0 || index3 === length) {
        return;
      }
      openingFenceEnd = index3;
      next = value.charCodeAt(index3);
      while (index3 < length) {
        code2 = next;
        next = value.charCodeAt(index3 + 1);
        if (code2 === graveAccent) {
          if (closingFenceStart === void 0) {
            closingFenceStart = index3;
          }
          closingFenceEnd = index3 + 1;
          if (next !== graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {
            found = true;
            break;
          }
        } else if (closingFenceStart !== void 0) {
          closingFenceStart = void 0;
          closingFenceEnd = void 0;
        }
        index3++;
      }
      if (!found) {
        return;
      }
      if (silent) {
        return true;
      }
      index3 = openingFenceEnd;
      length = closingFenceStart;
      code2 = value.charCodeAt(index3);
      next = value.charCodeAt(length - 1);
      found = false;
      if (length - index3 > 2 && (code2 === space$5 || code2 === lineFeed$3) && (next === space$5 || next === lineFeed$3)) {
        index3++;
        length--;
        while (index3 < length) {
          code2 = value.charCodeAt(index3);
          if (code2 !== space$5 && code2 !== lineFeed$3) {
            found = true;
            break;
          }
          index3++;
        }
        if (found === true) {
          openingFenceEnd++;
          closingFenceStart--;
        }
      }
      return eat(value.slice(0, closingFenceEnd))({
        type: "inlineCode",
        value: value.slice(openingFenceEnd, closingFenceStart)
      });
    }
    var _break$2 = locate;
    function locate(value, fromIndex) {
      var index3 = value.indexOf("\n", fromIndex);
      while (index3 > fromIndex) {
        if (value.charAt(index3 - 1) !== " ") {
          break;
        }
        index3--;
      }
      return index3;
    }
    var _break$1 = hardBreak$1;
    hardBreak$1.locator = _break$2;
    var space$4 = " ";
    var lineFeed$2 = "\n";
    var minBreakLength = 2;
    function hardBreak$1(eat, value, silent) {
      var length = value.length;
      var index3 = -1;
      var queue = "";
      var character;
      while (++index3 < length) {
        character = value.charAt(index3);
        if (character === lineFeed$2) {
          if (index3 < minBreakLength) {
            return;
          }
          if (silent) {
            return true;
          }
          queue += character;
          return eat(queue)({ type: "break" });
        }
        if (character !== space$4) {
          return;
        }
        queue += character;
      }
    }
    var text_1$2 = text$3;
    function text$3(eat, value, silent) {
      var self2 = this;
      var methods;
      var tokenizers;
      var index3;
      var length;
      var subvalue;
      var position2;
      var tokenizer2;
      var name2;
      var min;
      var now;
      if (silent) {
        return true;
      }
      methods = self2.inlineMethods;
      length = methods.length;
      tokenizers = self2.inlineTokenizers;
      index3 = -1;
      min = value.length;
      while (++index3 < length) {
        name2 = methods[index3];
        if (name2 === "text" || !tokenizers[name2]) {
          continue;
        }
        tokenizer2 = tokenizers[name2].locator;
        if (!tokenizer2) {
          eat.file.fail("Missing locator: `" + name2 + "`");
        }
        position2 = tokenizer2.call(self2, value, 1);
        if (position2 !== -1 && position2 < min) {
          min = position2;
        }
      }
      subvalue = value.slice(0, min);
      now = eat.now();
      self2.decode(subvalue, now, handler2);
      function handler2(content, position3, source) {
        eat(source || content)({ type: "text", value: content });
      }
    }
    var parser$1 = Parser;
    function Parser(doc, file) {
      this.file = file;
      this.offset = {};
      this.options = immutable(this.options);
      this.setOptions({});
      this.inList = false;
      this.inBlock = false;
      this.inLink = false;
      this.atStart = true;
      this.toOffset = vfileLocation(file).toOffset;
      this.unescape = _unescape(this, "escape");
      this.decode = decode(this);
    }
    var proto$3 = Parser.prototype;
    proto$3.setOptions = setOptions_1;
    proto$3.parse = parse_1$2;
    proto$3.options = defaults$1;
    proto$3.exitStart = stateToggle("atStart", true);
    proto$3.enterList = stateToggle("inList", false);
    proto$3.enterLink = stateToggle("inLink", false);
    proto$3.enterBlock = stateToggle("inBlock", false);
    proto$3.interruptParagraph = [
      ["thematicBreak"],
      ["list"],
      ["atxHeading"],
      ["fencedCode"],
      ["blockquote"],
      ["html"],
      ["setextHeading", { commonmark: false }],
      ["definition", { commonmark: false }]
    ];
    proto$3.interruptList = [
      ["atxHeading", { pedantic: false }],
      ["fencedCode", { pedantic: false }],
      ["thematicBreak", { pedantic: false }],
      ["definition", { commonmark: false }]
    ];
    proto$3.interruptBlockquote = [
      ["indentedCode", { commonmark: true }],
      ["fencedCode", { commonmark: true }],
      ["atxHeading", { commonmark: true }],
      ["setextHeading", { commonmark: true }],
      ["thematicBreak", { commonmark: true }],
      ["html", { commonmark: true }],
      ["list", { commonmark: true }],
      ["definition", { commonmark: false }]
    ];
    proto$3.blockTokenizers = {
      blankLine: blankLine_1,
      indentedCode: codeIndented,
      fencedCode: codeFenced,
      blockquote: blockquote_1$1,
      atxHeading: headingAtx,
      thematicBreak: thematicBreak_1$1,
      list: list_1$1,
      setextHeading: headingSetext,
      html: htmlBlock,
      definition: definition_1,
      table: table_1$1,
      paragraph: paragraph_1$1
    };
    proto$3.inlineTokenizers = {
      escape: _escape,
      autoLink: autoLink_1,
      url: url_1,
      email: email_1,
      html: htmlInline,
      link: link_1$1,
      reference: reference_1,
      strong: strong_1$1,
      emphasis: emphasis_1$1,
      deletion: _delete$1,
      code: codeInline,
      break: _break$1,
      text: text_1$2
    };
    proto$3.blockMethods = keys$1(proto$3.blockTokenizers);
    proto$3.inlineMethods = keys$1(proto$3.inlineTokenizers);
    proto$3.tokenizeBlock = tokenizer$1("block");
    proto$3.tokenizeInline = tokenizer$1("inline");
    proto$3.tokenizeFactory = tokenizer$1;
    function keys$1(value) {
      var result = [];
      var key;
      for (key in value) {
        result.push(key);
      }
      return result;
    }
    var remarkParse = parse$5;
    parse$5.Parser = parser$1;
    function parse$5(options4) {
      var settings = this.data("settings");
      var Local = unherit_1(parser$1);
      Local.prototype.options = immutable(Local.prototype.options, settings, options4);
      this.Parser = Local;
    }
    var mdastUtilDefinitions$1 = getDefinitionFactory$1;
    var own$a = {}.hasOwnProperty;
    function getDefinitionFactory$1(node, options4) {
      return getterFactory$1(gather$1(node, options4));
    }
    function gather$1(node, options4) {
      var cache2 = {};
      if (!node || !node.type) {
        throw new Error("mdast-util-definitions expected node");
      }
      unistUtilVisit(node, "definition", options4 && options4.commonmark ? commonmark2 : normal);
      return cache2;
      function commonmark2(definition2) {
        var id = normalise$1(definition2.identifier);
        if (!own$a.call(cache2, id)) {
          cache2[id] = definition2;
        }
      }
      function normal(definition2) {
        cache2[normalise$1(definition2.identifier)] = definition2;
      }
    }
    function getterFactory$1(cache2) {
      return getter;
      function getter(identifier) {
        var id = identifier && normalise$1(identifier);
        return id && own$a.call(cache2, id) ? cache2[id] : null;
      }
    }
    function normalise$1(identifier) {
      return identifier.toUpperCase();
    }
    var parse_1$1 = parse$4;
    var stringify_1$1 = stringify$3;
    var empty$2 = "";
    var space$3 = " ";
    var whiteSpace$1 = /[ \t\n\r\f]+/g;
    function parse$4(value) {
      var input = String(value || empty$2).trim();
      return input === empty$2 ? [] : input.split(whiteSpace$1);
    }
    function stringify$3(values2) {
      return values2.join(space$3).trim();
    }
    var spaceSeparatedTokens = {
      parse: parse_1$1,
      stringify: stringify_1$1
    };
    var isAbsoluteUrl = (url2) => {
      if (typeof url2 !== "string") {
        throw new TypeError(`Expected a \`string\`, got \`${typeof url2}\``);
      }
      if (/^[a-zA-Z]:\\/.test(url2)) {
        return false;
      }
      return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url2);
    };
    var spaceSeparated$4 = spaceSeparatedTokens.parse;
    var remarkExternalLinks = externalLinks;
    var defaultTarget = "_blank";
    var defaultRel = ["nofollow", "noopener", "noreferrer"];
    var defaultProtocols = ["http", "https"];
    function externalLinks(options4) {
      var settings = options4 || {};
      var target2 = settings.target;
      var rel = settings.rel;
      var protocols = settings.protocols || defaultProtocols;
      var content = settings.content;
      var contentProperties = settings.contentProperties || {};
      if (typeof rel === "string") {
        rel = spaceSeparated$4(rel);
      }
      if (content && typeof content === "object" && !("length" in content)) {
        content = [content];
      }
      return transform2;
      function transform2(tree) {
        var definition2 = mdastUtilDefinitions$1(tree);
        unistUtilVisit(tree, ["link", "linkReference"], visitor);
        function visitor(node) {
          var ctx = node.type === "link" ? node : definition2(node.identifier);
          var protocol;
          var data2;
          var props;
          if (!ctx)
            return;
          protocol = ctx.url.slice(0, ctx.url.indexOf(":"));
          if (isAbsoluteUrl(ctx.url) && protocols.indexOf(protocol) !== -1) {
            data2 = node.data || (node.data = {});
            props = data2.hProperties || (data2.hProperties = {});
            if (target2 !== false) {
              props.target = target2 || defaultTarget;
            }
            if (rel !== false) {
              props.rel = (rel || defaultRel).concat();
            }
            if (content) {
              node.children.push({
                type: "fragment",
                children: [],
                data: {
                  hName: "span",
                  hProperties: extend$2(true, contentProperties),
                  hChildren: extend$2(true, content)
                }
              });
            }
          }
        }
      }
    }
    var format2 = createCommonjsModule(function(module3) {
      (function() {
        var namespace;
        {
          namespace = module3.exports = format3;
        }
        namespace.format = format3;
        namespace.vsprintf = vsprintf;
        if (typeof console !== "undefined" && typeof console.log === "function") {
          namespace.printf = printf;
        }
        function printf() {
          console.log(format3.apply(null, arguments));
        }
        function vsprintf(fmt, replacements) {
          return format3.apply(null, [fmt].concat(replacements));
        }
        function format3(fmt) {
          var argIndex = 1, args = [].slice.call(arguments), i2 = 0, n = fmt.length, result = "", c, escaped3 = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
            return args[argIndex++];
          }, slurpNumber = function() {
            var digits = "";
            while (/\d/.test(fmt[i2])) {
              digits += fmt[i2++];
              c = fmt[i2];
            }
            return digits.length > 0 ? parseInt(digits) : null;
          };
          for (; i2 < n; ++i2) {
            c = fmt[i2];
            if (escaped3) {
              escaped3 = false;
              if (c == ".") {
                leadingZero = false;
                c = fmt[++i2];
              } else if (c == "0" && fmt[i2 + 1] == ".") {
                leadingZero = true;
                i2 += 2;
                c = fmt[i2];
              } else {
                leadingZero = true;
              }
              precision = slurpNumber();
              switch (c) {
                case "b":
                  result += parseInt(nextArg(), 10).toString(2);
                  break;
                case "c":
                  arg = nextArg();
                  if (typeof arg === "string" || arg instanceof String)
                    result += arg;
                  else
                    result += String.fromCharCode(parseInt(arg, 10));
                  break;
                case "d":
                  result += parseInt(nextArg(), 10);
                  break;
                case "f":
                  tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                  result += leadingZero ? tmp : tmp.replace(/^0/, "");
                  break;
                case "j":
                  result += JSON.stringify(nextArg());
                  break;
                case "o":
                  result += "0" + parseInt(nextArg(), 10).toString(8);
                  break;
                case "s":
                  result += nextArg();
                  break;
                case "x":
                  result += "0x" + parseInt(nextArg(), 10).toString(16);
                  break;
                case "X":
                  result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                  break;
                default:
                  result += c;
                  break;
              }
            } else if (c === "%") {
              escaped3 = true;
            } else {
              result += c;
            }
          }
          return result;
        }
      })();
    });
    var fault = create$3(Error);
    var fault_1 = fault;
    fault.eval = create$3(EvalError);
    fault.range = create$3(RangeError);
    fault.reference = create$3(ReferenceError);
    fault.syntax = create$3(SyntaxError);
    fault.type = create$3(TypeError);
    fault.uri = create$3(URIError);
    fault.create = create$3;
    function create$3(EConstructor) {
      FormattedError.displayName = EConstructor.displayName || EConstructor.name;
      return FormattedError;
      function FormattedError(format$1) {
        if (format$1) {
          format$1 = format2.apply(null, arguments);
        }
        return new EConstructor(format$1);
      }
    }
    var matters_1 = matters;
    var own$9 = {}.hasOwnProperty;
    var markers = {
      yaml: "-",
      toml: "+"
    };
    function matters(options4) {
      var results = [];
      var index3 = -1;
      var length;
      if (typeof options4 === "string" || !("length" in options4)) {
        options4 = [options4];
      }
      length = options4.length;
      while (++index3 < length) {
        results[index3] = matter(options4[index3]);
      }
      return results;
    }
    function matter(option2) {
      var result = option2;
      if (typeof result === "string") {
        if (!own$9.call(markers, result)) {
          throw fault_1("Missing matter definition for `%s`", result);
        }
        result = { type: result, marker: markers[result] };
      } else if (typeof result !== "object") {
        throw fault_1("Expected matter to be an object, not `%j`", result);
      }
      if (!own$9.call(result, "type")) {
        throw fault_1("Missing `type` in matter `%j`", result);
      }
      if (!own$9.call(result, "fence") && !own$9.call(result, "marker")) {
        throw fault_1("Missing `marker` or `fence` in matter `%j`", result);
      }
      return result;
    }
    var fence_1 = fence;
    function fence(matter2, prop2) {
      var marker2;
      if (matter2.marker) {
        marker2 = pick(matter2.marker, prop2);
        return marker2 + marker2 + marker2;
      }
      return pick(matter2.fence, prop2);
    }
    function pick(schema2, prop2) {
      return typeof schema2 === "string" ? schema2 : schema2[prop2];
    }
    var parse$3 = create$2;
    function create$2(matter2) {
      var name2 = matter2.type + "FrontMatter";
      var open = fence_1(matter2, "open");
      var close = fence_1(matter2, "close");
      var newline2 = "\n";
      var anywhere = matter2.anywhere;
      frontmatter2.displayName = name2;
      frontmatter2.onlyAtStart = typeof anywhere === "boolean" ? !anywhere : true;
      return [name2, frontmatter2];
      function frontmatter2(eat, value, silent) {
        var index3 = open.length;
        var offset;
        if (value.slice(0, index3) !== open || value.charAt(index3) !== newline2) {
          return;
        }
        offset = value.indexOf(close, index3);
        while (offset !== -1 && value.charAt(offset - 1) !== newline2) {
          index3 = offset + close.length;
          offset = value.indexOf(close, index3);
        }
        if (offset !== -1) {
          if (silent) {
            return true;
          }
          return eat(value.slice(0, offset + close.length))({
            type: matter2.type,
            value: value.slice(open.length + 1, offset - 1)
          });
        }
      }
    }
    var compile2 = create$1;
    function create$1(matter2) {
      var type2 = matter2.type;
      var open = fence_1(matter2, "open");
      var close = fence_1(matter2, "close");
      frontmatter2.displayName = type2 + "FrontMatter";
      return [type2, frontmatter2];
      function frontmatter2(node) {
        return open + (node.value ? "\n" + node.value : "") + "\n" + close;
      }
    }
    var remarkFrontmatter = frontmatter;
    function frontmatter(options4) {
      var parser2 = this.Parser;
      var compiler2 = this.Compiler;
      var config = matters_1(options4 || ["yaml"]);
      if (isRemarkParser(parser2)) {
        attachParser(parser2, config);
      }
      if (isRemarkCompiler(compiler2)) {
        attachCompiler(compiler2, config);
      }
    }
    function attachParser(parser2, matters2) {
      var proto2 = parser2.prototype;
      var tokenizers = wrap$1(parse$3, matters2);
      var names = [];
      var key;
      for (key in tokenizers) {
        names.push(key);
      }
      proto2.blockMethods = names.concat(proto2.blockMethods);
      proto2.blockTokenizers = Object.assign({}, tokenizers, proto2.blockTokenizers);
    }
    function attachCompiler(compiler2, matters2) {
      var proto2 = compiler2.prototype;
      proto2.visitors = Object.assign({}, wrap$1(compile2, matters2), proto2.visitors);
    }
    function wrap$1(func, matters2) {
      var result = {};
      var length = matters2.length;
      var index3 = -1;
      var tuple;
      while (++index3 < length) {
        tuple = func(matters2[index3]);
        result[tuple[0]] = tuple[1];
      }
      return result;
    }
    function isRemarkParser(parser2) {
      return Boolean(parser2 && parser2.prototype && parser2.prototype.blockTokenizers);
    }
    function isRemarkCompiler(compiler2) {
      return Boolean(compiler2 && compiler2.prototype && compiler2.prototype.visitors);
    }
    var unistBuilder = u;
    function u(type2, props, value) {
      var node;
      if ((value === null || value === void 0) && (typeof props !== "object" || Array.isArray(props))) {
        value = props;
        props = {};
      }
      node = Object.assign({ type: String(type2) }, props);
      if (Array.isArray(value)) {
        node.children = value;
      } else if (value !== null && value !== void 0) {
        node.value = String(value);
      }
      return node;
    }
    var start = factory$1("start");
    var end = factory$1("end");
    var unistUtilPosition = position;
    position.start = start;
    position.end = end;
    function position(node) {
      return { start: start(node), end: end(node) };
    }
    function factory$1(type2) {
      point2.displayName = type2;
      return point2;
      function point2(node) {
        var point3 = node && node.position && node.position[type2] || {};
        return {
          line: point3.line || null,
          column: point3.column || null,
          offset: isNaN(point3.offset) ? null : point3.offset
        };
      }
    }
    var unistUtilGenerated = generated;
    function generated(node) {
      var position2 = optional(optional(node).position);
      var start2 = optional(position2.start);
      var end2 = optional(position2.end);
      return !start2.line || !start2.column || !end2.line || !end2.column;
    }
    function optional(value) {
      return value && typeof value === "object" ? value : {};
    }
    var mdastUtilDefinitions = getDefinitionFactory;
    var own$8 = {}.hasOwnProperty;
    function getDefinitionFactory(node, options4) {
      return getterFactory(gather(node, options4));
    }
    function gather(node, options4) {
      var cache2 = {};
      if (!node || !node.type) {
        throw new Error("mdast-util-definitions expected node");
      }
      unistUtilVisit(node, "definition", options4 && options4.commonmark ? commonmark2 : normal);
      return cache2;
      function commonmark2(definition2) {
        var id = normalise(definition2.identifier);
        if (!own$8.call(cache2, id)) {
          cache2[id] = definition2;
        }
      }
      function normal(definition2) {
        cache2[normalise(definition2.identifier)] = definition2;
      }
    }
    function getterFactory(cache2) {
      return getter;
      function getter(identifier) {
        var id = identifier && normalise(identifier);
        return id && own$8.call(cache2, id) ? cache2[id] : null;
      }
    }
    function normalise(identifier) {
      return identifier.toUpperCase();
    }
    var all_1$1 = all$2;
    function all$2(h, parent) {
      var nodes = parent.children || [];
      var length = nodes.length;
      var values2 = [];
      var index3 = -1;
      var result;
      var head2;
      while (++index3 < length) {
        result = one_1$1(h, nodes[index3], parent);
        if (result) {
          if (index3 && nodes[index3 - 1].type === "break") {
            if (result.value) {
              result.value = result.value.replace(/^\s+/, "");
            }
            head2 = result.children && result.children[0];
            if (head2 && head2.value) {
              head2.value = head2.value.replace(/^\s+/, "");
            }
          }
          values2 = values2.concat(result);
        }
      }
      return values2;
    }
    var one_1$1 = one$2;
    var own$7 = {}.hasOwnProperty;
    function unknown(h, node) {
      if (text$2(node)) {
        return h.augment(node, unistBuilder("text", node.value));
      }
      return h(node, "div", all_1$1(h, node));
    }
    function one$2(h, node, parent) {
      var type2 = node && node.type;
      var fn = own$7.call(h.handlers, type2) ? h.handlers[type2] : h.unknownHandler;
      if (!type2) {
        throw new Error("Expected node, got `" + node + "`");
      }
      return (typeof fn === "function" ? fn : unknown)(h, node, parent);
    }
    function text$2(node) {
      var data2 = node.data || {};
      if (own$7.call(data2, "hName") || own$7.call(data2, "hProperties") || own$7.call(data2, "hChildren")) {
        return false;
      }
      return "value" in node;
    }
    var thematicBreak_1 = thematicBreak;
    function thematicBreak(h, node) {
      return h(node, "hr");
    }
    var wrap_1 = wrap2;
    function wrap2(nodes, loose) {
      var result = [];
      var index3 = -1;
      var length = nodes.length;
      if (loose) {
        result.push(unistBuilder("text", "\n"));
      }
      while (++index3 < length) {
        if (index3) {
          result.push(unistBuilder("text", "\n"));
        }
        result.push(nodes[index3]);
      }
      if (loose && nodes.length !== 0) {
        result.push(unistBuilder("text", "\n"));
      }
      return result;
    }
    var list_1 = list;
    function list(h, node) {
      var props = {};
      var name2 = node.ordered ? "ol" : "ul";
      var items;
      var index3 = -1;
      var length;
      if (typeof node.start === "number" && node.start !== 1) {
        props.start = node.start;
      }
      items = all_1$1(h, node);
      length = items.length;
      while (++index3 < length) {
        if (items[index3].properties.className && items[index3].properties.className.indexOf("task-list-item") !== -1) {
          props.className = ["contains-task-list"];
          break;
        }
      }
      return h(node, name2, props, wrap_1(items, true));
    }
    var footer = generateFootnotes;
    function generateFootnotes(h) {
      var footnoteById = h.footnoteById;
      var footnoteOrder = h.footnoteOrder;
      var length = footnoteOrder.length;
      var index3 = -1;
      var listItems = [];
      var def;
      var backReference;
      var content;
      var tail;
      while (++index3 < length) {
        def = footnoteById[footnoteOrder[index3].toUpperCase()];
        if (!def) {
          continue;
        }
        content = def.children.concat();
        tail = content[content.length - 1];
        backReference = {
          type: "link",
          url: "#fnref-" + def.identifier,
          data: { hProperties: { className: ["footnote-backref"] } },
          children: [{ type: "text", value: "\u21A9" }]
        };
        if (!tail || tail.type !== "paragraph") {
          tail = { type: "paragraph", children: [] };
          content.push(tail);
        }
        tail.children.push(backReference);
        listItems.push({
          type: "listItem",
          data: { hProperties: { id: "fn-" + def.identifier } },
          children: content,
          position: def.position
        });
      }
      if (listItems.length === 0) {
        return null;
      }
      return h(null, "div", { className: ["footnotes"] }, wrap_1([
        thematicBreak_1(h),
        list_1(h, { type: "list", ordered: true, children: listItems })
      ], true));
    }
    var blockquote_1 = blockquote;
    function blockquote(h, node) {
      return h(node, "blockquote", wrap_1(all_1$1(h, node), true));
    }
    var _break = hardBreak;
    function hardBreak(h, node) {
      return [h(node, "br"), unistBuilder("text", "\n")];
    }
    var detab_1 = detab;
    var tab$1 = 9;
    var lineFeed$1 = 10;
    var carriageReturn = 13;
    function detab(value, size) {
      var string = typeof value === "string";
      var length = string && value.length;
      var start2 = 0;
      var index3 = -1;
      var column = -1;
      var tabSize2 = size || 4;
      var results = [];
      var code2;
      var add;
      if (!string) {
        throw new Error("detab expected string");
      }
      while (++index3 < length) {
        code2 = value.charCodeAt(index3);
        if (code2 === tab$1) {
          add = tabSize2 - (column + 1) % tabSize2;
          column += add;
          results.push(value.slice(start2, index3) + repeatString(" ", add));
          start2 = index3 + 1;
        } else if (code2 === lineFeed$1 || code2 === carriageReturn) {
          column = -1;
        } else {
          column++;
        }
      }
      results.push(value.slice(start2));
      return results.join("");
    }
    var code_1 = code;
    function code(h, node) {
      var value = node.value ? detab_1(node.value + "\n") : "";
      var lang2 = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/);
      var props = {};
      if (lang2) {
        props.className = ["language-" + lang2];
      }
      return h(node.position, "pre", [h(node, "code", props, [unistBuilder("text", value)])]);
    }
    var _delete = strikethrough;
    function strikethrough(h, node) {
      return h(node, "del", all_1$1(h, node));
    }
    var emphasis_1 = emphasis;
    function emphasis(h, node) {
      return h(node, "em", all_1$1(h, node));
    }
    var footnoteReference_1 = footnoteReference;
    function footnoteReference(h, node) {
      var footnoteOrder = h.footnoteOrder;
      var identifier = String(node.identifier);
      if (footnoteOrder.indexOf(identifier) === -1) {
        footnoteOrder.push(identifier);
      }
      return h(node.position, "sup", { id: "fnref-" + identifier }, [
        h(node, "a", { href: "#fn-" + identifier, className: ["footnote-ref"] }, [
          unistBuilder("text", node.label || identifier)
        ])
      ]);
    }
    var footnote_1 = footnote;
    function footnote(h, node) {
      var footnoteById = h.footnoteById;
      var footnoteOrder = h.footnoteOrder;
      var identifier = 1;
      while (identifier in footnoteById) {
        identifier++;
      }
      identifier = String(identifier);
      footnoteOrder.push(identifier);
      footnoteById[identifier] = {
        type: "footnoteDefinition",
        identifier,
        children: [{ type: "paragraph", children: node.children }],
        position: node.position
      };
      return footnoteReference_1(h, {
        type: "footnoteReference",
        identifier,
        position: node.position
      });
    }
    var heading_1 = heading;
    function heading(h, node) {
      return h(node, "h" + node.depth, all_1$1(h, node));
    }
    var html_1$1 = html$3;
    function html$3(h, node) {
      return h.dangerous ? h.augment(node, unistBuilder("raw", node.value)) : null;
    }
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i2, ch, cache2 = encodeCache[exclude];
      if (cache2) {
        return cache2;
      }
      cache2 = encodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache2.push(ch);
        } else {
          cache2.push("%" + ("0" + i2.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        cache2[exclude.charCodeAt(i2)] = exclude[i2];
      }
      return cache2;
    }
    function encode$1(string, exclude, keepEscaped) {
      var i2, l2, code2, nextCode, cache2, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode$1.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache2 = getEncodeCache(exclude);
      for (i2 = 0, l2 = string.length; i2 < l2; i2++) {
        code2 = string.charCodeAt(i2);
        if (keepEscaped && code2 === 37 && i2 + 2 < l2) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i2 + 1, i2 + 3))) {
            result += string.slice(i2, i2 + 3);
            i2 += 2;
            continue;
          }
        }
        if (code2 < 128) {
          result += cache2[code2];
          continue;
        }
        if (code2 >= 55296 && code2 <= 57343) {
          if (code2 >= 55296 && code2 <= 56319 && i2 + 1 < l2) {
            nextCode = string.charCodeAt(i2 + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i2] + string[i2 + 1]);
              i2++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i2]);
      }
      return result;
    }
    encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode$1.componentChars = "-_.!~*'()";
    var encode_1 = encode$1;
    var revert_1 = revert;
    function revert(h, node) {
      var subtype = node.referenceType;
      var suffix = "]";
      var contents;
      var head2;
      var tail;
      if (subtype === "collapsed") {
        suffix += "[]";
      } else if (subtype === "full") {
        suffix += "[" + (node.label || node.identifier) + "]";
      }
      if (node.type === "imageReference") {
        return unistBuilder("text", "![" + node.alt + suffix);
      }
      contents = all_1$1(h, node);
      head2 = contents[0];
      if (head2 && head2.type === "text") {
        head2.value = "[" + head2.value;
      } else {
        contents.unshift(unistBuilder("text", "["));
      }
      tail = contents[contents.length - 1];
      if (tail && tail.type === "text") {
        tail.value += suffix;
      } else {
        contents.push(unistBuilder("text", suffix));
      }
      return contents;
    }
    var imageReference_1 = imageReference;
    function imageReference(h, node) {
      var def = h.definition(node.identifier);
      var props;
      if (!def) {
        return revert_1(h, node);
      }
      props = { src: encode_1(def.url || ""), alt: node.alt };
      if (def.title !== null && def.title !== void 0) {
        props.title = def.title;
      }
      return h(node, "img", props);
    }
    var image_1 = image$1;
    function image$1(h, node) {
      var props = { src: encode_1(node.url), alt: node.alt };
      if (node.title !== null && node.title !== void 0) {
        props.title = node.title;
      }
      return h(node, "img", props);
    }
    var inlineCode_1 = inlineCode;
    function inlineCode(h, node) {
      return h(node, "code", [unistBuilder("text", collapseWhiteSpace(node.value))]);
    }
    var linkReference_1 = linkReference;
    function linkReference(h, node) {
      var def = h.definition(node.identifier);
      var props;
      if (!def) {
        return revert_1(h, node);
      }
      props = { href: encode_1(def.url || "") };
      if (def.title !== null && def.title !== void 0) {
        props.title = def.title;
      }
      return h(node, "a", props, all_1$1(h, node));
    }
    var link_1 = link;
    function link(h, node) {
      var props = { href: encode_1(node.url) };
      if (node.title !== null && node.title !== void 0) {
        props.title = node.title;
      }
      return h(node, "a", props, all_1$1(h, node));
    }
    var listItem_1 = listItem$1;
    function listItem$1(h, node, parent) {
      var children = node.children;
      var head2 = children[0];
      var raw2 = all_1$1(h, node);
      var loose = parent ? listLoose(parent) : listItemLoose(node);
      var props = {};
      var result;
      var container;
      var index3;
      var length;
      var child;
      if (loose) {
        result = raw2;
      } else {
        result = [];
        length = raw2.length;
        index3 = -1;
        while (++index3 < length) {
          child = raw2[index3];
          if (child.tagName === "p") {
            result = result.concat(child.children);
          } else {
            result.push(child);
          }
        }
      }
      if (typeof node.checked === "boolean") {
        if (loose && (!head2 || head2.type !== "paragraph")) {
          result.unshift(h(null, "p", []));
        }
        container = loose ? result[0].children : result;
        if (container.length !== 0) {
          container.unshift(unistBuilder("text", " "));
        }
        container.unshift(h(null, "input", {
          type: "checkbox",
          checked: node.checked,
          disabled: true
        }));
        props.className = ["task-list-item"];
      }
      if (loose && result.length !== 0) {
        result = wrap_1(result, true);
      }
      return h(node, "li", props, result);
    }
    function listLoose(node) {
      var loose = node.spread;
      var children = node.children;
      var length = children.length;
      var index3 = -1;
      while (!loose && ++index3 < length) {
        loose = listItemLoose(children[index3]);
      }
      return loose;
    }
    function listItemLoose(node) {
      var spread = node.spread;
      return spread === void 0 || spread === null ? node.children.length > 1 : spread;
    }
    var paragraph_1 = paragraph;
    function paragraph(h, node) {
      return h(node, "p", all_1$1(h, node));
    }
    var root_1 = root;
    function root(h, node) {
      return h.augment(node, unistBuilder("root", wrap_1(all_1$1(h, node))));
    }
    var strong_1 = strong;
    function strong(h, node) {
      return h(node, "strong", all_1$1(h, node));
    }
    var table_1 = table;
    function table(h, node) {
      var rows = node.children;
      var index3 = rows.length;
      var align = node.align;
      var alignLength = align.length;
      var result = [];
      var pos;
      var row;
      var out;
      var name2;
      var cell;
      while (index3--) {
        row = rows[index3].children;
        name2 = index3 === 0 ? "th" : "td";
        pos = alignLength;
        out = [];
        while (pos--) {
          cell = row[pos];
          out[pos] = h(cell, name2, { align: align[pos] }, cell ? all_1$1(h, cell) : []);
        }
        result[index3] = h(rows[index3], "tr", wrap_1(out, true));
      }
      return h(node, "table", wrap_1([
        h(result[0].position, "thead", wrap_1([result[0]], true)),
        h({
          start: unistUtilPosition.start(result[1]),
          end: unistUtilPosition.end(result[result.length - 1])
        }, "tbody", wrap_1(result.slice(1), true))
      ], true));
    }
    var trimLines_1 = trimLines;
    var ws = /[ \t]*\n+[ \t]*/g;
    var newline$1 = "\n";
    function trimLines(value) {
      return String(value).replace(ws, newline$1);
    }
    var text_1$1 = text$1;
    function text$1(h, node) {
      return h.augment(node, unistBuilder("text", trimLines_1(node.value)));
    }
    var handlers$1 = {
      blockquote: blockquote_1,
      break: _break,
      code: code_1,
      delete: _delete,
      emphasis: emphasis_1,
      footnoteReference: footnoteReference_1,
      footnote: footnote_1,
      heading: heading_1,
      html: html_1$1,
      imageReference: imageReference_1,
      image: image_1,
      inlineCode: inlineCode_1,
      linkReference: linkReference_1,
      link: link_1,
      listItem: listItem_1,
      list: list_1,
      paragraph: paragraph_1,
      root: root_1,
      strong: strong_1,
      table: table_1,
      text: text_1$1,
      thematicBreak: thematicBreak_1,
      toml: ignore,
      yaml: ignore,
      definition: ignore,
      footnoteDefinition: ignore
    };
    function ignore() {
      return null;
    }
    var lib$2 = toHast;
    var own$6 = {}.hasOwnProperty;
    var deprecationWarningIssued = false;
    function factory(tree, options4) {
      var settings = options4 || {};
      if (settings.allowDangerousHTML !== void 0 && !deprecationWarningIssued) {
        deprecationWarningIssued = true;
        console.warn("mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead");
      }
      var dangerous2 = settings.allowDangerousHtml || settings.allowDangerousHTML;
      var footnoteById = {};
      h.dangerous = dangerous2;
      h.definition = mdastUtilDefinitions(tree, settings);
      h.footnoteById = footnoteById;
      h.footnoteOrder = [];
      h.augment = augment;
      h.handlers = Object.assign({}, handlers$1, settings.handlers);
      h.unknownHandler = settings.unknownHandler;
      unistUtilVisit(tree, "footnoteDefinition", onfootnotedefinition);
      return h;
      function augment(left2, right2) {
        var data2;
        var ctx;
        if (left2 && "data" in left2) {
          data2 = left2.data;
          if (right2.type === "element" && data2.hName) {
            right2.tagName = data2.hName;
          }
          if (right2.type === "element" && data2.hProperties) {
            right2.properties = Object.assign({}, right2.properties, data2.hProperties);
          }
          if (right2.children && data2.hChildren) {
            right2.children = data2.hChildren;
          }
        }
        ctx = left2 && left2.position ? left2 : { position: left2 };
        if (!unistUtilGenerated(ctx)) {
          right2.position = {
            start: unistUtilPosition.start(ctx),
            end: unistUtilPosition.end(ctx)
          };
        }
        return right2;
      }
      function h(node, tagName, props, children) {
        if ((children === void 0 || children === null) && typeof props === "object" && "length" in props) {
          children = props;
          props = {};
        }
        return augment(node, {
          type: "element",
          tagName,
          properties: props || {},
          children: children || []
        });
      }
      function onfootnotedefinition(definition2) {
        var id = String(definition2.identifier).toUpperCase();
        if (!own$6.call(footnoteById, id)) {
          footnoteById[id] = definition2;
        }
      }
    }
    function toHast(tree, options4) {
      var h = factory(tree, options4);
      var node = one_1$1(h, tree);
      var foot = footer(h);
      if (foot) {
        node.children = node.children.concat(unistBuilder("text", "\n"), foot);
      }
      return node;
    }
    var mdastUtilToHast = lib$2;
    var remarkRehype = remark2rehype;
    function remark2rehype(destination, options4) {
      if (destination && !destination.process) {
        options4 = destination;
        destination = null;
      }
      return destination ? bridge(destination, options4) : mutate(options4);
    }
    function bridge(destination, options4) {
      return transformer;
      function transformer(node, file, next) {
        destination.run(mdastUtilToHast(node, options4), file, done);
        function done(err) {
          next(err);
        }
      }
    }
    function mutate(options4) {
      return transformer;
      function transformer(node) {
        return mdastUtilToHast(node, options4);
      }
    }
    var schema$1 = Schema$2;
    var proto$2 = Schema$2.prototype;
    proto$2.space = null;
    proto$2.normal = {};
    proto$2.property = {};
    function Schema$2(property, normal, space2) {
      this.property = property;
      this.normal = normal;
      if (space2) {
        this.space = space2;
      }
    }
    var merge_1 = merge$1;
    function merge$1(definitions) {
      var length = definitions.length;
      var property = [];
      var normal = [];
      var index3 = -1;
      var info2;
      var space2;
      while (++index3 < length) {
        info2 = definitions[index3];
        property.push(info2.property);
        normal.push(info2.normal);
        space2 = info2.space;
      }
      return new schema$1(immutable.apply(null, property), immutable.apply(null, normal), space2);
    }
    var normalize_1 = normalize2;
    function normalize2(value) {
      return value.toLowerCase();
    }
    var info = Info;
    var proto$1 = Info.prototype;
    proto$1.space = null;
    proto$1.attribute = null;
    proto$1.property = null;
    proto$1.boolean = false;
    proto$1.booleanish = false;
    proto$1.overloadedBoolean = false;
    proto$1.number = false;
    proto$1.commaSeparated = false;
    proto$1.spaceSeparated = false;
    proto$1.commaOrSpaceSeparated = false;
    proto$1.mustUseProperty = false;
    proto$1.defined = false;
    function Info(property, attribute2) {
      this.property = property;
      this.attribute = attribute2;
    }
    var powers = 0;
    var boolean_1 = increment();
    var booleanish$2 = increment();
    var overloadedBoolean$1 = increment();
    var number$3 = increment();
    var spaceSeparated$3 = increment();
    var commaSeparated$2 = increment();
    var commaOrSpaceSeparated$1 = increment();
    function increment() {
      return Math.pow(2, ++powers);
    }
    var types2 = {
      boolean: boolean_1,
      booleanish: booleanish$2,
      overloadedBoolean: overloadedBoolean$1,
      number: number$3,
      spaceSeparated: spaceSeparated$3,
      commaSeparated: commaSeparated$2,
      commaOrSpaceSeparated: commaOrSpaceSeparated$1
    };
    var definedInfo = DefinedInfo;
    DefinedInfo.prototype = new info();
    DefinedInfo.prototype.defined = true;
    var checks = [
      "boolean",
      "booleanish",
      "overloadedBoolean",
      "number",
      "commaSeparated",
      "spaceSeparated",
      "commaOrSpaceSeparated"
    ];
    var checksLength = checks.length;
    function DefinedInfo(property, attribute2, mask, space2) {
      var index3 = -1;
      var check2;
      mark$1(this, "space", space2);
      info.call(this, property, attribute2);
      while (++index3 < checksLength) {
        check2 = checks[index3];
        mark$1(this, check2, (mask & types2[check2]) === types2[check2]);
      }
    }
    function mark$1(values2, key, value) {
      if (value) {
        values2[key] = value;
      }
    }
    var create_1 = create;
    function create(definition2) {
      var space2 = definition2.space;
      var mustUseProperty = definition2.mustUseProperty || [];
      var attributes2 = definition2.attributes || {};
      var props = definition2.properties;
      var transform2 = definition2.transform;
      var property = {};
      var normal = {};
      var prop2;
      var info2;
      for (prop2 in props) {
        info2 = new definedInfo(prop2, transform2(attributes2, prop2), props[prop2], space2);
        if (mustUseProperty.indexOf(prop2) !== -1) {
          info2.mustUseProperty = true;
        }
        property[prop2] = info2;
        normal[normalize_1(prop2)] = prop2;
        normal[normalize_1(info2.attribute)] = prop2;
      }
      return new schema$1(property, normal, space2);
    }
    var xlink = create_1({
      space: "xlink",
      transform: xlinkTransform,
      properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
      }
    });
    function xlinkTransform(_, prop2) {
      return "xlink:" + prop2.slice(5).toLowerCase();
    }
    var xml = create_1({
      space: "xml",
      transform: xmlTransform,
      properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
      }
    });
    function xmlTransform(_, prop2) {
      return "xml:" + prop2.slice(3).toLowerCase();
    }
    var caseSensitiveTransform_1 = caseSensitiveTransform;
    function caseSensitiveTransform(attributes2, attribute2) {
      return attribute2 in attributes2 ? attributes2[attribute2] : attribute2;
    }
    var caseInsensitiveTransform_1 = caseInsensitiveTransform;
    function caseInsensitiveTransform(attributes2, property) {
      return caseSensitiveTransform_1(attributes2, property.toLowerCase());
    }
    var xmlns = create_1({
      space: "xmlns",
      attributes: {
        xmlnsxlink: "xmlns:xlink"
      },
      transform: caseInsensitiveTransform_1,
      properties: {
        xmlns: null,
        xmlnsXLink: null
      }
    });
    var booleanish$1 = types2.booleanish;
    var number$2 = types2.number;
    var spaceSeparated$2 = types2.spaceSeparated;
    var aria = create_1({
      transform: ariaTransform,
      properties: {
        ariaActiveDescendant: null,
        ariaAtomic: booleanish$1,
        ariaAutoComplete: null,
        ariaBusy: booleanish$1,
        ariaChecked: booleanish$1,
        ariaColCount: number$2,
        ariaColIndex: number$2,
        ariaColSpan: number$2,
        ariaControls: spaceSeparated$2,
        ariaCurrent: null,
        ariaDescribedBy: spaceSeparated$2,
        ariaDetails: null,
        ariaDisabled: booleanish$1,
        ariaDropEffect: spaceSeparated$2,
        ariaErrorMessage: null,
        ariaExpanded: booleanish$1,
        ariaFlowTo: spaceSeparated$2,
        ariaGrabbed: booleanish$1,
        ariaHasPopup: null,
        ariaHidden: booleanish$1,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: spaceSeparated$2,
        ariaLevel: number$2,
        ariaLive: null,
        ariaModal: booleanish$1,
        ariaMultiLine: booleanish$1,
        ariaMultiSelectable: booleanish$1,
        ariaOrientation: null,
        ariaOwns: spaceSeparated$2,
        ariaPlaceholder: null,
        ariaPosInSet: number$2,
        ariaPressed: booleanish$1,
        ariaReadOnly: booleanish$1,
        ariaRelevant: null,
        ariaRequired: booleanish$1,
        ariaRoleDescription: spaceSeparated$2,
        ariaRowCount: number$2,
        ariaRowIndex: number$2,
        ariaRowSpan: number$2,
        ariaSelected: booleanish$1,
        ariaSetSize: number$2,
        ariaSort: null,
        ariaValueMax: number$2,
        ariaValueMin: number$2,
        ariaValueNow: number$2,
        ariaValueText: null,
        role: null
      }
    });
    function ariaTransform(_, prop2) {
      return prop2 === "role" ? prop2 : "aria-" + prop2.slice(4).toLowerCase();
    }
    var boolean$1 = types2.boolean;
    var overloadedBoolean = types2.overloadedBoolean;
    var booleanish = types2.booleanish;
    var number$1 = types2.number;
    var spaceSeparated$1 = types2.spaceSeparated;
    var commaSeparated$1 = types2.commaSeparated;
    var html$2 = create_1({
      space: "html",
      attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
      },
      transform: caseInsensitiveTransform_1,
      mustUseProperty: ["checked", "multiple", "muted", "selected"],
      properties: {
        abbr: null,
        accept: commaSeparated$1,
        acceptCharset: spaceSeparated$1,
        accessKey: spaceSeparated$1,
        action: null,
        allow: null,
        allowFullScreen: boolean$1,
        allowPaymentRequest: boolean$1,
        allowUserMedia: boolean$1,
        alt: null,
        as: null,
        async: boolean$1,
        autoCapitalize: null,
        autoComplete: spaceSeparated$1,
        autoFocus: boolean$1,
        autoPlay: boolean$1,
        capture: boolean$1,
        charSet: null,
        checked: boolean$1,
        cite: null,
        className: spaceSeparated$1,
        cols: number$1,
        colSpan: null,
        content: null,
        contentEditable: booleanish,
        controls: boolean$1,
        controlsList: spaceSeparated$1,
        coords: number$1 | commaSeparated$1,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean$1,
        defer: boolean$1,
        dir: null,
        dirName: null,
        disabled: boolean$1,
        download: overloadedBoolean,
        draggable: booleanish,
        encType: null,
        enterKeyHint: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean$1,
        formTarget: null,
        headers: spaceSeparated$1,
        height: number$1,
        hidden: boolean$1,
        high: number$1,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated$1,
        httpEquiv: spaceSeparated$1,
        id: null,
        imageSizes: null,
        imageSrcSet: commaSeparated$1,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean$1,
        itemId: null,
        itemProp: spaceSeparated$1,
        itemRef: spaceSeparated$1,
        itemScope: boolean$1,
        itemType: spaceSeparated$1,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loop: boolean$1,
        low: number$1,
        manifest: null,
        max: null,
        maxLength: number$1,
        media: null,
        method: null,
        min: null,
        minLength: number$1,
        multiple: boolean$1,
        muted: boolean$1,
        name: null,
        nonce: null,
        noModule: boolean$1,
        noValidate: boolean$1,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextMenu: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean$1,
        optimum: number$1,
        pattern: null,
        ping: spaceSeparated$1,
        placeholder: null,
        playsInline: boolean$1,
        poster: null,
        preload: null,
        readOnly: boolean$1,
        referrerPolicy: null,
        rel: spaceSeparated$1,
        required: boolean$1,
        reversed: boolean$1,
        rows: number$1,
        rowSpan: number$1,
        sandbox: spaceSeparated$1,
        scope: null,
        scoped: boolean$1,
        seamless: boolean$1,
        selected: boolean$1,
        shape: null,
        size: number$1,
        sizes: null,
        slot: null,
        span: number$1,
        spellCheck: booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: commaSeparated$1,
        start: number$1,
        step: null,
        style: null,
        tabIndex: number$1,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean$1,
        useMap: null,
        value: booleanish,
        width: number$1,
        wrap: null,
        align: null,
        aLink: null,
        archive: spaceSeparated$1,
        axis: null,
        background: null,
        bgColor: null,
        border: number$1,
        borderColor: null,
        bottomMargin: number$1,
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: boolean$1,
        declare: boolean$1,
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: number$1,
        leftMargin: number$1,
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: number$1,
        marginWidth: number$1,
        noResize: boolean$1,
        noHref: boolean$1,
        noShade: boolean$1,
        noWrap: boolean$1,
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: number$1,
        rules: null,
        scheme: null,
        scrolling: booleanish,
        standby: null,
        summary: null,
        text: null,
        topMargin: number$1,
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: number$1,
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean$1,
        disableRemotePlayback: boolean$1,
        prefix: null,
        property: null,
        results: number$1,
        security: null,
        unselectable: null
      }
    });
    var html_1 = merge_1([xml, xlink, xmlns, aria, html$2]);
    var boolean = types2.boolean;
    var number = types2.number;
    var spaceSeparated = types2.spaceSeparated;
    var commaSeparated = types2.commaSeparated;
    var commaOrSpaceSeparated = types2.commaOrSpaceSeparated;
    var svg = create_1({
      space: "svg",
      attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
      },
      transform: caseSensitiveTransform_1,
      properties: {
        about: commaOrSpaceSeparated,
        accentHeight: number,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: number,
        amplitude: number,
        arabicForm: null,
        ascent: number,
        attributeName: null,
        attributeType: null,
        azimuth: number,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: number,
        by: null,
        calcMode: null,
        capHeight: number,
        className: spaceSeparated,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: number,
        diffuseConstant: number,
        direction: null,
        display: null,
        dur: null,
        divisor: number,
        dominantBaseline: null,
        download: boolean,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: number,
        enableBackground: null,
        end: null,
        event: null,
        exponent: number,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: number,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: commaSeparated,
        g2: commaSeparated,
        glyphName: commaSeparated,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: number,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: number,
        horizOriginX: number,
        horizOriginY: number,
        id: null,
        ideographic: number,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: number,
        k: number,
        k1: number,
        k2: number,
        k3: number,
        k4: number,
        kernelMatrix: commaOrSpaceSeparated,
        kernelUnitLength: null,
        keyPoints: null,
        keySplines: null,
        keyTimes: null,
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: number,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: number,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: number,
        overlineThickness: number,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: number,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: spaceSeparated,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: number,
        pointsAtY: number,
        pointsAtZ: number,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: commaOrSpaceSeparated,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: commaOrSpaceSeparated,
        rev: commaOrSpaceSeparated,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: commaOrSpaceSeparated,
        requiredFeatures: commaOrSpaceSeparated,
        requiredFonts: commaOrSpaceSeparated,
        requiredFormats: commaOrSpaceSeparated,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: number,
        specularExponent: number,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: number,
        strikethroughThickness: number,
        string: null,
        stroke: null,
        strokeDashArray: commaOrSpaceSeparated,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: number,
        strokeOpacity: number,
        strokeWidth: null,
        style: null,
        surfaceScale: number,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: commaOrSpaceSeparated,
        tabIndex: number,
        tableValues: null,
        target: null,
        targetX: number,
        targetY: number,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: commaOrSpaceSeparated,
        to: null,
        transform: null,
        u1: null,
        u2: null,
        underlinePosition: number,
        underlineThickness: number,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: number,
        values: null,
        vAlphabetic: number,
        vMathematical: number,
        vectorEffect: null,
        vHanging: number,
        vIdeographic: number,
        version: null,
        vertAdvY: number,
        vertOriginX: number,
        vertOriginY: number,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: number,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
      }
    });
    var svg_1 = merge_1([xml, xlink, xmlns, aria, svg]);
    var index$2 = [
      "area",
      "base",
      "basefont",
      "bgsound",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "image",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "nextid",
      "param",
      "source",
      "track",
      "wbr"
    ];
    var htmlVoidElements = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      "default": index$2
    });
    var unistUtilIs = is;
    function is(test, node, index3, parent, context2) {
      var hasParent = parent !== null && parent !== void 0;
      var hasIndex = index3 !== null && index3 !== void 0;
      var check2 = convert(test);
      if (hasIndex && (typeof index3 !== "number" || index3 < 0 || index3 === Infinity)) {
        throw new Error("Expected positive finite index or child node");
      }
      if (hasParent && (!is(null, parent) || !parent.children)) {
        throw new Error("Expected parent node");
      }
      if (!node || !node.type || typeof node.type !== "string") {
        return false;
      }
      if (hasParent !== hasIndex) {
        throw new Error("Expected both parent and index");
      }
      return Boolean(check2.call(context2, node, index3, parent));
    }
    function convert(test) {
      if (typeof test === "string") {
        return typeFactory(test);
      }
      if (test === null || test === void 0) {
        return ok;
      }
      if (typeof test === "object") {
        return ("length" in test ? anyFactory : matchesFactory)(test);
      }
      if (typeof test === "function") {
        return test;
      }
      throw new Error("Expected function, string, or object as test");
    }
    function convertAll(tests2) {
      var results = [];
      var length = tests2.length;
      var index3 = -1;
      while (++index3 < length) {
        results[index3] = convert(tests2[index3]);
      }
      return results;
    }
    function matchesFactory(test) {
      return matches;
      function matches(node) {
        var key;
        for (key in test) {
          if (node[key] !== test[key]) {
            return false;
          }
        }
        return true;
      }
    }
    function anyFactory(tests2) {
      var checks2 = convertAll(tests2);
      var length = checks2.length;
      return matches;
      function matches() {
        var index3 = -1;
        while (++index3 < length) {
          if (checks2[index3].apply(this, arguments)) {
            return true;
          }
        }
        return false;
      }
    }
    function typeFactory(test) {
      return type2;
      function type2(node) {
        return Boolean(node && node.type === test);
      }
    }
    function ok() {
      return true;
    }
    var hastUtilIsElement = isElement;
    function isElement(node, tagNames) {
      var name2;
      if (!(tagNames === null || tagNames === void 0 || typeof tagNames === "string" || typeof tagNames === "object" && tagNames.length !== 0)) {
        throw new Error("Expected `string` or `Array.<string>` for `tagNames`, not `" + tagNames + "`");
      }
      if (!node || typeof node !== "object" || node.type !== "element" || typeof node.tagName !== "string") {
        return false;
      }
      if (tagNames === null || tagNames === void 0) {
        return true;
      }
      name2 = node.tagName;
      if (typeof tagNames === "string") {
        return name2 === tagNames;
      }
      return tagNames.indexOf(name2) !== -1;
    }
    var hastUtilWhitespace = interElementWhiteSpace;
    var re = /[ \t\n\f\r]/g;
    function interElementWhiteSpace(node) {
      var value;
      if (node && typeof node === "object" && node.type === "text") {
        value = node.value || "";
      } else if (typeof node === "string") {
        value = node;
      } else {
        return false;
      }
      return value.replace(re, "") === "";
    }
    var before$1 = siblings(-1);
    var after$2 = siblings(1);
    function siblings(increment2) {
      return sibling;
      function sibling(parent, index3, includeWhiteSpace) {
        var siblings2 = parent && parent.children;
        var next;
        index3 += increment2;
        next = siblings2 && siblings2[index3];
        if (!includeWhiteSpace) {
          while (next && hastUtilWhitespace(next)) {
            index3 += increment2;
            next = siblings2[index3];
          }
        }
        return next;
      }
    }
    var siblings_1 = {
      before: before$1,
      after: after$2
    };
    var after$1 = siblings_1.after;
    var first_1 = first;
    function first(parent, includeWhiteSpace) {
      return after$1(parent, -1, includeWhiteSpace);
    }
    var place_1 = place;
    function place(parent, child) {
      return parent && parent.children && parent.children.indexOf(child);
    }
    var whiteSpaceLeft_1 = whiteSpaceLeft;
    function whiteSpaceLeft(node) {
      return unistUtilIs("text", node) && hastUtilWhitespace(node.value.charAt(0));
    }
    var omission_1 = omission$1;
    var own$5 = {}.hasOwnProperty;
    function omission$1(handlers2) {
      return omit;
      function omit(node, index3, parent) {
        var name2 = node.tagName;
        var fn = own$5.call(handlers2, name2) ? handlers2[name2] : false;
        return fn ? fn(node, index3, parent) : false;
      }
    }
    var after = siblings_1.after;
    var optionGroup = "optgroup";
    var options3 = ["option"].concat(optionGroup);
    var dataListItem = ["dt", "dd"];
    var listItem = "li";
    var menuContent = ["menuitem", "hr", "menu"];
    var ruby = ["rp", "rt"];
    var tableContainer = ["tbody", "tfoot"];
    var tableRow$1 = "tr";
    var tableCell = ["td", "th"];
    var confusingParagraphParent = ["a", "audio", "del", "ins", "map", "noscript", "video"];
    var clearParagraphSibling = [
      "address",
      "article",
      "aside",
      "blockquote",
      "details",
      "div",
      "dl",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "hr",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "table",
      "ul"
    ];
    var closing$1 = omission_1({
      html: html$1,
      head: headOrColgroupOrCaption,
      body: body$1,
      p,
      li,
      dt,
      dd,
      rt: rubyElement,
      rp: rubyElement,
      optgroup,
      option,
      menuitem,
      colgroup: headOrColgroupOrCaption,
      caption: headOrColgroupOrCaption,
      thead,
      tbody: tbody$1,
      tfoot,
      tr,
      td: cells,
      th: cells
    });
    function headOrColgroupOrCaption(node, index3, parent) {
      var next = after(parent, index3, true);
      return !next || !unistUtilIs("comment", next) && !whiteSpaceLeft_1(next);
    }
    function html$1(node, index3, parent) {
      var next = after(parent, index3);
      return !next || !unistUtilIs("comment", next);
    }
    function body$1(node, index3, parent) {
      var next = after(parent, index3);
      return !next || !unistUtilIs("comment", next);
    }
    function p(node, index3, parent) {
      var next = after(parent, index3);
      return next ? hastUtilIsElement(next, clearParagraphSibling) : !parent || !hastUtilIsElement(parent, confusingParagraphParent);
    }
    function li(node, index3, parent) {
      var next = after(parent, index3);
      return !next || hastUtilIsElement(next, listItem);
    }
    function dt(node, index3, parent) {
      var next = after(parent, index3);
      return next && hastUtilIsElement(next, dataListItem);
    }
    function dd(node, index3, parent) {
      var next = after(parent, index3);
      return !next || hastUtilIsElement(next, dataListItem);
    }
    function rubyElement(node, index3, parent) {
      var next = after(parent, index3);
      return !next || hastUtilIsElement(next, ruby);
    }
    function optgroup(node, index3, parent) {
      var next = after(parent, index3);
      return !next || hastUtilIsElement(next, optionGroup);
    }
    function option(node, index3, parent) {
      var next = after(parent, index3);
      return !next || hastUtilIsElement(next, options3);
    }
    function menuitem(node, index3, parent) {
      var next = after(parent, index3);
      return !next || hastUtilIsElement(next, menuContent);
    }
    function thead(node, index3, parent) {
      var next = after(parent, index3);
      return next && hastUtilIsElement(next, tableContainer);
    }
    function tbody$1(node, index3, parent) {
      var next = after(parent, index3);
      return !next || hastUtilIsElement(next, tableContainer);
    }
    function tfoot(node, index3, parent) {
      return !after(parent, index3);
    }
    function tr(node, index3, parent) {
      var next = after(parent, index3);
      return !next || hastUtilIsElement(next, tableRow$1);
    }
    function cells(node, index3, parent) {
      var next = after(parent, index3);
      return !next || hastUtilIsElement(next, tableCell);
    }
    var before = siblings_1.before;
    var own$4 = {}.hasOwnProperty;
    var uniqueHeadMetadata = ["title", "base"];
    var meta = ["meta", "link", "script", "style", "template"];
    var tableContainers = ["thead", "tbody"];
    var tableRow = "tr";
    var opening$1 = omission_1({
      html,
      head,
      body,
      colgroup,
      tbody
    });
    function html(node) {
      var head2 = first_1(node);
      return !head2 || !unistUtilIs("comment", head2);
    }
    function head(node) {
      var children = node.children;
      var length = children.length;
      var map2 = {};
      var index3 = -1;
      var child;
      var name2;
      while (++index3 < length) {
        child = children[index3];
        name2 = child.tagName;
        if (hastUtilIsElement(child, uniqueHeadMetadata)) {
          if (own$4.call(map2, name2)) {
            return false;
          }
          map2[name2] = true;
        }
      }
      return Boolean(length);
    }
    function body(node) {
      var head2 = first_1(node, true);
      return !head2 || !unistUtilIs("comment", head2) && !whiteSpaceLeft_1(head2) && !hastUtilIsElement(head2, meta);
    }
    function colgroup(node, index3, parent) {
      var prev = before(parent, index3);
      var head2 = first_1(node, true);
      if (hastUtilIsElement(prev, "colgroup") && closing$1(prev, place_1(parent, prev), parent)) {
        return false;
      }
      return head2 && hastUtilIsElement(head2, "col");
    }
    function tbody(node, index3, parent) {
      var prev = before(parent, index3);
      var head2 = first_1(node);
      if (hastUtilIsElement(prev, tableContainers) && closing$1(prev, place_1(parent, prev), parent)) {
        return false;
      }
      return head2 && hastUtilIsElement(head2, tableRow);
    }
    var opening = opening$1;
    var closing = closing$1;
    var omission = {
      opening,
      closing
    };
    var index$1 = [
      "script",
      "style",
      "pre",
      "textarea"
    ];
    var htmlWhitespaceSensitiveTagNames = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      "default": index$1
    });
    var sensitive = getCjsExportFromNamespace(htmlWhitespaceSensitiveTagNames);
    var all_1 = all$1;
    function all$1(ctx, parent) {
      var children = parent && parent.children;
      var length = children && children.length;
      var index3 = -1;
      var results = [];
      let printWidthOffset = 0;
      let innerTextLength = 0;
      while (++index3 < length) {
        innerTextLength = getInnerTextLength(children[index3]);
        results[index3] = one_1(ctx, children[index3], index3, parent, printWidthOffset, innerTextLength);
        printWidthOffset = results[index3].replace(/\n+/g, "").length;
      }
      return results.join("");
    }
    function getInnerTextLength(node) {
      if (sensitive.indexOf(node.tagName) !== -1) {
        return 0;
      }
      if (!node.children || !node.children.length) {
        return 0;
      }
      var child = node.children[0];
      if (child.type === "text" || child.type === "comment") {
        return child.value.split("\n")[0].length;
      }
      return 0;
    }
    var text_1 = text;
    function text(ctx, node, index3, parent) {
      var value = node.value;
      return value;
    }
    var data = "data";
    var find_1 = find;
    var valid = /^data[-\w.:]+$/i;
    var dash = /-[a-z]/g;
    var cap$1 = /[A-Z]/g;
    function find(schema2, value) {
      var normal = normalize_1(value);
      var prop2 = value;
      var Type2 = info;
      if (normal in schema2.normal) {
        return schema2.property[schema2.normal[normal]];
      }
      if (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value)) {
        if (value.charAt(4) === "-") {
          prop2 = datasetToProperty(value);
        } else {
          value = datasetToAttribute(value);
        }
        Type2 = definedInfo;
      }
      return new Type2(prop2, value);
    }
    function datasetToProperty(attribute2) {
      var value = attribute2.slice(5).replace(dash, camelcase);
      return data + value.charAt(0).toUpperCase() + value.slice(1);
    }
    function datasetToAttribute(property) {
      var value = property.slice(4);
      if (dash.test(value)) {
        return property;
      }
      value = value.replace(cap$1, kebab);
      if (value.charAt(0) !== "-") {
        value = "-" + value;
      }
      return data + value;
    }
    function kebab($0) {
      return "-" + $0.toLowerCase();
    }
    function camelcase($0) {
      return $0.charAt(1).toUpperCase();
    }
    var parse_1 = parse$2;
    var stringify_1 = stringify$2;
    var comma = ",";
    var space$2 = " ";
    var empty$1 = "";
    function parse$2(value) {
      var values2 = [];
      var input = String(value || empty$1);
      var index3 = input.indexOf(comma);
      var lastIndex = 0;
      var end2 = false;
      var val;
      while (!end2) {
        if (index3 === -1) {
          index3 = input.length;
          end2 = true;
        }
        val = input.slice(lastIndex, index3).trim();
        if (val || !end2) {
          values2.push(val);
        }
        lastIndex = index3 + 1;
        index3 = input.indexOf(comma, lastIndex);
      }
      return values2;
    }
    function stringify$2(values2, options4) {
      var settings = options4 || {};
      var left2 = settings.padLeft === false ? empty$1 : space$2;
      var right2 = settings.padRight ? space$2 : empty$1;
      if (values2[values2.length - 1] === empty$1) {
        values2 = values2.concat(empty$1);
      }
      return values2.join(right2 + comma + left2).trim();
    }
    var commaSeparatedTokens = {
      parse: parse_1,
      stringify: stringify_1
    };
    var nbsp = "\xA0";
    var iexcl = "\xA1";
    var cent = "\xA2";
    var pound = "\xA3";
    var curren = "\xA4";
    var yen = "\xA5";
    var brvbar = "\xA6";
    var sect = "\xA7";
    var uml = "\xA8";
    var copy = "\xA9";
    var ordf = "\xAA";
    var laquo = "\xAB";
    var not = "\xAC";
    var shy = "\xAD";
    var reg = "\xAE";
    var macr = "\xAF";
    var deg = "\xB0";
    var plusmn = "\xB1";
    var sup2 = "\xB2";
    var sup3 = "\xB3";
    var acute = "\xB4";
    var micro = "\xB5";
    var para = "\xB6";
    var middot = "\xB7";
    var cedil = "\xB8";
    var sup1 = "\xB9";
    var ordm = "\xBA";
    var raquo = "\xBB";
    var frac14 = "\xBC";
    var frac12 = "\xBD";
    var frac34 = "\xBE";
    var iquest = "\xBF";
    var Agrave = "\xC0";
    var Aacute = "\xC1";
    var Acirc = "\xC2";
    var Atilde = "\xC3";
    var Auml = "\xC4";
    var Aring = "\xC5";
    var AElig = "\xC6";
    var Ccedil = "\xC7";
    var Egrave = "\xC8";
    var Eacute = "\xC9";
    var Ecirc = "\xCA";
    var Euml = "\xCB";
    var Igrave = "\xCC";
    var Iacute = "\xCD";
    var Icirc = "\xCE";
    var Iuml = "\xCF";
    var ETH = "\xD0";
    var Ntilde = "\xD1";
    var Ograve = "\xD2";
    var Oacute = "\xD3";
    var Ocirc = "\xD4";
    var Otilde = "\xD5";
    var Ouml = "\xD6";
    var times = "\xD7";
    var Oslash = "\xD8";
    var Ugrave = "\xD9";
    var Uacute = "\xDA";
    var Ucirc = "\xDB";
    var Uuml = "\xDC";
    var Yacute = "\xDD";
    var THORN = "\xDE";
    var szlig = "\xDF";
    var agrave = "\xE0";
    var aacute = "\xE1";
    var acirc = "\xE2";
    var atilde = "\xE3";
    var auml = "\xE4";
    var aring = "\xE5";
    var aelig = "\xE6";
    var ccedil = "\xE7";
    var egrave = "\xE8";
    var eacute = "\xE9";
    var ecirc = "\xEA";
    var euml = "\xEB";
    var igrave = "\xEC";
    var iacute = "\xED";
    var icirc = "\xEE";
    var iuml = "\xEF";
    var eth = "\xF0";
    var ntilde = "\xF1";
    var ograve = "\xF2";
    var oacute = "\xF3";
    var ocirc = "\xF4";
    var otilde = "\xF5";
    var ouml = "\xF6";
    var divide = "\xF7";
    var oslash = "\xF8";
    var ugrave = "\xF9";
    var uacute = "\xFA";
    var ucirc = "\xFB";
    var uuml = "\xFC";
    var yacute = "\xFD";
    var thorn = "\xFE";
    var yuml = "\xFF";
    var fnof = "\u0192";
    var Alpha = "\u0391";
    var Beta = "\u0392";
    var Gamma = "\u0393";
    var Delta = "\u0394";
    var Epsilon = "\u0395";
    var Zeta = "\u0396";
    var Eta = "\u0397";
    var Theta = "\u0398";
    var Iota = "\u0399";
    var Kappa = "\u039A";
    var Lambda = "\u039B";
    var Mu = "\u039C";
    var Nu = "\u039D";
    var Xi = "\u039E";
    var Omicron = "\u039F";
    var Pi = "\u03A0";
    var Rho = "\u03A1";
    var Sigma = "\u03A3";
    var Tau = "\u03A4";
    var Upsilon = "\u03A5";
    var Phi = "\u03A6";
    var Chi = "\u03A7";
    var Psi = "\u03A8";
    var Omega = "\u03A9";
    var alpha = "\u03B1";
    var beta = "\u03B2";
    var gamma = "\u03B3";
    var delta = "\u03B4";
    var epsilon = "\u03B5";
    var zeta = "\u03B6";
    var eta = "\u03B7";
    var theta = "\u03B8";
    var iota = "\u03B9";
    var kappa = "\u03BA";
    var lambda = "\u03BB";
    var mu = "\u03BC";
    var nu = "\u03BD";
    var xi = "\u03BE";
    var omicron = "\u03BF";
    var pi = "\u03C0";
    var rho = "\u03C1";
    var sigmaf = "\u03C2";
    var sigma = "\u03C3";
    var tau = "\u03C4";
    var upsilon = "\u03C5";
    var phi = "\u03C6";
    var chi = "\u03C7";
    var psi = "\u03C8";
    var omega = "\u03C9";
    var thetasym = "\u03D1";
    var upsih = "\u03D2";
    var piv = "\u03D6";
    var bull = "\u2022";
    var hellip = "\u2026";
    var prime = "\u2032";
    var Prime = "\u2033";
    var oline = "\u203E";
    var frasl = "\u2044";
    var weierp = "\u2118";
    var image = "\u2111";
    var real = "\u211C";
    var trade = "\u2122";
    var alefsym = "\u2135";
    var larr = "\u2190";
    var uarr = "\u2191";
    var rarr = "\u2192";
    var darr = "\u2193";
    var harr = "\u2194";
    var crarr = "\u21B5";
    var lArr = "\u21D0";
    var uArr = "\u21D1";
    var rArr = "\u21D2";
    var dArr = "\u21D3";
    var hArr = "\u21D4";
    var forall = "\u2200";
    var part = "\u2202";
    var exist = "\u2203";
    var empty2 = "\u2205";
    var nabla = "\u2207";
    var isin = "\u2208";
    var notin = "\u2209";
    var ni = "\u220B";
    var prod = "\u220F";
    var sum = "\u2211";
    var minus = "\u2212";
    var lowast = "\u2217";
    var radic = "\u221A";
    var prop = "\u221D";
    var infin = "\u221E";
    var ang = "\u2220";
    var and = "\u2227";
    var or = "\u2228";
    var cap = "\u2229";
    var cup = "\u222A";
    var int = "\u222B";
    var there4 = "\u2234";
    var sim = "\u223C";
    var cong = "\u2245";
    var asymp = "\u2248";
    var ne = "\u2260";
    var equiv = "\u2261";
    var le = "\u2264";
    var ge = "\u2265";
    var sub = "\u2282";
    var sup = "\u2283";
    var nsub = "\u2284";
    var sube = "\u2286";
    var supe = "\u2287";
    var oplus = "\u2295";
    var otimes = "\u2297";
    var perp = "\u22A5";
    var sdot = "\u22C5";
    var lceil = "\u2308";
    var rceil = "\u2309";
    var lfloor = "\u230A";
    var rfloor = "\u230B";
    var lang = "\u2329";
    var rang = "\u232A";
    var loz = "\u25CA";
    var spades = "\u2660";
    var clubs = "\u2663";
    var hearts = "\u2665";
    var diams = "\u2666";
    var quot = '"';
    var amp = "&";
    var lt = "<";
    var gt = ">";
    var OElig = "\u0152";
    var oelig = "\u0153";
    var Scaron = "\u0160";
    var scaron = "\u0161";
    var Yuml = "\u0178";
    var circ = "\u02C6";
    var tilde = "\u02DC";
    var ensp = "\u2002";
    var emsp = "\u2003";
    var thinsp = "\u2009";
    var zwnj = "\u200C";
    var zwj = "\u200D";
    var lrm = "\u200E";
    var rlm = "\u200F";
    var ndash = "\u2013";
    var mdash = "\u2014";
    var lsquo = "\u2018";
    var rsquo = "\u2019";
    var sbquo = "\u201A";
    var ldquo = "\u201C";
    var rdquo = "\u201D";
    var bdquo = "\u201E";
    var dagger = "\u2020";
    var Dagger = "\u2021";
    var permil = "\u2030";
    var lsaquo = "\u2039";
    var rsaquo = "\u203A";
    var euro = "\u20AC";
    var index2 = {
      nbsp,
      iexcl,
      cent,
      pound,
      curren,
      yen,
      brvbar,
      sect,
      uml,
      copy,
      ordf,
      laquo,
      not,
      shy,
      reg,
      macr,
      deg,
      plusmn,
      sup2,
      sup3,
      acute,
      micro,
      para,
      middot,
      cedil,
      sup1,
      ordm,
      raquo,
      frac14,
      frac12,
      frac34,
      iquest,
      Agrave,
      Aacute,
      Acirc,
      Atilde,
      Auml,
      Aring,
      AElig,
      Ccedil,
      Egrave,
      Eacute,
      Ecirc,
      Euml,
      Igrave,
      Iacute,
      Icirc,
      Iuml,
      ETH,
      Ntilde,
      Ograve,
      Oacute,
      Ocirc,
      Otilde,
      Ouml,
      times,
      Oslash,
      Ugrave,
      Uacute,
      Ucirc,
      Uuml,
      Yacute,
      THORN,
      szlig,
      agrave,
      aacute,
      acirc,
      atilde,
      auml,
      aring,
      aelig,
      ccedil,
      egrave,
      eacute,
      ecirc,
      euml,
      igrave,
      iacute,
      icirc,
      iuml,
      eth,
      ntilde,
      ograve,
      oacute,
      ocirc,
      otilde,
      ouml,
      divide,
      oslash,
      ugrave,
      uacute,
      ucirc,
      uuml,
      yacute,
      thorn,
      yuml,
      fnof,
      Alpha,
      Beta,
      Gamma,
      Delta,
      Epsilon,
      Zeta,
      Eta,
      Theta,
      Iota,
      Kappa,
      Lambda,
      Mu,
      Nu,
      Xi,
      Omicron,
      Pi,
      Rho,
      Sigma,
      Tau,
      Upsilon,
      Phi,
      Chi,
      Psi,
      Omega,
      alpha,
      beta,
      gamma,
      delta,
      epsilon,
      zeta,
      eta,
      theta,
      iota,
      kappa,
      lambda,
      mu,
      nu,
      xi,
      omicron,
      pi,
      rho,
      sigmaf,
      sigma,
      tau,
      upsilon,
      phi,
      chi,
      psi,
      omega,
      thetasym,
      upsih,
      piv,
      bull,
      hellip,
      prime,
      Prime,
      oline,
      frasl,
      weierp,
      image,
      real,
      trade,
      alefsym,
      larr,
      uarr,
      rarr,
      darr,
      harr,
      crarr,
      lArr,
      uArr,
      rArr,
      dArr,
      hArr,
      forall,
      part,
      exist,
      empty: empty2,
      nabla,
      isin,
      notin,
      ni,
      prod,
      sum,
      minus,
      lowast,
      radic,
      prop,
      infin,
      ang,
      and,
      or,
      cap,
      cup,
      int,
      there4,
      sim,
      cong,
      asymp,
      ne,
      equiv,
      le,
      ge,
      sub,
      sup,
      nsub,
      sube,
      supe,
      oplus,
      otimes,
      perp,
      sdot,
      lceil,
      rceil,
      lfloor,
      rfloor,
      lang,
      rang,
      loz,
      spades,
      clubs,
      hearts,
      diams,
      quot,
      amp,
      lt,
      gt,
      OElig,
      oelig,
      Scaron,
      scaron,
      Yuml,
      circ,
      tilde,
      ensp,
      emsp,
      thinsp,
      zwnj,
      zwj,
      lrm,
      rlm,
      ndash,
      mdash,
      lsquo,
      rsquo,
      sbquo,
      ldquo,
      rdquo,
      bdquo,
      dagger,
      Dagger,
      permil,
      lsaquo,
      rsaquo,
      euro
    };
    var characterEntitiesHtml4 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      nbsp,
      iexcl,
      cent,
      pound,
      curren,
      yen,
      brvbar,
      sect,
      uml,
      copy,
      ordf,
      laquo,
      not,
      shy,
      reg,
      macr,
      deg,
      plusmn,
      sup2,
      sup3,
      acute,
      micro,
      para,
      middot,
      cedil,
      sup1,
      ordm,
      raquo,
      frac14,
      frac12,
      frac34,
      iquest,
      Agrave,
      Aacute,
      Acirc,
      Atilde,
      Auml,
      Aring,
      AElig,
      Ccedil,
      Egrave,
      Eacute,
      Ecirc,
      Euml,
      Igrave,
      Iacute,
      Icirc,
      Iuml,
      ETH,
      Ntilde,
      Ograve,
      Oacute,
      Ocirc,
      Otilde,
      Ouml,
      times,
      Oslash,
      Ugrave,
      Uacute,
      Ucirc,
      Uuml,
      Yacute,
      THORN,
      szlig,
      agrave,
      aacute,
      acirc,
      atilde,
      auml,
      aring,
      aelig,
      ccedil,
      egrave,
      eacute,
      ecirc,
      euml,
      igrave,
      iacute,
      icirc,
      iuml,
      eth,
      ntilde,
      ograve,
      oacute,
      ocirc,
      otilde,
      ouml,
      divide,
      oslash,
      ugrave,
      uacute,
      ucirc,
      uuml,
      yacute,
      thorn,
      yuml,
      fnof,
      Alpha,
      Beta,
      Gamma,
      Delta,
      Epsilon,
      Zeta,
      Eta,
      Theta,
      Iota,
      Kappa,
      Lambda,
      Mu,
      Nu,
      Xi,
      Omicron,
      Pi,
      Rho,
      Sigma,
      Tau,
      Upsilon,
      Phi,
      Chi,
      Psi,
      Omega,
      alpha,
      beta,
      gamma,
      delta,
      epsilon,
      zeta,
      eta,
      theta,
      iota,
      kappa,
      lambda,
      mu,
      nu,
      xi,
      omicron,
      pi,
      rho,
      sigmaf,
      sigma,
      tau,
      upsilon,
      phi,
      chi,
      psi,
      omega,
      thetasym,
      upsih,
      piv,
      bull,
      hellip,
      prime,
      Prime,
      oline,
      frasl,
      weierp,
      image,
      real,
      trade,
      alefsym,
      larr,
      uarr,
      rarr,
      darr,
      harr,
      crarr,
      lArr,
      uArr,
      rArr,
      dArr,
      hArr,
      forall,
      part,
      exist,
      empty: empty2,
      nabla,
      isin,
      notin,
      ni,
      prod,
      sum,
      minus,
      lowast,
      radic,
      prop,
      infin,
      ang,
      and,
      or,
      cap,
      cup,
      int,
      there4,
      sim,
      cong,
      asymp,
      ne,
      equiv,
      le,
      ge,
      sub,
      sup,
      nsub,
      sube,
      supe,
      oplus,
      otimes,
      perp,
      sdot,
      lceil,
      rceil,
      lfloor,
      rfloor,
      lang,
      rang,
      loz,
      spades,
      clubs,
      hearts,
      diams,
      quot,
      amp,
      lt,
      gt,
      OElig,
      oelig,
      Scaron,
      scaron,
      Yuml,
      circ,
      tilde,
      ensp,
      emsp,
      thinsp,
      zwnj,
      zwj,
      lrm,
      rlm,
      ndash,
      mdash,
      lsquo,
      rsquo,
      sbquo,
      ldquo,
      rdquo,
      bdquo,
      dagger,
      Dagger,
      permil,
      lsaquo,
      rsaquo,
      euro,
      "default": index2
    });
    var dangerous$1 = [
      "cent",
      "copy",
      "divide",
      "gt",
      "lt",
      "not",
      "para",
      "times"
    ];
    var dangerous$2 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      "default": dangerous$1
    });
    var entities = getCjsExportFromNamespace(characterEntitiesHtml4);
    var dangerous = getCjsExportFromNamespace(dangerous$2);
    var decimal = isDecimal;
    var stringifyEntities = encode;
    encode.escape = escape3;
    var own$3 = {}.hasOwnProperty;
    var escapes = ['"', "'", "<", ">", "&", "`"];
    var characters = construct();
    var defaultEscapes = toExpression(escapes);
    var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var bmp = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
    function encode(value, options4) {
      var settings = options4 || {};
      var subset2 = settings.subset;
      var set2 = subset2 ? toExpression(subset2) : defaultEscapes;
      var escapeOnly = settings.escapeOnly;
      var omit = settings.omitOptionalSemicolons;
      value = value.replace(set2, replace);
      if (subset2 || escapeOnly) {
        return value;
      }
      return value.replace(surrogatePair, replaceSurrogatePair).replace(bmp, replace);
      function replaceSurrogatePair(pair, pos, val) {
        return toHexReference((pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536, val.charAt(pos + 2), omit);
      }
      function replace(char, pos, val) {
        return one$1(char, val.charAt(pos + 1), settings);
      }
    }
    function escape3(value) {
      return encode(value, { escapeOnly: true, useNamedReferences: true });
    }
    function one$1(char, next, options4) {
      var shortest = options4.useShortestReferences;
      var omit = options4.omitOptionalSemicolons;
      var named;
      var code2;
      var numeric;
      var decimal2;
      if ((shortest || options4.useNamedReferences) && own$3.call(characters, char)) {
        named = toNamed(characters[char], next, omit, options4.attribute);
      }
      if (shortest || !named) {
        code2 = char.charCodeAt(0);
        numeric = toHexReference(code2, next, omit);
        if (shortest) {
          decimal2 = toDecimalReference(code2, next, omit);
          if (decimal2.length < numeric.length) {
            numeric = decimal2;
          }
        }
      }
      if (named && (!shortest || named.length < numeric.length)) {
        return named;
      }
      return numeric;
    }
    function toNamed(name2, next, omit, attribute2) {
      var value = "&" + name2;
      if (omit && own$3.call(legacy, name2) && dangerous.indexOf(name2) === -1 && (!attribute2 || next && next !== "=" && !isAlphanumerical(next))) {
        return value;
      }
      return value + ";";
    }
    function toHexReference(code2, next, omit) {
      var value = "&#x" + code2.toString(16).toUpperCase();
      return omit && next && !isHexadecimal(next) ? value : value + ";";
    }
    function toDecimalReference(code2, next, omit) {
      var value = "&#" + String(code2);
      return omit && next && !decimal(next) ? value : value + ";";
    }
    function toExpression(characters2) {
      return new RegExp("[" + characters2.join("") + "]", "g");
    }
    function construct() {
      var chars2 = {};
      var name2;
      for (name2 in entities) {
        chars2[entities[name2]] = name2;
      }
      return chars2;
    }
    var NULL = "\0";
    var AMP = "&";
    var SP = " ";
    var TB = "	";
    var GR = "`";
    var DQ$1 = '"';
    var SQ$1 = "'";
    var EQ = "=";
    var LT = "<";
    var GT = ">";
    var SO = "/";
    var LF = "\n";
    var CR = "\r";
    var FF = "\f";
    var whitespace = [SP, TB, LF, CR, FF];
    var name = whitespace.concat(AMP, SO, GT, EQ);
    var unquoted$1 = whitespace.concat(AMP, GT);
    var unquotedSafe = unquoted$1.concat(NULL, DQ$1, SQ$1, LT, EQ, GR);
    var singleQuoted$1 = [AMP, SQ$1];
    var doubleQuoted$1 = [AMP, DQ$1];
    var constants = {
      name: [[name, name.concat(DQ$1, SQ$1, GR)], [name.concat(NULL, DQ$1, SQ$1, LT), name.concat(NULL, DQ$1, SQ$1, LT, GR)]],
      unquoted: [[unquoted$1, unquotedSafe], [unquotedSafe, unquotedSafe]],
      single: [
        [singleQuoted$1, singleQuoted$1.concat(DQ$1, GR)],
        [singleQuoted$1.concat(NULL), singleQuoted$1.concat(NULL, DQ$1, GR)]
      ],
      double: [
        [doubleQuoted$1, doubleQuoted$1.concat(SQ$1, GR)],
        [doubleQuoted$1.concat(NULL), doubleQuoted$1.concat(NULL, SQ$1, GR)]
      ]
    };
    var spaces = spaceSeparatedTokens.stringify;
    var commas = commaSeparatedTokens.stringify;
    var element_1 = element;
    var emptyString = "";
    var space$1 = " ";
    var quotationMark = '"';
    var apostrophe$1 = "'";
    var equalsTo = "=";
    var lessThan$1 = "<";
    var greaterThan = ">";
    var slash$1 = "/";
    var newLine = "\n";
    function element(ctx, node, index3, parent, printWidthOffset, innerTextLength) {
      var parentSchema = ctx.schema;
      var name2 = node.tagName;
      var value = "";
      var selfClosing;
      var close;
      var omit;
      var root2 = node;
      var content;
      var attrs2;
      var indentLevel = getNodeData(node, "indentLevel", 0);
      var printContext = {
        offset: printWidthOffset,
        wrapAttributes: false,
        indentLevel
      };
      var isVoid = ctx.voids.indexOf(name2) !== -1;
      var ignoreAttrCollapsing = getNodeData(node, "ignore", false) || getNodeData(node, "preserveAttrWrapping", false);
      if (parentSchema.space === "html" && name2 === "svg") {
        ctx.schema = svg_1;
      }
      if (ctx.schema.space === "svg") {
        omit = false;
        close = true;
        selfClosing = ctx.closeEmpty;
      } else {
        omit = ctx.omit;
        close = ctx.close;
        selfClosing = isVoid;
      }
      if (selfClosing === false) {
        selfClosing = getNodeData(node, "selfClosing", false);
      }
      printContext.offset += lessThan$1.length;
      printContext.offset += node.tagName.length;
      if (selfClosing && !isVoid) {
        printContext.offset += slash$1.length;
      }
      printContext.offset += greaterThan.length;
      const propertyCount = Object.keys(node.properties).length;
      if (propertyCount > 1 && ctx.wrapAttributes) {
        printContext.wrapAttributes = true;
      }
      if (propertyCount) {
        printContext.offset += propertyCount * space$1.length;
      }
      printContext.offset += innerTextLength;
      attrs2 = attributes(ctx, node.properties, printContext, ignoreAttrCollapsing);
      const shouldCollapse = ignoreAttrCollapsing === false && printContext.wrapAttributes;
      content = all_1(ctx, root2);
      selfClosing = content ? false : selfClosing;
      if (attrs2 || !omit || !omit.opening(node, index3, parent)) {
        value = lessThan$1 + name2;
        if (attrs2) {
          if (shouldCollapse) {
            value += attrs2;
          } else {
            value += space$1 + attrs2;
          }
        }
        let selfClosed = false;
        if (selfClosing && close) {
          if ((!ctx.tightClose || attrs2.charAt(attrs2.length - 1) === slash$1) && !shouldCollapse) {
            value += space$1;
          }
          if (shouldCollapse) {
            value += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
          }
          selfClosed = true;
          value += slash$1;
        } else if (selfClosing && !isVoid) {
          if (shouldCollapse) {
            value += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
          }
          selfClosed = true;
          value += slash$1;
        }
        if (shouldCollapse && !selfClosed) {
          value += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
        }
        value += greaterThan;
      }
      value += content;
      if (!selfClosing && (!omit || !omit.closing(node, index3, parent))) {
        value += lessThan$1 + slash$1 + name2 + greaterThan;
      }
      ctx.schema = parentSchema;
      return value;
    }
    function attributes(ctx, props, printContext, ignoreIndent) {
      var values2 = [];
      var key;
      var value;
      var result;
      var length;
      var index3;
      var last;
      for (key in props) {
        value = props[key];
        if (value == null) {
          continue;
        }
        result = attribute$1(ctx, key, value);
        printContext.offset += result.length;
        if (ignoreIndent === false && printContext.offset > ctx.printWidth) {
          printContext.wrapAttributes = true;
        }
        if (result) {
          values2.push(result);
        }
      }
      length = values2.length;
      index3 = -1;
      while (++index3 < length) {
        result = values2[index3];
        last = null;
        if (last !== quotationMark && last !== apostrophe$1) {
          if (printContext.wrapAttributes) {
            values2[index3] = newLine + repeatString(ctx.tabWidth, printContext.indentLevel + 1) + result;
          } else if (index3 !== length - 1) {
            values2[index3] = result + space$1;
          } else {
            values2[index3] = result;
          }
        }
      }
      return values2.join(emptyString);
    }
    function attribute$1(ctx, key, value) {
      var schema2 = ctx.schema;
      var info2 = find_1(schema2, key);
      var name2 = info2.attribute;
      if (value == null || typeof value === "number" && isNaN(value) || value === false && info2.boolean) {
        return emptyString;
      }
      name2 = attributeName$1(ctx, name2);
      if (value === true && info2.boolean || value === true && info2.overloadedBoolean) {
        return name2;
      }
      return name2 + attributeValue$1(ctx, key, value, info2);
    }
    function attributeName$1(ctx, name2) {
      var valid2 = ctx.schema.space === "html" ? ctx.valid : 1;
      var subset2 = constants.name[valid2][ctx.safe];
      return stringifyEntities(name2, immutable(ctx.entities, { subset: subset2 }));
    }
    function attributeValue$1(ctx, key, value, info2) {
      var quote = ctx.quote;
      if (typeof value === "object" && "length" in value) {
        value = (info2.commaSeparated ? commas : spaces)(value, {
          padLeft: !ctx.tightLists
        });
      }
      value = String(value);
      if (value === "") {
        return value;
      } else {
        value = equalsTo + quote + value + quote;
      }
      return value;
    }
    function getNodeData(node, key, defaultValue) {
      let data2 = node.data || {};
      return data2[key] || defaultValue;
    }
    var doctype_1 = doctype;
    function doctype(ctx, node) {
      var sep = ctx.tightDoctype ? "" : " ";
      var name2 = node.name;
      var pub = node.public;
      var sys = node.system;
      var val = ["<!doctype"];
      if (name2) {
        val.push(sep, name2);
        if (pub != null) {
          val.push(" public", sep, smart(pub));
        } else if (sys != null) {
          val.push(" system");
        }
        if (sys != null) {
          val.push(sep, smart(sys));
        }
      }
      return val.join("") + ">";
    }
    function smart(value) {
      var quote = value.indexOf('"') === -1 ? '"' : "'";
      return quote + value + quote;
    }
    var comment_1 = comment;
    function comment(ctx, node) {
      return "<!--" + node.value + "-->";
    }
    var raw_1 = raw;
    function raw(ctx, node) {
      return node.value;
    }
    var one_1 = one;
    var own$2 = {}.hasOwnProperty;
    var handlers = {};
    handlers.root = all_1;
    handlers.text = text_1;
    handlers.element = element_1;
    handlers.doctype = doctype_1;
    handlers.comment = comment_1;
    handlers.raw = raw_1;
    function one(ctx, node, index3, parent, printWidthOffset, innerTextLength) {
      var type2 = node && node.type;
      if (!type2) {
        throw new Error("Expected node, not `" + node + "`");
      }
      if (!own$2.call(handlers, type2)) {
        throw new Error("Cannot compile unknown node `" + type2 + "`");
      }
      return handlers[type2](ctx, node, index3, parent, printWidthOffset, innerTextLength);
    }
    var voids = getCjsExportFromNamespace(htmlVoidElements);
    var lib$1 = toHTML;
    var DQ = '"';
    var SQ = "'";
    function toHTML(node, options4) {
      var settings = options4 || {};
      var quote = settings.singleQuote ? SQ : DQ;
      var printWidth = settings.printWidth === void 0 ? 80 : settings.printWidth;
      var useTabs = settings.useTabs;
      var tabWidth = settings.tabWidth || 2;
      var wrapAttributes = settings.wrapAttributes;
      if (useTabs) {
        tabWidth = "	";
      } else if (typeof tabWidth === "number") {
        tabWidth = repeatString(" ", tabWidth);
      }
      return one_1({
        valid: settings.allowParseErrors ? 0 : 1,
        safe: settings.allowDangerousCharacters ? 0 : 1,
        schema: settings.space === "svg" ? svg_1 : html_1,
        omit: settings.omitOptionalTags && omission,
        quote,
        printWidth,
        tabWidth,
        wrapAttributes,
        tightDoctype: Boolean(settings.tightDoctype),
        tightLists: settings.tightCommaSeparatedLists,
        voids: settings.voids || voids.concat(),
        entities: settings.entities || {},
        close: settings.closeSelfClosing,
        tightClose: settings.tightSelfClosing,
        closeEmpty: settings.closeEmptyElements
      }, node);
    }
    var prettyhtmlHastToHtml = lib$1;
    var void_els = [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    var RE_SVELTE_TAG = /^<svelte:([a-z]*)[\s\S]*(?:(?:svelte:[a-z]*)|(?:\/))>$/;
    var RE_SVELTE_TAG_START = /(^\s*)<([\\/\s])*svelte:/;
    function parse_svelte_tag(eat, value, silent) {
      const is_svelte_tag = RE_SVELTE_TAG_START.exec(value);
      if (is_svelte_tag) {
        if (silent)
          return true;
        const trimmed_value = value.trim();
        let cbPos = 0;
        let pos = 1;
        let current_tag = "";
        let in_tag_name = false;
        while (cbPos > -1) {
          if (!trimmed_value[pos]) {
            break;
          }
          if (trimmed_value[pos].match(/</)) {
            cbPos++;
            current_tag = "";
            in_tag_name = true;
          }
          if (in_tag_name && trimmed_value[pos].match(/\s/)) {
            in_tag_name = false;
          }
          if (in_tag_name && !trimmed_value[pos].match(/</)) {
            current_tag += trimmed_value[pos];
          }
          const is_void = void_els.includes(current_tag);
          if (is_void && trimmed_value[pos].match(/>/) || (trimmed_value[pos - 1] + trimmed_value[pos]).match(/\/>/)) {
            cbPos--;
          }
          if ((trimmed_value[pos - 1] + trimmed_value[pos]).match(/<\//)) {
            let inner_indent = 0;
            while (inner_indent > -1) {
              if (trimmed_value[pos].match(/>/)) {
                pos++;
                inner_indent -= 1;
                cbPos -= 2;
              } else {
                pos++;
              }
            }
          }
          pos++;
        }
        const match = RE_SVELTE_TAG.exec(trimmed_value.substring(0, pos).trim());
        if (!match)
          return;
        return eat(is_svelte_tag[1] + match[0])({
          type: "svelteTag",
          value: match[0],
          name: match[1]
        });
      }
    }
    var RE_SVELTE_BLOCK_START = /(^\s*){[#:/@]/;
    var RE_SVELTE_BLOCK = /^{[#:/@](else if|[a-z]+).*}$/;
    function parse_svelte_block(eat, value, silent) {
      const is_svelte_block = RE_SVELTE_BLOCK_START.exec(value);
      if (is_svelte_block) {
        if (silent)
          return true;
        const trimmed_value = value.trim();
        let cbPos = 0;
        let pos = 1;
        while (cbPos > -1) {
          if (trimmed_value[pos].match(/{/))
            cbPos++;
          if (trimmed_value[pos].match(/}/))
            cbPos--;
          pos++;
        }
        const match = RE_SVELTE_BLOCK.exec(trimmed_value.substring(0, pos));
        if (!match)
          return;
        return eat(is_svelte_block[1] + match[0])({
          type: "svelteBlock",
          value: `${is_svelte_block[1]}${match[0]}`,
          name: match[1]
        });
      }
    }
    var dotAllPolyfill = "[\0-\uFFFF]";
    var attributeName = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
    var singleQuoted = "'[^']*'";
    var doubleQuoted = '"[^"]*"';
    var jsProps = "{.*}".replace(".", dotAllPolyfill);
    var attributeValue = "(?:" + unquoted + "|" + singleQuoted + "|" + doubleQuoted + "|" + jsProps + ")";
    var attribute = "(?:\\s+" + attributeName + "(?:\\s*=\\s*" + attributeValue + ")?)";
    var openTag = "<[A-Za-z]*[A-Za-z0-9\\.\\-]*" + attribute + "*\\s*\\/?>";
    var closeTag = "<\\/[A-Za-z][A-Za-z0-9\\.\\-]*\\s*>";
    "<[?].*?[?]>".replace(".", dotAllPolyfill);
    var openCloseTag = new RegExp("^(?:" + openTag + "|" + closeTag + ")");
    var tab = "	";
    var space = " ";
    var lineFeed = "\n";
    var lessThan = "<";
    var rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
    var rawCloseExpression = /<\/(script|pre|style)>/i;
    var commentOpenExpression = /^<!--/;
    var commentCloseExpression = /-->/;
    var instructionOpenExpression = /^<\?/;
    var instructionCloseExpression = /\?>/;
    var directiveOpenExpression = /^<![A-Za-z]/;
    var directiveCloseExpression = />/;
    var cdataOpenExpression = /^<!\[CDATA\[/;
    var cdataCloseExpression = /\]\]>/;
    var elementCloseExpression = /^$/;
    var otherElementOpenExpression = new RegExp(openCloseTag.source + "\\s*$");
    var fragmentOpenExpression = /^<>/;
    function blockHtml(eat, value, silent) {
      const blocks = "[a-z\\.]*(\\.){0,1}[a-z][a-z0-9\\.]*";
      const elementOpenExpression = new RegExp("^</?(" + blocks + ")(?=(\\s|/?>|$))", "i");
      const length = value.length;
      let index3 = 0;
      let next;
      let line2;
      let offset;
      let character;
      let sequence;
      const sequences = [
        [rawOpenExpression, rawCloseExpression, true],
        [commentOpenExpression, commentCloseExpression, true],
        [instructionOpenExpression, instructionCloseExpression, true],
        [directiveOpenExpression, directiveCloseExpression, true],
        [cdataOpenExpression, cdataCloseExpression, true],
        [elementOpenExpression, elementCloseExpression, true],
        [fragmentOpenExpression, elementCloseExpression, true],
        [otherElementOpenExpression, elementCloseExpression, false]
      ];
      while (index3 < length) {
        character = value.charAt(index3);
        if (character !== tab && character !== space) {
          break;
        }
        index3++;
      }
      if (value.charAt(index3) !== lessThan) {
        return;
      }
      next = value.indexOf(lineFeed, index3 + 1);
      next = next === -1 ? length : next;
      line2 = value.slice(index3, next);
      offset = -1;
      const count = sequences.length;
      while (++offset < count) {
        if (sequences[offset][0].test(line2)) {
          sequence = sequences[offset];
          break;
        }
      }
      if (!sequence) {
        return;
      }
      if (silent) {
        return sequence[2];
      }
      index3 = next;
      if (!sequence[1].test(line2)) {
        while (index3 < length) {
          next = value.indexOf(lineFeed, index3 + 1);
          next = next === -1 ? length : next;
          line2 = value.slice(index3 + 1, next);
          if (sequence[1].test(line2)) {
            if (line2) {
              index3 = next;
            }
            break;
          }
          index3 = next;
        }
      }
      const subvalue = value.slice(0, index3);
      return eat(subvalue)({ type: "html", value: subvalue });
    }
    function mdsvex_parser() {
      const Parser2 = this.Parser;
      const block_tokenizers = Parser2.prototype.blockTokenizers;
      const methods = Parser2.prototype.blockMethods;
      block_tokenizers.svelteBlock = parse_svelte_block;
      block_tokenizers.svelteTag = parse_svelte_tag;
      block_tokenizers.html = blockHtml;
      block_tokenizers.indentedCode = indentedCode;
      methods.splice(methods.indexOf("html"), 0, "svelteBlock");
      methods.splice(methods.indexOf("html"), 0, "svelteTag");
    }
    function indentedCode() {
      return true;
    }
    var unified_1 = unified().freeze();
    var slice = [].slice;
    var own$1 = {}.hasOwnProperty;
    var pipeline2 = trough_1().use(pipelineParse).use(pipelineRun).use(pipelineStringify);
    function pipelineParse(p2, ctx) {
      ctx.tree = p2.parse(ctx.file);
    }
    function pipelineRun(p2, ctx, next) {
      p2.run(ctx.tree, ctx.file, done);
      function done(err, tree, file) {
        if (err) {
          next(err);
        } else {
          ctx.tree = tree;
          ctx.file = file;
          next();
        }
      }
    }
    function pipelineStringify(p2, ctx) {
      ctx.file.contents = p2.stringify(ctx.tree, ctx.file);
    }
    function unified() {
      var attachers = [];
      var transformers = trough_1();
      var namespace = {};
      var frozen = false;
      var freezeIndex = -1;
      processor.data = data2;
      processor.freeze = freeze;
      processor.attachers = attachers;
      processor.use = use;
      processor.parse = parse3;
      processor.stringify = stringify2;
      processor.run = run3;
      processor.runSync = runSync;
      processor.process = process2;
      processor.processSync = processSync;
      return processor;
      function processor() {
        var destination = unified();
        var length = attachers.length;
        var index3 = -1;
        while (++index3 < length) {
          destination.use.apply(null, attachers[index3]);
        }
        destination.data(extend$2(true, {}, namespace));
        return destination;
      }
      function freeze() {
        var values2;
        var plugin;
        var options4;
        var transformer;
        if (frozen) {
          return processor;
        }
        while (++freezeIndex < attachers.length) {
          values2 = attachers[freezeIndex];
          plugin = values2[0];
          options4 = values2[1];
          transformer = null;
          if (options4 === false) {
            continue;
          }
          if (options4 === true) {
            values2[1] = void 0;
          }
          transformer = plugin.apply(processor, values2.slice(1));
          if (typeof transformer === "function") {
            transformers.use(transformer);
          }
        }
        frozen = true;
        freezeIndex = Infinity;
        return processor;
      }
      function data2(key, value) {
        if (typeof key === "string") {
          if (arguments.length === 2) {
            assertUnfrozen("data", frozen);
            namespace[key] = value;
            return processor;
          }
          return own$1.call(namespace, key) && namespace[key] || null;
        }
        if (key) {
          assertUnfrozen("data", frozen);
          namespace = key;
          return processor;
        }
        return namespace;
      }
      function use(value) {
        var settings;
        assertUnfrozen("use", frozen);
        if (value === null || value === void 0)
          ;
        else if (typeof value === "function") {
          addPlugin.apply(null, arguments);
        } else if (typeof value === "object") {
          if ("length" in value) {
            addList(value);
          } else {
            addPreset(value);
          }
        } else {
          throw new Error("Expected usable value, not `" + value + "`");
        }
        if (settings) {
          namespace.settings = extend$2(namespace.settings || {}, settings);
        }
        return processor;
        function addPreset(result) {
          addList(result.plugins);
          if (result.settings) {
            settings = extend$2(settings || {}, result.settings);
          }
        }
        function add(value2) {
          if (typeof value2 === "function") {
            addPlugin(value2);
          } else if (typeof value2 === "object") {
            if ("length" in value2) {
              addPlugin.apply(null, value2);
            } else {
              addPreset(value2);
            }
          } else {
            throw new Error("Expected usable value, not `" + value2 + "`");
          }
        }
        function addList(plugins) {
          var length;
          var index3;
          if (plugins === null || plugins === void 0)
            ;
          else if (typeof plugins === "object" && "length" in plugins) {
            length = plugins.length;
            index3 = -1;
            while (++index3 < length) {
              add(plugins[index3]);
            }
          } else {
            throw new Error("Expected a list of plugins, not `" + plugins + "`");
          }
        }
        function addPlugin(plugin, value2) {
          var entry = find2(plugin);
          if (entry) {
            if (isPlainObj(entry[1]) && isPlainObj(value2)) {
              value2 = extend$2(entry[1], value2);
            }
            entry[1] = value2;
          } else {
            attachers.push(slice.call(arguments));
          }
        }
      }
      function find2(plugin) {
        var length = attachers.length;
        var index3 = -1;
        var entry;
        while (++index3 < length) {
          entry = attachers[index3];
          if (entry[0] === plugin) {
            return entry;
          }
        }
      }
      function parse3(doc) {
        var file = vfile(doc);
        var Parser2;
        freeze();
        Parser2 = processor.Parser;
        assertParser("parse", Parser2);
        if (newable(Parser2, "parse")) {
          return new Parser2(String(file), file).parse();
        }
        return Parser2(String(file), file);
      }
      function run3(node, file, cb) {
        assertNode(node);
        freeze();
        if (!cb && typeof file === "function") {
          cb = file;
          file = null;
        }
        if (!cb) {
          return new Promise(executor);
        }
        executor(null, cb);
        function executor(resolve2, reject) {
          transformers.run(node, vfile(file), done);
          function done(err, tree, file2) {
            tree = tree || node;
            if (err) {
              reject(err);
            } else if (resolve2) {
              resolve2(tree);
            } else {
              cb(null, tree, file2);
            }
          }
        }
      }
      function runSync(node, file) {
        var complete = false;
        var result;
        run3(node, file, done);
        assertDone("runSync", "run", complete);
        return result;
        function done(err, tree) {
          complete = true;
          bail_1(err);
          result = tree;
        }
      }
      function stringify2(node, doc) {
        var file = vfile(doc);
        var Compiler;
        freeze();
        Compiler = processor.Compiler;
        assertCompiler("stringify", Compiler);
        assertNode(node);
        if (newable(Compiler, "compile")) {
          return new Compiler(node, file).compile();
        }
        return Compiler(node, file);
      }
      function process2(doc, cb) {
        freeze();
        assertParser("process", processor.Parser);
        assertCompiler("process", processor.Compiler);
        if (!cb) {
          return new Promise(executor);
        }
        executor(null, cb);
        function executor(resolve2, reject) {
          var file = vfile(doc);
          pipeline2.run(processor, { file }, done);
          function done(err) {
            if (err) {
              reject(err);
            } else if (resolve2) {
              resolve2(file);
            } else {
              cb(null, file);
            }
          }
        }
      }
      function processSync(doc) {
        var complete = false;
        var file;
        freeze();
        assertParser("processSync", processor.Parser);
        assertCompiler("processSync", processor.Compiler);
        file = vfile(doc);
        process2(file, done);
        assertDone("processSync", "process", complete);
        return file;
        function done(err) {
          complete = true;
          bail_1(err);
        }
      }
    }
    function newable(value, name2) {
      return typeof value === "function" && value.prototype && (keys(value.prototype) || name2 in value.prototype);
    }
    function keys(value) {
      var key;
      for (key in value) {
        return true;
      }
      return false;
    }
    function assertParser(name2, Parser2) {
      if (typeof Parser2 !== "function") {
        throw new Error("Cannot `" + name2 + "` without `Parser`");
      }
    }
    function assertCompiler(name2, Compiler) {
      if (typeof Compiler !== "function") {
        throw new Error("Cannot `" + name2 + "` without `Compiler`");
      }
    }
    function assertUnfrozen(name2, frozen) {
      if (frozen) {
        throw new Error("Cannot invoke `" + name2 + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
      }
    }
    function assertNode(node) {
      if (!node || typeof node.type !== "string") {
        throw new Error("Expected node, got `" + node + "`");
      }
    }
    function assertDone(name2, asyncName, complete) {
      if (!complete) {
        throw new Error("`" + name2 + "` finished async. Use `" + asyncName + "` instead");
      }
    }
    var nlcstToString_1 = nlcstToString;
    function nlcstToString(node, separator) {
      var sep = separator || "";
      var values2;
      var length;
      var children;
      if (!node || !("length" in node) && !node.type) {
        throw new Error("Expected node, not `" + node + "`");
      }
      if (typeof node.value === "string") {
        return node.value;
      }
      children = "length" in node ? node : node.children;
      length = children.length;
      if (length === 1 && "value" in children[0]) {
        return children[0].value;
      }
      values2 = [];
      while (length--) {
        values2[length] = nlcstToString(children[length], sep);
      }
      return values2.join(sep);
    }
    var tokenizer = tokenizerFactory;
    function tokenizerFactory(childType, expression) {
      return tokenizer2;
      function tokenizer2(node) {
        var children = [];
        var tokens = node.children;
        var type2 = node.type;
        var length = tokens.length;
        var index3 = -1;
        var lastIndex = length - 1;
        var start2 = 0;
        var first2;
        var last;
        var parent;
        while (++index3 < length) {
          if (index3 === lastIndex || tokens[index3].type === childType && expression.test(nlcstToString_1(tokens[index3]))) {
            first2 = tokens[start2];
            last = tokens[index3];
            parent = {
              type: type2,
              children: tokens.slice(start2, index3 + 1)
            };
            if (first2.position && last.position) {
              parent.position = {
                start: first2.position.start,
                end: last.position.end
              };
            }
            children.push(parent);
            start2 = index3 + 1;
          }
        }
        return children;
      }
    }
    var parser = parserFactory;
    function parserFactory(options4) {
      var type2 = options4.type;
      var tokenizerProperty = options4.tokenizer;
      var delimiter = options4.delimiter;
      var tokenize2 = delimiter && tokenizer(options4.delimiterType, delimiter);
      return parser2;
      function parser2(value) {
        var children = this[tokenizerProperty](value);
        return {
          type: type2,
          children: tokenize2 ? tokenize2(children) : children
        };
      }
    }
    var expressions = {
      affixSymbol: /^([\)\]\}\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63]|["'\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21]|[!\.\?\u2026\u203D])\1*$/,
      newLine: /^[ \t]*((\r?\n|\r)[\t ]*)+$/,
      newLineMulti: /^[ \t]*((\r?\n|\r)[\t ]*){2,}$/,
      terminalMarker: /^((?:[!\.\?\u2026\u203D])+)$/,
      wordSymbolInner: /^((?:[&'\x2D\.:=\?@\xAD\xB7\u2010\u2011\u2019\u2027])|(?:_)+)$/,
      numerical: /^(?:[0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C])+$/,
      digitStart: /^\d/,
      lowerInitial: /^(?:[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7BB\uA7BD\uA7BF\uA7C3\uA7FA\uAB30-\uAB5A\uAB60-\uAB67\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43])/,
      surrogates: /[\uD800-\uDFFF]/,
      punctuation: /[!"'-\),-\/:;\?\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u201F\u2022-\u2027\u2032-\u203A\u203C-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,
      word: /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09F4-\u09F9\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BF2\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7E\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D63\u0D66-\u0D78\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u17F0-\u17F9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABE\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u20D0-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BA\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA672\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA830-\uA835\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE6\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD27\uDD30-\uDD39\uDE60-\uDE7E\uDF00-\uDF27\uDF30-\uDF54\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC52-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF3B]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCF2\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
      whiteSpace: /[\t-\r \x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
    };
    var arrayIterate = iterate;
    var own = {}.hasOwnProperty;
    function iterate(values2, callback, context2) {
      var index3 = -1;
      var result;
      if (!values2) {
        throw new Error("Iterate requires that |this| not be " + values2);
      }
      if (!own.call(values2, "length")) {
        throw new Error("Iterate requires that |this| has a `length`");
      }
      if (typeof callback !== "function") {
        throw new Error("`callback` must be a function");
      }
      while (++index3 < values2.length) {
        if (!(index3 in values2)) {
          continue;
        }
        result = callback.call(context2, values2[index3], index3, values2);
        if (typeof result === "number") {
          if (result < 0) {
            index3 = 0;
          }
          index3 = result - 1;
        }
      }
    }
    var unistUtilModifyChildren = modifierFactory;
    function modifierFactory(callback) {
      return iteratorFactory(wrapperFactory(callback));
    }
    function iteratorFactory(callback) {
      return iterator;
      function iterator(parent) {
        var children = parent && parent.children;
        if (!children) {
          throw new Error("Missing children in `parent` for `modifier`");
        }
        return arrayIterate(children, callback, parent);
      }
    }
    function wrapperFactory(callback) {
      return wrapper;
      function wrapper(value, index3) {
        return callback(value, index3, this);
      }
    }
    var mergeInitialWordSymbol_1 = unistUtilModifyChildren(mergeInitialWordSymbol);
    function mergeInitialWordSymbol(child, index3, parent) {
      var children;
      var next;
      if (child.type !== "SymbolNode" && child.type !== "PunctuationNode" || nlcstToString_1(child) !== "&") {
        return;
      }
      children = parent.children;
      next = children[index3 + 1];
      if (index3 !== 0 && children[index3 - 1].type === "WordNode" || !(next && next.type === "WordNode")) {
        return;
      }
      children.splice(index3, 1);
      next.children.unshift(child);
      if (next.position && child.position) {
        next.position.start = child.position.start;
      }
      return index3 - 1;
    }
    var mergeFinalWordSymbol_1 = unistUtilModifyChildren(mergeFinalWordSymbol$1);
    function mergeFinalWordSymbol$1(child, index3, parent) {
      var children;
      var prev;
      var next;
      if (index3 !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode") && nlcstToString_1(child) === "-") {
        children = parent.children;
        prev = children[index3 - 1];
        next = children[index3 + 1];
        if ((!next || next.type !== "WordNode") && prev && prev.type === "WordNode") {
          children.splice(index3, 1);
          prev.children.push(child);
          if (prev.position && child.position) {
            prev.position.end = child.position.end;
          }
          return index3;
        }
      }
    }
    var mergeInnerWordSymbol_1 = unistUtilModifyChildren(mergeInnerWordSymbol);
    var wordSymbolInner = expressions.wordSymbolInner;
    function mergeInnerWordSymbol(child, index3, parent) {
      var siblings2;
      var sibling;
      var prev;
      var last;
      var position2;
      var tokens;
      var queue;
      if (index3 !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode")) {
        siblings2 = parent.children;
        prev = siblings2[index3 - 1];
        if (prev && prev.type === "WordNode") {
          position2 = index3 - 1;
          tokens = [];
          queue = [];
          while (siblings2[++position2]) {
            sibling = siblings2[position2];
            if (sibling.type === "WordNode") {
              tokens = tokens.concat(queue, sibling.children);
              queue = [];
            } else if ((sibling.type === "SymbolNode" || sibling.type === "PunctuationNode") && wordSymbolInner.test(nlcstToString_1(sibling))) {
              queue.push(sibling);
            } else {
              break;
            }
          }
          if (tokens.length !== 0) {
            if (queue.length !== 0) {
              position2 -= queue.length;
            }
            siblings2.splice(index3, position2 - index3);
            prev.children = prev.children.concat(tokens);
            last = tokens[tokens.length - 1];
            if (prev.position && last.position) {
              prev.position.end = last.position.end;
            }
            return index3;
          }
        }
      }
    }
    var mergeInnerWordSlash_1 = unistUtilModifyChildren(mergeInnerWordSlash);
    var slash = "/";
    function mergeInnerWordSlash(child, index3, parent) {
      var siblings2 = parent.children;
      var prev;
      var next;
      var prevValue;
      var nextValue;
      var queue;
      var tail;
      var count;
      prev = siblings2[index3 - 1];
      next = siblings2[index3 + 1];
      if (prev && prev.type === "WordNode" && (child.type === "SymbolNode" || child.type === "PunctuationNode") && nlcstToString_1(child) === slash) {
        prevValue = nlcstToString_1(prev);
        tail = child;
        queue = [child];
        count = 1;
        if (next && next.type === "WordNode") {
          nextValue = nlcstToString_1(next);
          tail = next;
          queue = queue.concat(next.children);
          count++;
        }
        if (prevValue.length < 3 && (!nextValue || nextValue.length < 3)) {
          prev.children = prev.children.concat(queue);
          siblings2.splice(index3, count);
          if (prev.position && tail.position) {
            prev.position.end = tail.position.end;
          }
          return index3;
        }
      }
    }
    var mergeInitialisms_1 = unistUtilModifyChildren(mergeInitialisms);
    var numerical = expressions.numerical;
    function mergeInitialisms(child, index3, parent) {
      var siblings2;
      var prev;
      var children;
      var length;
      var position2;
      var otherChild;
      var isAllDigits;
      var value;
      if (index3 !== 0 && nlcstToString_1(child) === ".") {
        siblings2 = parent.children;
        prev = siblings2[index3 - 1];
        children = prev.children;
        length = children && children.length;
        if (prev.type === "WordNode" && length !== 1 && length % 2 !== 0) {
          position2 = length;
          isAllDigits = true;
          while (children[--position2]) {
            otherChild = children[position2];
            value = nlcstToString_1(otherChild);
            if (position2 % 2 === 0) {
              if (value.length > 1) {
                return;
              }
              if (!numerical.test(value)) {
                isAllDigits = false;
              }
            } else if (value !== ".") {
              if (position2 < length - 2) {
                break;
              } else {
                return;
              }
            }
          }
          if (!isAllDigits) {
            siblings2.splice(index3, 1);
            children.push(child);
            if (prev.position && child.position) {
              prev.position.end = child.position.end;
            }
            return index3;
          }
        }
      }
    }
    var mergeWords = unistUtilModifyChildren(mergeFinalWordSymbol);
    function mergeFinalWordSymbol(child, index3, parent) {
      var siblings2 = parent.children;
      var next;
      if (child.type === "WordNode") {
        next = siblings2[index3 + 1];
        if (next && next.type === "WordNode") {
          siblings2.splice(index3 + 1, 1);
          child.children = child.children.concat(next.children);
          if (next.position && child.position) {
            child.position.end = next.position.end;
          }
          return index3;
        }
      }
    }
    var unistUtilVisitChildren = visitChildren;
    function visitChildren(callback) {
      return visitor;
      function visitor(parent) {
        var index3 = -1;
        var children = parent && parent.children;
        if (!children) {
          throw new Error("Missing children in `parent` for `visitor`");
        }
        while (++index3 in children) {
          callback(children[index3], index3, parent);
        }
      }
    }
    var patchPosition_1 = unistUtilVisitChildren(patchPosition);
    function patchPosition(child, index3, node) {
      var siblings2 = node.children;
      if (!child.position) {
        return;
      }
      if (index3 === 0 && (!node.position || !node.position.start)) {
        patch(node);
        node.position.start = child.position.start;
      }
      if (index3 === siblings2.length - 1 && (!node.position || !node.position.end)) {
        patch(node);
        node.position.end = child.position.end;
      }
    }
    function patch(node) {
      if (!node.position) {
        node.position = {};
      }
    }
    var mergeNonWordSentences_1 = unistUtilModifyChildren(mergeNonWordSentences);
    function mergeNonWordSentences(child, index3, parent) {
      var children = child.children;
      var position2 = -1;
      var prev;
      var next;
      while (children[++position2]) {
        if (children[position2].type === "WordNode") {
          return;
        }
      }
      prev = parent.children[index3 - 1];
      if (prev) {
        prev.children = prev.children.concat(children);
        parent.children.splice(index3, 1);
        if (prev.position && child.position) {
          prev.position.end = child.position.end;
        }
        return index3;
      }
      next = parent.children[index3 + 1];
      if (next) {
        next.children = children.concat(next.children);
        if (next.position && child.position) {
          next.position.start = child.position.start;
        }
        parent.children.splice(index3, 1);
      }
    }
    var mergeAffixSymbol_1 = unistUtilModifyChildren(mergeAffixSymbol);
    var affixSymbol = expressions.affixSymbol;
    function mergeAffixSymbol(child, index3, parent) {
      var children = child.children;
      var first2;
      var second;
      var prev;
      if (children && children.length !== 0 && index3 !== 0) {
        first2 = children[0];
        second = children[1];
        prev = parent.children[index3 - 1];
        if ((first2.type === "SymbolNode" || first2.type === "PunctuationNode") && affixSymbol.test(nlcstToString_1(first2))) {
          prev.children.push(children.shift());
          if (first2.position && prev.position) {
            prev.position.end = first2.position.end;
          }
          if (second && second.position && child.position) {
            child.position.start = second.position.start;
          }
          return index3 - 1;
        }
      }
    }
    var mergeInitialLowerCaseLetterSentences_1 = unistUtilModifyChildren(mergeInitialLowerCaseLetterSentences);
    var lowerInitial = expressions.lowerInitial;
    function mergeInitialLowerCaseLetterSentences(child, index3, parent) {
      var children = child.children;
      var position2;
      var node;
      var siblings2;
      var prev;
      if (children && children.length !== 0 && index3 !== 0) {
        position2 = -1;
        while (children[++position2]) {
          node = children[position2];
          if (node.type === "WordNode") {
            if (!lowerInitial.test(nlcstToString_1(node))) {
              return;
            }
            siblings2 = parent.children;
            prev = siblings2[index3 - 1];
            prev.children = prev.children.concat(children);
            siblings2.splice(index3, 1);
            if (prev.position && child.position) {
              prev.position.end = child.position.end;
            }
            return index3;
          }
          if (node.type === "SymbolNode" || node.type === "PunctuationNode") {
            return;
          }
        }
      }
    }
    var mergeInitialDigitSentences_1 = unistUtilModifyChildren(mergeInitialDigitSentences);
    var digit = expressions.digitStart;
    function mergeInitialDigitSentences(child, index3, parent) {
      var children = child.children;
      var siblings2 = parent.children;
      var prev = siblings2[index3 - 1];
      var head2 = children[0];
      if (prev && head2 && head2.type === "WordNode" && digit.test(nlcstToString_1(head2))) {
        prev.children = prev.children.concat(children);
        siblings2.splice(index3, 1);
        if (prev.position && child.position) {
          prev.position.end = child.position.end;
        }
        return index3;
      }
    }
    var mergePrefixExceptions_1 = unistUtilModifyChildren(mergePrefixExceptions);
    var abbreviationPrefix = new RegExp("^([0-9]{1,3}|[a-z]|al|ca|cap|cca|cent|cf|cit|con|cp|cwt|ead|etc|ff|fl|ibid|id|nem|op|pro|seq|sic|stat|tem|viz)$");
    function mergePrefixExceptions(child, index3, parent) {
      var children = child.children;
      var period2;
      var node;
      var next;
      if (children && children.length > 1) {
        period2 = children[children.length - 1];
        if (period2 && nlcstToString_1(period2) === ".") {
          node = children[children.length - 2];
          if (node && node.type === "WordNode" && abbreviationPrefix.test(nlcstToString_1(node).toLowerCase())) {
            node.children.push(period2);
            children.pop();
            if (period2.position && node.position) {
              node.position.end = period2.position.end;
            }
            next = parent.children[index3 + 1];
            if (next) {
              child.children = children.concat(next.children);
              parent.children.splice(index3 + 1, 1);
              if (next.position && child.position) {
                child.position.end = next.position.end;
              }
              return index3 - 1;
            }
          }
        }
      }
    }
    var mergeAffixExceptions_1 = unistUtilModifyChildren(mergeAffixExceptions);
    function mergeAffixExceptions(child, index3, parent) {
      var children = child.children;
      var node;
      var position2;
      var value;
      var previousChild;
      if (!children || children.length === 0 || index3 === 0) {
        return;
      }
      position2 = -1;
      while (children[++position2]) {
        node = children[position2];
        if (node.type === "WordNode") {
          return;
        }
        if (node.type === "SymbolNode" || node.type === "PunctuationNode") {
          value = nlcstToString_1(node);
          if (value !== "," && value !== ";") {
            return;
          }
          previousChild = parent.children[index3 - 1];
          previousChild.children = previousChild.children.concat(children);
          if (previousChild.position && child.position) {
            previousChild.position.end = child.position.end;
          }
          parent.children.splice(index3, 1);
          return index3;
        }
      }
    }
    var mergeRemainingFullStops_1 = unistUtilVisitChildren(mergeRemainingFullStops);
    var terminalMarker = expressions.terminalMarker;
    function mergeRemainingFullStops(child) {
      var children = child.children;
      var position2 = children.length;
      var hasFoundDelimiter = false;
      var grandchild;
      var prev;
      var next;
      var nextNext;
      while (children[--position2]) {
        grandchild = children[position2];
        if (grandchild.type !== "SymbolNode" && grandchild.type !== "PunctuationNode") {
          if (grandchild.type === "WordNode") {
            hasFoundDelimiter = true;
          }
          continue;
        }
        if (!terminalMarker.test(nlcstToString_1(grandchild))) {
          continue;
        }
        if (!hasFoundDelimiter) {
          hasFoundDelimiter = true;
          continue;
        }
        if (nlcstToString_1(grandchild) !== ".") {
          continue;
        }
        prev = children[position2 - 1];
        next = children[position2 + 1];
        if (prev && prev.type === "WordNode") {
          nextNext = children[position2 + 2];
          if (next && nextNext && next.type === "WhiteSpaceNode" && nlcstToString_1(nextNext) === ".") {
            continue;
          }
          children.splice(position2, 1);
          prev.children.push(grandchild);
          if (grandchild.position && prev.position) {
            prev.position.end = grandchild.position.end;
          }
          position2--;
        } else if (next && next.type === "WordNode") {
          children.splice(position2, 1);
          next.children.unshift(grandchild);
          if (grandchild.position && next.position) {
            next.position.start = grandchild.position.start;
          }
        }
      }
    }
    var makeInitialWhiteSpaceSiblings_1 = unistUtilVisitChildren(makeInitialWhiteSpaceSiblings);
    function makeInitialWhiteSpaceSiblings(child, index3, parent) {
      var children = child.children;
      var next;
      if (children && children.length !== 0 && children[0].type === "WhiteSpaceNode") {
        parent.children.splice(index3, 0, children.shift());
        next = children[0];
        if (next && next.position && child.position) {
          child.position.start = next.position.start;
        }
      }
    }
    var makeFinalWhiteSpaceSiblings_1 = unistUtilModifyChildren(makeFinalWhiteSpaceSiblings);
    function makeFinalWhiteSpaceSiblings(child, index3, parent) {
      var children = child.children;
      var prev;
      if (children && children.length !== 0 && children[children.length - 1].type === "WhiteSpaceNode") {
        parent.children.splice(index3 + 1, 0, child.children.pop());
        prev = children[children.length - 1];
        if (prev && prev.position && child.position) {
          child.position.end = prev.position.end;
        }
        return index3;
      }
    }
    var breakImplicitSentences_1 = unistUtilModifyChildren(breakImplicitSentences);
    var multiNewLine = expressions.newLineMulti;
    function breakImplicitSentences(child, index3, parent) {
      var children;
      var position2;
      var length;
      var tail;
      var head2;
      var end2;
      var insertion;
      var node;
      if (child.type !== "SentenceNode") {
        return;
      }
      children = child.children;
      length = children.length - 1;
      position2 = 0;
      while (++position2 < length) {
        node = children[position2];
        if (node.type !== "WhiteSpaceNode" || !multiNewLine.test(nlcstToString_1(node))) {
          continue;
        }
        child.children = children.slice(0, position2);
        insertion = {
          type: "SentenceNode",
          children: children.slice(position2 + 1)
        };
        tail = children[position2 - 1];
        head2 = children[position2 + 1];
        parent.children.splice(index3 + 1, 0, node, insertion);
        if (child.position && tail.position && head2.position) {
          end2 = child.position.end;
          child.position.end = tail.position.end;
          insertion.position = {
            start: head2.position.start,
            end: end2
          };
        }
        return index3 + 1;
      }
    }
    var removeEmptyNodes_1 = unistUtilModifyChildren(removeEmptyNodes);
    function removeEmptyNodes(child, index3, parent) {
      if ("children" in child && child.children.length === 0) {
        parent.children.splice(index3, 1);
        return index3;
      }
    }
    var lib = ParseLatin;
    function ParseLatin(doc, file) {
      var value = file || doc;
      if (!(this instanceof ParseLatin)) {
        return new ParseLatin(doc, file);
      }
      this.doc = value ? String(value) : null;
    }
    var proto = ParseLatin.prototype;
    proto.position = true;
    proto.tokenizeSymbol = createTextFactory("Symbol");
    proto.tokenizeWhiteSpace = createTextFactory("WhiteSpace");
    proto.tokenizePunctuation = createTextFactory("Punctuation");
    proto.tokenizeSource = createTextFactory("Source");
    proto.tokenizeText = createTextFactory("Text");
    proto.run = run2;
    proto.use = useFactory(function(context2, key, plugins) {
      context2[key] = context2[key].concat(plugins);
    });
    proto.useFirst = useFactory(function(context2, key, plugins) {
      context2[key] = plugins.concat(context2[key]);
    });
    proto.parse = function(value) {
      return this.tokenizeRoot(value || this.doc);
    };
    proto.tokenize = function(value) {
      return tokenize(this, value);
    };
    pluggable(ParseLatin, "tokenizeWord", function(value, eat) {
      var add = (eat || noopEat)("");
      var parent = { type: "WordNode", children: [] };
      this.tokenizeText(value, eat, parent);
      return add(parent);
    });
    pluggable(ParseLatin, "tokenizeSentence", parser({
      type: "SentenceNode",
      tokenizer: "tokenize"
    }));
    pluggable(ParseLatin, "tokenizeParagraph", parser({
      type: "ParagraphNode",
      delimiter: expressions.terminalMarker,
      delimiterType: "PunctuationNode",
      tokenizer: "tokenizeSentence"
    }));
    pluggable(ParseLatin, "tokenizeRoot", parser({
      type: "RootNode",
      delimiter: expressions.newLine,
      delimiterType: "WhiteSpaceNode",
      tokenizer: "tokenizeParagraph"
    }));
    proto.use("tokenizeSentence", [
      mergeInitialWordSymbol_1,
      mergeFinalWordSymbol_1,
      mergeInnerWordSymbol_1,
      mergeInnerWordSlash_1,
      mergeInitialisms_1,
      mergeWords,
      patchPosition_1
    ]);
    proto.use("tokenizeParagraph", [
      mergeNonWordSentences_1,
      mergeAffixSymbol_1,
      mergeInitialLowerCaseLetterSentences_1,
      mergeInitialDigitSentences_1,
      mergePrefixExceptions_1,
      mergeAffixExceptions_1,
      mergeRemainingFullStops_1,
      makeInitialWhiteSpaceSiblings_1,
      makeFinalWhiteSpaceSiblings_1,
      breakImplicitSentences_1,
      removeEmptyNodes_1,
      patchPosition_1
    ]);
    proto.use("tokenizeRoot", [
      makeInitialWhiteSpaceSiblings_1,
      makeFinalWhiteSpaceSiblings_1,
      removeEmptyNodes_1,
      patchPosition_1
    ]);
    function createTextFactory(type2) {
      type2 += "Node";
      return createText;
      function createText(value, eat, parent) {
        if (value === null || value === void 0) {
          value = "";
        }
        return (eat || noopEat)(value)({
          type: type2,
          value: String(value)
        }, parent);
      }
    }
    function run2(key, nodes) {
      var wareKey = key + "Plugins";
      var plugins = this[wareKey];
      var index3 = -1;
      if (plugins) {
        while (plugins[++index3]) {
          plugins[index3](nodes);
        }
      }
      return nodes;
    }
    function pluggable(Constructor, key, callback) {
      Constructor.prototype[key] = function() {
        return this.run(key, callback.apply(this, arguments));
      };
    }
    function useFactory(callback) {
      return use;
      function use(key, plugins) {
        var self2 = this;
        var wareKey;
        if (!(key in self2)) {
          throw new Error("Illegal Invocation: Unsupported `key` for `use(key, plugins)`. Make sure `key` is a supported function");
        }
        if (!plugins) {
          return;
        }
        wareKey = key + "Plugins";
        if (typeof plugins === "function") {
          plugins = [plugins];
        } else {
          plugins = plugins.concat();
        }
        if (!self2[wareKey]) {
          self2[wareKey] = [];
        }
        callback(self2, wareKey, plugins);
      }
    }
    var wordRe = expressions.word;
    var surrogatesRe = expressions.surrogates;
    var punctuationRe = expressions.punctuation;
    var whiteSpaceRe = expressions.whiteSpace;
    function tokenize(parser2, value) {
      var tokens;
      var offset;
      var line2;
      var column;
      var index3;
      var length;
      var character;
      var queue;
      var prev;
      var left2;
      var right2;
      var eater;
      if (value === null || value === void 0) {
        value = "";
      } else if (value instanceof String) {
        value = value.toString();
      }
      if (typeof value !== "string") {
        if ("length" in value && (!value[0] || value[0].type)) {
          return value;
        }
        throw new Error("Illegal invocation: '" + value + "' is not a valid argument for 'ParseLatin'");
      }
      tokens = [];
      if (!value) {
        return tokens;
      }
      index3 = 0;
      offset = 0;
      line2 = 1;
      column = 1;
      eater = parser2.position ? eat : noPositionEat;
      length = value.length;
      prev = "";
      queue = "";
      while (index3 < length) {
        character = value.charAt(index3);
        if (whiteSpaceRe.test(character)) {
          right2 = "WhiteSpace";
        } else if (punctuationRe.test(character)) {
          right2 = "Punctuation";
        } else if (wordRe.test(character)) {
          right2 = "Word";
        } else {
          right2 = "Symbol";
        }
        tick();
        prev = character;
        character = "";
        left2 = right2;
        right2 = null;
        index3++;
      }
      tick();
      return tokens;
      function tick() {
        if (left2 === right2 && (left2 === "Word" || left2 === "WhiteSpace" || character === prev || surrogatesRe.test(character))) {
          queue += character;
        } else {
          if (queue) {
            parser2["tokenize" + left2](queue, eater);
          }
          queue = character;
        }
      }
      function eat(subvalue) {
        var pos = position2();
        update(subvalue);
        return apply;
        function apply() {
          return pos(add.apply(null, arguments));
        }
      }
      function noPositionEat() {
        return apply;
        function apply() {
          return add.apply(null, arguments);
        }
      }
      function add(node, parent) {
        if (parent) {
          parent.children.push(node);
        } else {
          tokens.push(node);
        }
        return node;
      }
      function position2() {
        var before2 = now();
        function patch2(node) {
          node.position = new Position(before2);
          return node;
        }
        return patch2;
      }
      function update(subvalue) {
        var subvalueLength = subvalue.length;
        var character2 = -1;
        var lastIndex = -1;
        offset += subvalueLength;
        while (++character2 < subvalueLength) {
          if (subvalue.charAt(character2) === "\n") {
            lastIndex = character2;
            line2++;
          }
        }
        if (lastIndex === -1) {
          column += subvalueLength;
        } else {
          column = subvalueLength - lastIndex;
        }
      }
      function Position(start2) {
        this.start = start2;
        this.end = now();
      }
      function now() {
        return {
          line: line2,
          column,
          offset
        };
      }
    }
    function noopAdd(node, parent) {
      if (parent) {
        parent.children.push(node);
      }
      return node;
    }
    function noopEat() {
      return noopAdd;
    }
    var parseLatin = lib;
    var retextLatin = parse$1;
    parse$1.Parser = parseLatin;
    function parse$1() {
      this.Parser = unherit_1(parseLatin);
    }
    var retextStringify = stringify$1;
    function stringify$1() {
      this.Compiler = compiler;
    }
    function compiler(tree) {
      return nlcstToString_1(tree);
    }
    var retext = unified_1().use(retextLatin).use(retextStringify).freeze();
    var retextSmartypants = smartypants;
    var punctuation = "PunctuationNode";
    var symbol = "SymbolNode";
    var word = "WordNode";
    var whiteSpace = "WhiteSpaceNode";
    var decadeExpression = /^\d\ds$/;
    var threeFullStopsExpression = /^\.{3,}$/;
    var fullStopsExpression = /^\.+$/;
    var threeDashes = "---";
    var twoDashes = "--";
    var emDash = "\u2014";
    var enDash = "\u2013";
    var ellipsis = "\u2026";
    var twoBackticks = "``";
    var backtick = "`";
    var twoSingleQuotes = "''";
    var singleQuote = "'";
    var apostrophe = "\u2019";
    var doubleQuote = '"';
    var openingDoubleQuote = "\u201C";
    var closingDoubleQuote = "\u201D";
    var openingSingleQuote = "\u2018";
    var closingSingleQuote = "\u2019";
    var closingQuotes = {};
    var openingQuotes = {};
    openingQuotes[doubleQuote] = openingDoubleQuote;
    closingQuotes[doubleQuote] = closingDoubleQuote;
    openingQuotes[singleQuote] = openingSingleQuote;
    closingQuotes[singleQuote] = closingSingleQuote;
    var educators = {};
    educators.dashes = {
      true: dashes2,
      oldschool,
      inverted
    };
    educators.backticks = {
      true: backticks,
      all
    };
    educators.ellipses = {
      true: ellipses
    };
    educators.quotes = {
      true: quotes
    };
    function smartypants(options4) {
      var methods = [];
      var quotes2;
      var ellipses2;
      var backticks2;
      var dashes3;
      if (!options4) {
        options4 = {};
      }
      if ("quotes" in options4) {
        quotes2 = options4.quotes;
        if (quotes2 !== Boolean(quotes2)) {
          throw new TypeError("Illegal invocation: `" + quotes2 + "` is not a valid value for `quotes` in `smartypants`");
        }
      } else {
        quotes2 = true;
      }
      if ("ellipses" in options4) {
        ellipses2 = options4.ellipses;
        if (ellipses2 !== Boolean(ellipses2)) {
          throw new TypeError("Illegal invocation: `" + ellipses2 + "` is not a valid value for `ellipses` in `smartypants`");
        }
      } else {
        ellipses2 = true;
      }
      if ("backticks" in options4) {
        backticks2 = options4.backticks;
        if (backticks2 !== Boolean(backticks2) && backticks2 !== "all") {
          throw new TypeError("Illegal invocation: `" + backticks2 + "` is not a valid value for `backticks` in `smartypants`");
        }
        if (backticks2 === "all" && quotes2 === true) {
          throw new TypeError("Illegal invocation: `backticks: " + backticks2 + "` is not a valid value when `quotes: " + quotes2 + "` in `smartypants`");
        }
      } else {
        backticks2 = true;
      }
      if ("dashes" in options4) {
        dashes3 = options4.dashes;
        if (dashes3 !== Boolean(dashes3) && dashes3 !== "oldschool" && dashes3 !== "inverted") {
          throw new TypeError("Illegal invocation: `" + dashes3 + "` is not a valid value for `dahes` in `smartypants`");
        }
      } else {
        dashes3 = true;
      }
      if (quotes2 !== false) {
        methods.push(educators.quotes[quotes2]);
      }
      if (ellipses2 !== false) {
        methods.push(educators.ellipses[ellipses2]);
      }
      if (backticks2 !== false) {
        methods.push(educators.backticks[backticks2]);
      }
      if (dashes3 !== false) {
        methods.push(educators.dashes[dashes3]);
      }
      return transformFactory(methods);
    }
    function transformFactory(methods) {
      var length = methods.length;
      return transformer;
      function transformer(tree) {
        unistUtilVisit(tree, visitor);
      }
      function visitor(node, position2, parent) {
        var index3 = -1;
        if (node.type === punctuation || node.type === symbol) {
          while (++index3 < length) {
            methods[index3](node, position2, parent);
          }
        }
      }
    }
    function oldschool(node) {
      if (node.value === threeDashes) {
        node.value = emDash;
      } else if (node.value === twoDashes) {
        node.value = enDash;
      }
    }
    function dashes2(node) {
      if (node.value === twoDashes) {
        node.value = emDash;
      }
    }
    function inverted(node) {
      if (node.value === threeDashes) {
        node.value = enDash;
      } else if (node.value === twoDashes) {
        node.value = emDash;
      }
    }
    function backticks(node) {
      if (node.value === twoBackticks) {
        node.value = openingDoubleQuote;
      } else if (node.value === twoSingleQuotes) {
        node.value = closingDoubleQuote;
      }
    }
    function all(node) {
      backticks(node);
      if (node.value === backtick) {
        node.value = openingSingleQuote;
      } else if (node.value === singleQuote) {
        node.value = closingSingleQuote;
      }
    }
    function ellipses(node, index3, parent) {
      var value = node.value;
      var siblings2 = parent.children;
      var position2;
      var nodes;
      var sibling;
      var type2;
      var count;
      var queue;
      if (threeFullStopsExpression.test(node.value)) {
        node.value = ellipsis;
        return;
      }
      if (!fullStopsExpression.test(value)) {
        return;
      }
      nodes = [];
      position2 = index3;
      count = 1;
      while (--position2 > 0) {
        sibling = siblings2[position2];
        if (sibling.type !== whiteSpace) {
          break;
        }
        queue = sibling;
        sibling = siblings2[--position2];
        type2 = sibling && sibling.type;
        if (sibling && (type2 === punctuation || type2 === symbol) && fullStopsExpression.test(sibling.value)) {
          nodes.push(queue, sibling);
          count++;
          continue;
        }
        break;
      }
      if (count < 3) {
        return;
      }
      siblings2.splice(index3 - nodes.length, nodes.length);
      node.value = ellipsis;
    }
    function quotes(node, index3, parent) {
      var siblings2 = parent.children;
      var value = node.value;
      var next;
      var nextNext;
      var prev;
      var nextValue;
      if (value !== doubleQuote && value !== singleQuote) {
        return;
      }
      prev = siblings2[index3 - 1];
      next = siblings2[index3 + 1];
      nextNext = siblings2[index3 + 2];
      nextValue = next && nlcstToString_1(next);
      if (next && nextNext && (next.type === punctuation || next.type === symbol) && nextNext.type !== word) {
        node.value = closingQuotes[value];
      } else if (nextNext && (nextValue === doubleQuote || nextValue === singleQuote) && nextNext.type === word) {
        node.value = openingQuotes[value];
        next.value = openingQuotes[nextValue];
      } else if (next && decadeExpression.test(nextValue)) {
        node.value = closingQuotes[value];
      } else if (prev && next && (prev.type === whiteSpace || prev.type === punctuation || prev.type === symbol) && next.type === word) {
        node.value = openingQuotes[value];
      } else if (prev && prev.type !== whiteSpace && prev.type !== symbol && prev.type !== punctuation) {
        node.value = closingQuotes[value];
      } else if (!next || next.type === whiteSpace || (value === singleQuote || value === apostrophe) && nextValue === "s") {
        node.value = closingQuotes[value];
      } else {
        node.value = openingQuotes[value];
      }
    }
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target2, source) {
      var index3, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index3 = 0, length = sourceKeys.length; index3 < length; index3 += 1) {
          key = sourceKeys[index3];
          target2[key] = source[key];
        }
      }
      return target2;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number2) {
      return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
    }
    var isNothing_1 = isNothing;
    var isObject_1 = isObject;
    var toArray_1 = toArray;
    var repeat_1 = repeat;
    var isNegativeZero_1 = isNegativeZero;
    var extend_1 = extend;
    var common = {
      isNothing: isNothing_1,
      isObject: isObject_1,
      toArray: toArray_1,
      repeat: repeat_1,
      isNegativeZero: isNegativeZero_1,
      extend: extend_1
    };
    function YAMLException$1(reason, mark2) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark2;
      this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException$1.prototype = Object.create(Error.prototype);
    YAMLException$1.prototype.constructor = YAMLException$1;
    YAMLException$1.prototype.toString = function toString2(compact) {
      var result = this.name + ": ";
      result += this.reason || "(unknown reason)";
      if (!compact && this.mark) {
        result += " " + this.mark.toString();
      }
      return result;
    };
    var exception = YAMLException$1;
    function Mark(name2, buffer, position2, line2, column) {
      this.name = name2;
      this.buffer = buffer;
      this.position = position2;
      this.line = line2;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head2, start2, tail, end2, snippet;
      if (!this.buffer)
        return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head2 = "";
      start2 = this.position;
      while (start2 > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start2 - 1)) === -1) {
        start2 -= 1;
        if (this.position - start2 > maxLength / 2 - 1) {
          head2 = " ... ";
          start2 += 5;
          break;
        }
      }
      tail = "";
      end2 = this.position;
      while (end2 < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end2)) === -1) {
        end2 += 1;
        if (end2 - this.position > maxLength / 2 - 1) {
          tail = " ... ";
          end2 -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start2, end2);
      return common.repeat(" ", indent) + head2 + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start2 + head2.length) + "^";
    };
    Mark.prototype.toString = function toString2(compact) {
      var snippet, where = "";
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ":\n" + snippet;
        }
      }
      return where;
    };
    var mark = Mark;
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map2) {
      var result = {};
      if (map2 !== null) {
        Object.keys(map2).forEach(function(style) {
          map2[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type$1(tag2, options4) {
      options4 = options4 || {};
      Object.keys(options4).forEach(function(name2) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
          throw new exception('Unknown option "' + name2 + '" is met in definition of "' + tag2 + '" YAML type.');
        }
      });
      this.tag = tag2;
      this.kind = options4["kind"] || null;
      this.resolve = options4["resolve"] || function() {
        return true;
      };
      this.construct = options4["construct"] || function(data2) {
        return data2;
      };
      this.instanceOf = options4["instanceOf"] || null;
      this.predicate = options4["predicate"] || null;
      this.represent = options4["represent"] || null;
      this.defaultStyle = options4["defaultStyle"] || null;
      this.styleAliases = compileStyleAliases(options4["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag2 + '" YAML type.');
      }
    }
    var type = Type$1;
    function compileList(schema2, name2, result) {
      var exclude = [];
      schema2.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name2, result);
      });
      schema2[name2].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function(type2, index3) {
        return exclude.indexOf(index3) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index3, length;
      function collectType(type2) {
        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
      }
      for (index3 = 0, length = arguments.length; index3 < length; index3 += 1) {
        arguments[index3].forEach(collectType);
      }
      return result;
    }
    function Schema$1(definition2) {
      this.include = definition2.include || [];
      this.implicit = definition2.implicit || [];
      this.explicit = definition2.explicit || [];
      this.implicit.forEach(function(type2) {
        if (type2.loadKind && type2.loadKind !== "scalar") {
          throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
      });
      this.compiledImplicit = compileList(this, "implicit", []);
      this.compiledExplicit = compileList(this, "explicit", []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema$1.DEFAULT = null;
    Schema$1.create = function createSchema() {
      var schemas, types3;
      switch (arguments.length) {
        case 1:
          schemas = Schema$1.DEFAULT;
          types3 = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types3 = arguments[1];
          break;
        default:
          throw new exception("Wrong number of arguments for Schema.create function");
      }
      schemas = common.toArray(schemas);
      types3 = common.toArray(types3);
      if (!schemas.every(function(schema2) {
        return schema2 instanceof Schema$1;
      })) {
        throw new exception("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      }
      if (!types3.every(function(type$1) {
        return type$1 instanceof type;
      })) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      return new Schema$1({
        include: schemas,
        explicit: types3
      });
    };
    var schema = Schema$1;
    var str2 = new type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data2) {
        return data2 !== null ? data2 : "";
      }
    });
    var seq = new type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data2) {
        return data2 !== null ? data2 : [];
      }
    });
    var map = new type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data2) {
        return data2 !== null ? data2 : {};
      }
    });
    var failsafe = new schema({
      explicit: [
        str2,
        seq,
        map
      ]
    });
    function resolveYamlNull(data2) {
      if (data2 === null)
        return true;
      var max = data2.length;
      return max === 1 && data2 === "~" || max === 4 && (data2 === "null" || data2 === "Null" || data2 === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    var _null = new type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
    function resolveYamlBoolean(data2) {
      if (data2 === null)
        return false;
      var max = data2.length;
      return max === 4 && (data2 === "true" || data2 === "True" || data2 === "TRUE") || max === 5 && (data2 === "false" || data2 === "False" || data2 === "FALSE");
    }
    function constructYamlBoolean(data2) {
      return data2 === "true" || data2 === "True" || data2 === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    var bool = new type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data2) {
      if (data2 === null)
        return false;
      var max = data2.length, index3 = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data2[index3];
      if (ch === "-" || ch === "+") {
        ch = data2[++index3];
      }
      if (ch === "0") {
        if (index3 + 1 === max)
          return true;
        ch = data2[++index3];
        if (ch === "b") {
          index3++;
          for (; index3 < max; index3++) {
            ch = data2[index3];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index3++;
          for (; index3 < max; index3++) {
            ch = data2[index3];
            if (ch === "_")
              continue;
            if (!isHexCode(data2.charCodeAt(index3)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        for (; index3 < max; index3++) {
          ch = data2[index3];
          if (ch === "_")
            continue;
          if (!isOctCode(data2.charCodeAt(index3)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "_")
        return false;
      for (; index3 < max; index3++) {
        ch = data2[index3];
        if (ch === "_")
          continue;
        if (ch === ":")
          break;
        if (!isDecCode(data2.charCodeAt(index3))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      if (ch !== ":")
        return true;
      return /^(:[0-5]?[0-9])+$/.test(data2.slice(index3));
    }
    function constructYamlInteger(data2) {
      var value = data2, sign = 1, ch, base2, digits = [];
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
      }
      if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base2 = 1;
        digits.forEach(function(d2) {
          value += d2 * base2;
          base2 *= 60;
        });
        return sign * value;
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    var int_1 = new type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data2) {
      if (data2 === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data2) || data2[data2.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data2) {
      var value, sign, base2, digits;
      value = data2.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      digits = [];
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      } else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseFloat(v, 10));
        });
        value = 0;
        base2 = 1;
        digits.forEach(function(d2) {
          value += d2 * base2;
          base2 *= 60;
        });
        return sign * value;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res2;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res2 = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res2) ? res2.replace("e", ".e") : res2;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    var float_1 = new type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
    var json = new schema({
      include: [
        failsafe
      ],
      implicit: [
        _null,
        bool,
        int_1,
        float_1
      ]
    });
    var core = new schema({
      include: [
        json
      ]
    });
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data2) {
      if (data2 === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data2) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data2) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data2) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta2 = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data2);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data2);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta2 = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta2 = -delta2;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta2)
        date.setTime(date.getTime() - delta2);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    var timestamp = new type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
    function resolveYamlMerge(data2) {
      return data2 === "<<" || data2 === null;
    }
    var merge = new type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
    var NodeBuffer;
    try {
      _require$1 = commonjsRequire;
      NodeBuffer = _require$1("buffer").Buffer;
    } catch (__) {
    }
    var _require$1;
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data2) {
      if (data2 === null)
        return false;
      var code2, idx, bitlen = 0, max = data2.length, map2 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code2 = map2.indexOf(data2.charAt(idx));
        if (code2 > 64)
          continue;
        if (code2 < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data2) {
      var idx, tailbits, input = data2.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map2.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      if (NodeBuffer) {
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map2[bits >> 18 & 63];
          result += map2[bits >> 12 & 63];
          result += map2[bits >> 6 & 63];
          result += map2[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      } else if (tail === 2) {
        result += map2[bits >> 10 & 63];
        result += map2[bits >> 4 & 63];
        result += map2[bits << 2 & 63];
        result += map2[64];
      } else if (tail === 1) {
        result += map2[bits >> 2 & 63];
        result += map2[bits << 4 & 63];
        result += map2[64];
        result += map2[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    var binary = new type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
    var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    var _toString$2 = Object.prototype.toString;
    function resolveYamlOmap(data2) {
      if (data2 === null)
        return true;
      var objectKeys = [], index3, length, pair, pairKey, pairHasKey, object = data2;
      for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
        pair = object[index3];
        pairHasKey = false;
        if (_toString$2.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty$3.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data2) {
      return data2 !== null ? data2 : [];
    }
    var omap = new type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
    var _toString$1 = Object.prototype.toString;
    function resolveYamlPairs(data2) {
      if (data2 === null)
        return true;
      var index3, length, pair, keys2, result, object = data2;
      result = new Array(object.length);
      for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
        pair = object[index3];
        if (_toString$1.call(pair) !== "[object Object]")
          return false;
        keys2 = Object.keys(pair);
        if (keys2.length !== 1)
          return false;
        result[index3] = [keys2[0], pair[keys2[0]]];
      }
      return true;
    }
    function constructYamlPairs(data2) {
      if (data2 === null)
        return [];
      var index3, length, pair, keys2, result, object = data2;
      result = new Array(object.length);
      for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
        pair = object[index3];
        keys2 = Object.keys(pair);
        result[index3] = [keys2[0], pair[keys2[0]]];
      }
      return result;
    }
    var pairs = new type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
    var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data2) {
      if (data2 === null)
        return true;
      var key, object = data2;
      for (key in object) {
        if (_hasOwnProperty$2.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data2) {
      return data2 !== null ? data2 : {};
    }
    var set = new type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
    var default_safe = new schema({
      include: [
        core
      ],
      implicit: [
        timestamp,
        merge
      ],
      explicit: [
        binary,
        omap,
        pairs,
        set
      ]
    });
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return void 0;
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined(object) {
      return typeof object === "undefined";
    }
    var _undefined = new type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });
    function resolveJavascriptRegExp(data2) {
      if (data2 === null)
        return false;
      if (data2.length === 0)
        return false;
      var regexp2 = data2, tail = /\/([gim]*)$/.exec(data2), modifiers = "";
      if (regexp2[0] === "/") {
        if (tail)
          modifiers = tail[1];
        if (modifiers.length > 3)
          return false;
        if (regexp2[regexp2.length - modifiers.length - 1] !== "/")
          return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data2) {
      var regexp2 = data2, tail = /\/([gim]*)$/.exec(data2), modifiers = "";
      if (regexp2[0] === "/") {
        if (tail)
          modifiers = tail[1];
        regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1);
      }
      return new RegExp(regexp2, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      if (object.global)
        result += "g";
      if (object.multiline)
        result += "m";
      if (object.ignoreCase)
        result += "i";
      return result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    var regexp = new type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
    var esprima;
    try {
      _require = commonjsRequire;
      esprima = _require("esprima");
    } catch (_) {
      if (typeof window !== "undefined")
        esprima = window.esprima;
    }
    var _require;
    function resolveJavascriptFunction(data2) {
      if (data2 === null)
        return false;
      try {
        var source = "(" + data2 + ")", ast2 = esprima.parse(source, { range: true });
        if (ast2.type !== "Program" || ast2.body.length !== 1 || ast2.body[0].type !== "ExpressionStatement" || ast2.body[0].expression.type !== "ArrowFunctionExpression" && ast2.body[0].expression.type !== "FunctionExpression") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    function constructJavascriptFunction(data2) {
      var source = "(" + data2 + ")", ast2 = esprima.parse(source, { range: true }), params = [], body2;
      if (ast2.type !== "Program" || ast2.body.length !== 1 || ast2.body[0].type !== "ExpressionStatement" || ast2.body[0].expression.type !== "ArrowFunctionExpression" && ast2.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
      }
      ast2.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      });
      body2 = ast2.body[0].expression.body.range;
      if (ast2.body[0].expression.body.type === "BlockStatement") {
        return new Function(params, source.slice(body2[0] + 1, body2[1] - 1));
      }
      return new Function(params, "return " + source.slice(body2[0], body2[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    var _function = new type("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction,
      represent: representJavascriptFunction
    });
    var default_full = schema.DEFAULT = new schema({
      include: [
        default_safe
      ],
      explicit: [
        _undefined,
        regexp,
        _function
      ]
    });
    var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State$1(input, options4) {
      this.input = input;
      this.filename = options4["filename"] || null;
      this.schema = options4["schema"] || default_full;
      this.onWarning = options4["onWarning"] || null;
      this.legacy = options4["legacy"] || false;
      this.json = options4["json"] || false;
      this.listener = options4["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];
    }
    function generateError(state, message2) {
      return new exception(message2, new mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
    }
    function throwError(state, message2) {
      throw generateError(state, message2);
    }
    function throwWarning(state, message2) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message2));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name2, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name2, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty$1.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start2, end2, checkJson) {
      var _position, _length, _character, _result;
      if (start2 < end2) {
        _result = state.input.slice(start2, end2);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index3, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index3 = 0, quantity = sourceKeys.length; index3 < quantity; index3 += 1) {
        key = sourceKeys[index3];
        if (!_hasOwnProperty$1.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index3, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index3 = 0, quantity = keyNode.length; index3 < quantity; index3 += 1) {
          if (Array.isArray(keyNode[index3])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index3]) === "[object Object]") {
            keyNode[index3] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index3 = 0, quantity = valueNode.length; index3 < quantity; index3 += 1) {
            mergeMappings(state, _result, valueNode[index3], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        _pos = state.position;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!state.anchorMap.hasOwnProperty(alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type2, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
          if (state.result !== null && state.kind !== "scalar") {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
          }
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type2 = state.implicitTypes[typeIndex];
            if (type2.resolve(state.result)) {
              state.result = type2.construct(state.result);
              state.tag = type2.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type2 = state.typeMap[state.kind || "fallback"][state.tag];
          if (state.result !== null && type2.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
          }
          if (!type2.resolve(state.result)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type2.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options4) {
      input = String(input);
      options4 = options4 || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State$1(input, options4);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll$1(input, iterator, options4) {
      if (iterator !== null && typeof iterator === "object" && typeof options4 === "undefined") {
        options4 = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options4);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index3 = 0, length = documents.length; index3 < length; index3 += 1) {
        iterator(documents[index3]);
      }
    }
    function load$12(input, options4) {
      var documents = loadDocuments(input, options4);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new exception("expected a single document in the stream, but found more");
    }
    function safeLoadAll$1(input, iterator, options4) {
      if (typeof iterator === "object" && iterator !== null && typeof options4 === "undefined") {
        options4 = iterator;
        iterator = null;
      }
      return loadAll$1(input, iterator, common.extend({ schema: default_safe }, options4));
    }
    function safeLoad$1(input, options4) {
      return load$12(input, common.extend({ schema: default_safe }, options4));
    }
    var loadAll_1 = loadAll$1;
    var load_1 = load$12;
    var safeLoadAll_1 = safeLoadAll$1;
    var safeLoad_1 = safeLoad$1;
    var loader = {
      loadAll: loadAll_1,
      load: load_1,
      safeLoadAll: safeLoadAll_1,
      safeLoad: safeLoad_1
    };
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema2, map2) {
      var result, keys2, index3, length, tag2, style, type2;
      if (map2 === null)
        return {};
      result = {};
      keys2 = Object.keys(map2);
      for (index3 = 0, length = keys2.length; index3 < length; index3 += 1) {
        tag2 = keys2[index3];
        style = String(map2[tag2]);
        if (tag2.slice(0, 2) === "!!") {
          tag2 = "tag:yaml.org,2002:" + tag2.slice(2);
        }
        type2 = schema2.compiledTypeMap["fallback"][tag2];
        if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
          style = type2.styleAliases[style];
        }
        result[tag2] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    function State(options4) {
      this.schema = options4["schema"] || default_full;
      this.indent = Math.max(1, options4["indent"] || 2);
      this.noArrayIndent = options4["noArrayIndent"] || false;
      this.skipInvalid = options4["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options4["flowLevel"]) ? -1 : options4["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options4["styles"] || null);
      this.sortKeys = options4["sortKeys"] || false;
      this.lineWidth = options4["lineWidth"] || 80;
      this.noRefs = options4["noRefs"] || false;
      this.noCompatMode = options4["noCompatMode"] || false;
      this.condenseFlow = options4["condenseFlow"] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces2) {
      var ind = common.repeat(" ", spaces2), position2 = 0, next = -1, result = "", line2, length = string.length;
      while (position2 < length) {
        next = string.indexOf("\n", position2);
        if (next === -1) {
          line2 = string.slice(position2);
          position2 = length;
        } else {
          line2 = string.slice(position2, next + 1);
          position2 = next + 1;
        }
        if (line2.length && line2 !== "\n")
          result += ind;
        result += line2;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str3) {
      var index3, length, type2;
      for (index3 = 0, length = state.implicitTypes.length; index3 < length; index3 += 1) {
        type2 = state.implicitTypes[index3];
        if (type2.resolve(str3)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
    }
    function isNsChar(c) {
      return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev) {
      return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i2;
      var char, prev_char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        for (i2 = 0; i2 < string.length; i2++) {
          char = string.charCodeAt(i2);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i2 > 0 ? string.charCodeAt(i2 - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
      } else {
        for (i2 = 0; i2 < string.length; i2++) {
          char = string.charCodeAt(i2);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i2;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i2 > 0 ? string.charCodeAt(i2 - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string) + '"';
          default:
            throw new exception("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line2 = match[2];
        moreIndented = line2[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line2 !== "" ? "\n" : "") + foldLine(line2, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line2, width) {
      if (line2 === "" || line2[0] === " ")
        return line2;
      var breakRe = / [^ ]/g;
      var match;
      var start2 = 0, end2, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line2)) {
        next = match.index;
        if (next - start2 > width) {
          end2 = curr > start2 ? curr : next;
          result += "\n" + line2.slice(start2, end2);
          start2 = end2 + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line2.length - start2 > width && curr > start2) {
        result += line2.slice(start2, curr) + "\n" + line2.slice(curr + 1);
      } else {
        result += line2.slice(start2);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char, nextChar;
      var escapeSeq;
      for (var i2 = 0; i2 < string.length; i2++) {
        char = string.charCodeAt(i2);
        if (char >= 55296 && char <= 56319) {
          nextChar = string.charCodeAt(i2 + 1);
          if (nextChar >= 56320 && nextChar <= 57343) {
            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
            i2++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i2] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index3, length;
      for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
        if (writeNode(state, level, object[index3], false, false)) {
          if (index3 !== 0)
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index3, length;
      for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
        if (writeNode(state, level + 1, object[index3], true, true)) {
          if (!compact || index3 !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index3, length, objectKey, objectValue, pairBuffer;
      for (index3 = 0, length = objectKeyList.length; index3 < length; index3 += 1) {
        pairBuffer = "";
        if (index3 !== 0)
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index3];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index3, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new exception("sortKeys must be a boolean or a function");
      }
      for (index3 = 0, length = objectKeyList.length; index3 < length; index3 += 1) {
        pairBuffer = "";
        if (!compact || index3 !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index3];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index3, length, type2, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index3 = 0, length = typeList.length; index3 < length; index3 += 1) {
        type2 = typeList[index3];
        if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
          state.tag = explicit ? type2.tag : "?";
          if (type2.represent) {
            style = state.styleMap[type2.tag] || type2.defaultStyle;
            if (_toString.call(type2.represent) === "[object Function]") {
              _result = type2.represent(object, style);
            } else if (_hasOwnProperty.call(type2.represent, style)) {
              _result = type2.represent[style](object, style);
            } else {
              throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block2, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type2 = _toString.call(state.dump);
      if (block2) {
        block2 = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type2 === "[object Object]") {
          if (block2 && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type2 === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block2 && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type2 === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid)
            return false;
          throw new exception("unacceptable kind of an object to dump " + type2);
        }
        if (state.tag !== null && state.tag !== "?") {
          state.dump = "!<" + state.tag + "> " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index3, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index3 = 0, length = duplicatesIndexes.length; index3 < length; index3 += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index3]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index3, length;
      if (object !== null && typeof object === "object") {
        index3 = objects.indexOf(object);
        if (index3 !== -1) {
          if (duplicatesIndexes.indexOf(index3) === -1) {
            duplicatesIndexes.push(index3);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
              inspectNode(object[index3], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index3 = 0, length = objectKeyList.length; index3 < length; index3 += 1) {
              inspectNode(object[objectKeyList[index3]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump$1(input, options4) {
      options4 = options4 || {};
      var state = new State(options4);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true))
        return state.dump + "\n";
      return "";
    }
    function safeDump$1(input, options4) {
      return dump$1(input, common.extend({ schema: default_safe }, options4));
    }
    var dump_1 = dump$1;
    var safeDump_1 = safeDump$1;
    var dumper = {
      dump: dump_1,
      safeDump: safeDump_1
    };
    function deprecated(name2) {
      return function() {
        throw new Error("Function " + name2 + " is deprecated and cannot be used.");
      };
    }
    var Type = type;
    var Schema = schema;
    var FAILSAFE_SCHEMA = failsafe;
    var JSON_SCHEMA = json;
    var CORE_SCHEMA = core;
    var DEFAULT_SAFE_SCHEMA = default_safe;
    var DEFAULT_FULL_SCHEMA = default_full;
    var load2 = loader.load;
    var loadAll = loader.loadAll;
    var safeLoad = loader.safeLoad;
    var safeLoadAll = loader.safeLoadAll;
    var dump = dumper.dump;
    var safeDump = dumper.safeDump;
    var YAMLException = exception;
    var MINIMAL_SCHEMA = failsafe;
    var SAFE_SCHEMA = default_safe;
    var DEFAULT_SCHEMA = default_full;
    var scan = deprecated("scan");
    var parse2 = deprecated("parse");
    var compose = deprecated("compose");
    var addConstructor = deprecated("addConstructor");
    var jsYaml$1 = {
      Type,
      Schema,
      FAILSAFE_SCHEMA,
      JSON_SCHEMA,
      CORE_SCHEMA,
      DEFAULT_SAFE_SCHEMA,
      DEFAULT_FULL_SCHEMA,
      load: load2,
      loadAll,
      safeLoad,
      safeLoadAll,
      dump,
      safeDump,
      YAMLException,
      MINIMAL_SCHEMA,
      SAFE_SCHEMA,
      DEFAULT_SCHEMA,
      scan,
      parse: parse2,
      compose,
      addConstructor
    };
    var jsYaml = jsYaml$1;
    var matchHtmlRegExp = /["'&<>]/;
    var escapeHtml_1 = escapeHtml;
    function escapeHtml(string) {
      var str3 = "" + string;
      var match = matchHtmlRegExp.exec(str3);
      if (!match) {
        return str3;
      }
      var escape4;
      var html2 = "";
      var index3 = 0;
      var lastIndex = 0;
      for (index3 = match.index; index3 < str3.length; index3++) {
        switch (str3.charCodeAt(index3)) {
          case 34:
            escape4 = "&quot;";
            break;
          case 38:
            escape4 = "&amp;";
            break;
          case 39:
            escape4 = "&#39;";
            break;
          case 60:
            escape4 = "&lt;";
            break;
          case 62:
            escape4 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index3) {
          html2 += str3.substring(lastIndex, index3);
        }
        lastIndex = index3 + 1;
        html2 += escape4;
      }
      return lastIndex !== index3 ? html2 + str3.substring(lastIndex, index3) : html2;
    }
    function _optionalChain(ops) {
      let lastAccessLHS = void 0;
      let value = ops[0];
      let i2 = 1;
      while (i2 < ops.length) {
        const op = ops[i2];
        const fn = ops[i2 + 1];
        i2 += 2;
        if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
          return void 0;
        }
        if (op === "access" || op === "optionalAccess") {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === "call" || op === "optionalCall") {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = void 0;
        }
      }
      return value;
    }
    var newline = "\n";
    function default_frontmatter(value, messages2) {
      try {
        return jsYaml.safeLoad(value);
      } catch (e) {
        messages2.push(new vfileMessage("YAML failed to parse", e));
      }
    }
    function parse_frontmatter({
      parse: parse3,
      type: type2
    }) {
      const transformer = (tree, vFile) => {
        unistUtilVisit(tree, type2, (node) => {
          const data2 = parse3(node.value, vFile.messages);
          if (data2) {
            vFile.data.fm = data2;
          }
        });
      };
      return transformer;
    }
    var entites = [
      [/</g, "&lt;"],
      [/>/g, "&gt;"],
      [/{/g, "&#123;"],
      [/}/g, "&#125;"]
    ];
    function escape_code({ blocks }) {
      return function(tree) {
        if (!blocks) {
          unistUtilVisit(tree, "code", escape4);
        }
        unistUtilVisit(tree, "inlineCode", escape4);
        function escape4(node) {
          for (let i2 = 0; i2 < entites.length; i2 += 1) {
            node.value = node.value.replace(entites[i2][0], entites[i2][1]);
          }
        }
      };
    }
    function smartypants_transformer(options4 = {}) {
      const processor = retext().use(retextSmartypants, options4);
      return function(tree) {
        unistUtilVisit(tree, "text", (node) => {
          node.value = String(processor.processSync(node.value));
        });
      };
    }
    var attrs = `(?:\\s{0,1}[a-zA-z]+=(?:"){0,1}[a-zA-Z0-9]+(?:"){0,1})*`;
    var context = `(?:\\s{0,1}context)=(?:"){0,1}module(?:"){0,1}`;
    var RE_BLANK = /^\n+$|^\s+$/;
    var RE_SCRIPT = new RegExp(`^(<script` + attrs + `>)`);
    var RE_MODULE_SCRIPT = new RegExp(`^(<script` + attrs + context + attrs + `>)`);
    function extract_parts(nodes) {
      const parts = {
        special: [],
        html: [],
        instance: [],
        module: [],
        css: []
      };
      children:
        for (let i2 = 0; i2 < nodes.length; i2 += 1) {
          const empty_node = nodes[i2].type === "text" && RE_BLANK.exec(nodes[i2].value);
          if (empty_node || !nodes[i2].value) {
            if (!parts.html.length || !(RE_BLANK.exec(nodes[i2].value) && RE_BLANK.exec(parts.html[parts.html.length - 1].value))) {
              parts.html.push(nodes[i2]);
            }
            continue children;
          }
          let result;
          try {
            result = compiler$1.parse(nodes[i2].value);
          } catch (e) {
            parts.html.push(nodes[i2]);
            continue children;
          }
          if (!result.html || !result.html.children)
            return parts;
          const _parts = result.html.children.map((v) => {
            if (v.type === "Options" || v.type === "Head" || v.type === "Window" || v.type === "Body") {
              return ["special", v.start, v.end];
            } else {
              return ["html", v.start, v.end];
            }
          });
          results:
            for (const key in result) {
              if (key === "html" || !result[key])
                continue results;
              _parts.push([
                key,
                result[key].start,
                result[key].end
              ]);
            }
          const sorted = _parts.sort((a, b) => a[1] - b[1]);
          sorted.forEach((next) => {
            parts[next[0]].push({
              type: "raw",
              value: nodes[i2].value.substring(next[1], next[2])
            });
          });
        }
      return parts;
    }
    function map_layout_to_path(filename, layout_map) {
      const match = Object.keys(layout_map).find((l2) => new RegExp(`\\${path__namespace.sep}${l2}\\${path__namespace.sep}`).test(path__namespace.normalize(filename).replace(process.cwd(), "")));
      if (match) {
        return layout_map[match];
      } else {
        return layout_map["_"] ? layout_map["_"] : void 0;
      }
    }
    function generate_layout_import(layout) {
      if (!layout)
        return false;
      return `import Layout_MDSVEX_DEFAULT${layout.components.length ? `, * as Components` : ""} from '${layout.path}';`;
    }
    function generate_layout({
      frontmatter_layout,
      layout_options,
      layout_mode,
      filename
    }) {
      let selected_layout;
      const error3 = { reason: "" };
      if (!layout_options || frontmatter_layout === false) {
        return [false, false, false];
      } else if (layout_mode === "single") {
        selected_layout = layout_options.__mdsvex_default;
        if (frontmatter_layout)
          error3.reason = `You attempted to apply a named layout in the front-matter of "${filename}", but did not provide any named layouts as options to the preprocessor. `;
      } else if (frontmatter_layout) {
        selected_layout = layout_options[frontmatter_layout];
        if (!selected_layout)
          error3.reason = `Could not find a layout with the name "${frontmatter_layout}" and no fall back layout ("_") was provided.`;
      } else {
        selected_layout = map_layout_to_path(filename, layout_options);
      }
      return [
        generate_layout_import(selected_layout),
        selected_layout !== void 0 && selected_layout.components.length > 0 && selected_layout.components,
        error3.reason ? error3 : false
      ];
    }
    function transform_hast({
      layout,
      layout_mode
    }) {
      return function transformer(tree, vFile) {
        unistUtilVisit(tree, "element", (node) => {
          if (node.tagName === "a" && node.properties && typeof node.properties.href === "string") {
            node.properties.href = node.properties.href.replace(/%7B/g, "{").replace(/%7D/g, "}");
          }
          if (node.tagName === "img" && node.properties && typeof node.properties.src === "string") {
            node.properties.src = node.properties.src.replace(/%7B/g, "{").replace(/%7D/g, "}");
          }
        });
        if (!layout && !vFile.data.fm)
          return tree;
        unistUtilVisit(tree, "root", (node) => {
          const { special, html: html2, instance, module: _module, css: css2 } = extract_parts(node.children);
          const fm = vFile.data.fm && `export const metadata = ${JSON.stringify(vFile.data.fm)};${newline}	const { ${Object.keys(vFile.data.fm).join(", ")} } = metadata;`;
          const _fm_layout = vFile.data.fm && vFile.data.fm.layout;
          const [import_script, components, error3] = generate_layout({
            frontmatter_layout: _fm_layout,
            layout_options: layout,
            layout_mode,
            filename: vFile.filename
          });
          if (error3)
            vFile.messages.push(new vfileMessage(error3.reason));
          if (components) {
            for (let i2 = 0; i2 < components.length; i2++) {
              unistUtilVisit(tree, "element", (node2) => {
                if (node2.tagName === components[i2]) {
                  node2.tagName = `Components.${components[i2]}`;
                }
              });
            }
          }
          if (import_script && !instance[0]) {
            instance.push({
              type: "raw",
              value: `${newline}<script>${newline}	${import_script}${newline}<\/script>${newline}`
            });
          } else if (import_script) {
            instance[0].value = instance[0].value.replace(RE_SCRIPT, `$1${newline}	${import_script}`);
          }
          if (!_module[0] && fm) {
            _module.push({
              type: "raw",
              value: `<script context="module">${newline}	${fm}${newline}<\/script>`
            });
          } else if (fm) {
            _module[0].value = _module[0].value.replace(RE_MODULE_SCRIPT, `$1${newline}	${fm}`);
          }
          node.children = [
            ..._module,
            { type: "raw", value: _module[0] ? newline : "" },
            ...instance,
            { type: "raw", value: instance[0] ? newline : "" },
            ...css2,
            { type: "raw", value: css2[0] ? newline : "" },
            ...special,
            { type: "raw", value: special[0] ? newline : "" },
            {
              type: "raw",
              value: import_script ? `<Layout_MDSVEX_DEFAULT {...$$props}${fm ? " {...metadata}" : ""}>` : ""
            },
            { type: "raw", value: newline },
            ...html2,
            { type: "raw", value: newline },
            { type: "raw", value: import_script ? "</Layout_MDSVEX_DEFAULT>" : "" }
          ];
        });
      };
    }
    var langs = {};
    var Prism;
    var make_path = (base_path, id) => base_path.replace("{id}", id);
    function get_lang_info(name2, lang_meta, base_path) {
      const _lang_meta = {
        name: name2,
        path: `prismjs/${make_path(base_path, name2)}`,
        deps: new Set()
      };
      const aliases = new Set();
      if (lang_meta.require) {
        if (Array.isArray(lang_meta.require)) {
          lang_meta.require.forEach((id) => _lang_meta.deps.add(id));
        } else {
          _lang_meta.deps.add(lang_meta.require);
        }
      }
      if (lang_meta.peerDependencies) {
        if (Array.isArray(lang_meta.peerDependencies)) {
          lang_meta.peerDependencies.forEach((id) => _lang_meta.deps.add(id));
        } else {
          _lang_meta.deps.add(lang_meta.peerDependencies);
        }
      }
      if (lang_meta.alias) {
        if (Array.isArray(lang_meta.alias)) {
          lang_meta.alias.forEach((id) => aliases.add(id));
        } else {
          aliases.add(lang_meta.alias);
        }
      }
      return [{ ..._lang_meta, aliases }, aliases];
    }
    function load_language_metadata() {
      if (!process.browser) {
        const {
          meta: meta2,
          ...languages
        } = require_components().languages;
        for (const lang2 in languages) {
          const [lang_info, aliases] = get_lang_info(lang2, languages[lang2], meta2.path);
          langs[lang2] = lang_info;
          aliases.forEach((_n) => {
            langs[_n] = langs[lang2];
          });
        }
        const svelte_meta = {
          name: "svelte",
          aliases: new Set(["sv"]),
          path: "prism-svelte",
          deps: new Set(["javscript", "css"])
        };
        langs.svelte = svelte_meta;
        langs.sv = svelte_meta;
      }
    }
    function load_language(lang2) {
      if (!process.browser) {
        if (!langs[lang2])
          return;
        langs[lang2].deps.forEach((name2) => load_language(name2));
        require(langs[lang2].path);
      }
    }
    function highlight_blocks({
      highlighter: highlight_fn,
      alias
    } = {}) {
      if (highlight_fn && !process.browser) {
        load_language_metadata();
        if (alias) {
          for (const lang2 in alias) {
            langs[lang2] = langs[alias[lang2]];
          }
        }
      }
      return async function(tree) {
        if (highlight_fn) {
          const nodes = [];
          unistUtilVisit(tree, "code", (node) => {
            nodes.push(node);
          });
          await Promise.all(nodes.map(async (node) => {
            node.type = "html";
            node.value = await highlight_fn(node.value, node.lang, node.meta);
          }));
        }
      };
    }
    var escape_svelty = (str3) => str3.replace(/[{}`]/g, (c) => ({ "{": "&#123;", "}": "&#125;", "`": "&#96;" })[c]).replace(/\\([trn])/g, "&#92;$1");
    var code_highlight = (code2, lang2) => {
      const normalised_lang = _optionalChain([lang2, "optionalAccess", (_) => _.toLowerCase, "call", (_2) => _2()]);
      if (!process.browser) {
        let _lang = !!normalised_lang && langs[normalised_lang];
        if (!Prism)
          Prism = require_prism();
        if (_lang && !Prism.languages[_lang.name]) {
          load_language(_lang.name);
        }
        if (!_lang && normalised_lang && Prism.languages[normalised_lang]) {
          langs[normalised_lang] = { name: lang2 };
          _lang = langs[normalised_lang];
        }
        const highlighted = escape_svelty(_lang ? Prism.highlight(code2, Prism.languages[_lang.name], _lang.name) : escapeHtml_1(code2));
        return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
      } else {
        const highlighted = escape_svelty(escapeHtml_1(code2));
        return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
      }
    };
    function stringify(options4 = {}) {
      this.Compiler = compiler2;
      function compiler2(tree) {
        return prettyhtmlHastToHtml(tree, options4);
      }
    }
    var apply_plugins = (plugins, parser2) => {
      plugins.forEach((plugin) => {
        if (Array.isArray(plugin)) {
          if (plugin[1] && plugin[1])
            parser2.use(plugin[0], plugin[1]);
          else
            parser2.use(plugin[0]);
        } else {
          parser2.use(plugin);
        }
      });
      return parser2;
    };
    function transform({
      remarkPlugins = [],
      rehypePlugins = [],
      frontmatter: frontmatter2,
      smartypants: smartypants2,
      layout,
      layout_mode,
      highlight
    } = { layout_mode: "single" }) {
      const fm_opts = frontmatter2 ? frontmatter2 : { parse: default_frontmatter, type: "yaml", marker: "-" };
      const toMDAST = unified_1$1().use(remarkParse).use(mdsvex_parser).use(remarkExternalLinks, { target: false, rel: ["nofollow"] }).use(escape_code, { blocks: !!highlight }).use(remarkFrontmatter, [{ type: fm_opts.type, marker: fm_opts.marker }]).use(parse_frontmatter, { parse: fm_opts.parse, type: fm_opts.type });
      if (smartypants2) {
        toMDAST.use(smartypants_transformer, typeof smartypants2 === "boolean" ? {} : smartypants2);
      }
      apply_plugins(remarkPlugins, toMDAST).use(highlight_blocks, highlight || {});
      const toHAST = toMDAST.use(remarkRehype, {
        allowDangerousHtml: true,
        allowDangerousCharacters: true
      }).use(transform_hast, { layout, layout_mode });
      apply_plugins(rehypePlugins, toHAST);
      const processor = toHAST.use(stringify, {
        allowDangerousHtml: true,
        allowDangerousCharacters: true
      });
      return processor;
    }
    var defaults = {
      remarkPlugins: [],
      rehypePlugins: [],
      smartypants: true,
      extension: ".svx",
      highlight: { highlighter: code_highlight }
    };
    function to_posix(_path) {
      const isExtendedLengthPath = /^\\\\\?\\/.test(_path);
      const hasNonAscii = /[^\u0000-\u0080]+/.test(_path);
      if (isExtendedLengthPath || hasNonAscii) {
        return _path;
      }
      return _path.replace(/\\/g, "/");
    }
    function resolve_layout(layout_path) {
      try {
        return to_posix(require.resolve(layout_path));
      } catch (e) {
        try {
          const _path = path2.join(process.cwd(), layout_path);
          return to_posix(require.resolve(_path));
        } catch (e2) {
          throw new Error(`The layout path you provided couldn't be found at either ${layout_path} or ${path2.join(process.cwd(), layout_path)}. Please double-check it and try again.`);
        }
      }
    }
    function process_layouts(layouts) {
      const _layouts = layouts;
      for (const key in _layouts) {
        const layout = fs__default["default"].readFileSync(_layouts[key].path, { encoding: "utf8" });
        const ast2 = compiler$1.parse(layout);
        if (ast2.module) {
          const component_exports = ast2.module.content.body.filter((node) => node.type === "ExportNamedDeclaration");
          if (component_exports.length) {
            _layouts[key].components = [];
            for (let i2 = 0; i2 < component_exports.length; i2++) {
              if (component_exports[i2].specifiers && component_exports[i2].specifiers.length) {
                for (let j = 0; j < component_exports[i2].specifiers.length; j++) {
                  _layouts[key].components.push(component_exports[i2].specifiers[j].exported.name);
                }
              } else if (component_exports[i2].declaration.declarations) {
                const declarations = component_exports[i2].declaration.declarations;
                for (let j = 0; j < declarations.length; j++) {
                  _layouts[key].components.push(declarations[j].id.name);
                }
              } else if (component_exports[i2].declaration) {
                _layouts[key].components.push(component_exports[i2].declaration.id.name);
              }
            }
          }
        }
      }
      return _layouts;
    }
    var mdsvex = (options4 = defaults) => {
      const {
        remarkPlugins = [],
        rehypePlugins = [],
        smartypants: smartypants2 = true,
        extension = ".svx",
        extensions,
        layout = false,
        highlight = { highlighter: code_highlight },
        frontmatter: frontmatter2
      } = options4;
      if (options4.layouts) {
        throw new Error(`mdsvex: "layouts" is not a valid option. Did you mean "layout"?`);
      }
      const unknown_opts = [];
      const known_opts = [
        "filename",
        "remarkPlugins",
        "rehypePlugins",
        "smartypants",
        "extension",
        "extensions",
        "layout",
        "highlight",
        "frontmatter"
      ];
      for (const opt in options4) {
        if (!known_opts.includes(opt))
          unknown_opts.push(opt);
      }
      if (unknown_opts.length) {
        console.warn(`mdsvex: Received unknown options: ${unknown_opts.join(", ")}. Valid options are: ${known_opts.join(", ")}.`);
      }
      let _layout2 = {};
      let layout_mode = "single";
      if (typeof layout === "string") {
        _layout2.__mdsvex_default = { path: resolve_layout(layout), components: [] };
      } else if (typeof layout === "object") {
        layout_mode = "named";
        for (const name2 in layout) {
          _layout2[name2] = { path: resolve_layout(layout[name2]), components: [] };
        }
      }
      if (highlight && highlight.highlighter === void 0) {
        highlight.highlighter = code_highlight;
      }
      _layout2 = process_layouts(_layout2);
      const parser2 = transform({
        remarkPlugins,
        rehypePlugins,
        smartypants: smartypants2,
        layout: _layout2,
        layout_mode,
        highlight,
        frontmatter: frontmatter2
      });
      return {
        markup: async ({ content, filename }) => {
          const extensionsParts = (extensions || [extension]).map((ext) => ext.split(".").pop());
          if (!extensionsParts.includes(filename.split(".").pop()))
            return;
          const parsed = await parser2.process({ contents: content, filename });
          return {
            code: parsed.contents,
            data: parsed.data,
            map: ""
          };
        }
      };
    };
    var _compile = (source, opts) => mdsvex(opts).markup({
      content: source,
      filename: opts && opts.filename || `file${opts && (opts.extensions && opts.extensions[0] || opts.extension) || ".svx"}`
    });
    exports2.compile = _compile;
    exports2.escapeSvelte = escape_svelty;
    exports2.mdsvex = mdsvex;
  }
});

// .svelte-kit/netlify/entry.js
__export(exports, {
  handler: () => handler
});
init_shims();

// .svelte-kit/output/server/app.js
init_shims();

// node_modules/@sveltejs/kit/dist/ssr.js
init_shims();

// node_modules/@sveltejs/kit/dist/adapter-utils.js
init_shims();
function isContentTypeTextual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}

// node_modules/@sveltejs/kit/dist/ssr.js
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s2) {
  return typeof s2 === "string" || s2 instanceof String;
}
async function render_endpoint(request, route) {
  const mod = await route.load();
  const handler2 = mod[request.method.toLowerCase().replace("delete", "del")];
  if (!handler2) {
    return;
  }
  const match = route.pattern.exec(request.path);
  if (!match) {
    return error("could not parse parameters from request path");
  }
  const params = route.params(match);
  const response = await handler2({ ...request, params });
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return;
  }
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers = {} } = response;
  headers = lowercase_keys(headers);
  const type = headers["content-type"];
  const is_type_textual = isContentTypeTextual(type);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
    headers = { ...headers, "content-type": "application/json; charset=utf-8" };
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers };
}
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str2 = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str2);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str2;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str2 = String(thing);
  if (typeof thing === "number")
    return str2.replace(/^(-)?0\./, "$1.");
  return str2;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str2) {
  return str2.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str2) {
  var result = '"';
  for (var i = 0; i < str2.length; i += 1) {
    var char = str2.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str2.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str2[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
Promise.resolve();
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = [];
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s2 = subscribers[i];
          s2[1]();
          subscriber_queue.push(s2, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var s$1 = JSON.stringify;
async function render_response({
  branch,
  options: options3,
  $session,
  page_config,
  status,
  error: error3,
  page
}) {
  const css2 = new Set(options3.entry.css);
  const js = new Set(options3.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error3) {
    error3.stack = options3.get_stack(error3);
  }
  if (page_config.ssr) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options3.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options3.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options3.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options3.entry.file)};
			start({
				target: ${options3.target ? `document.querySelector(${s$1(options3.target)})` : "document.body"},
				paths: ${s$1(options3.paths)},
				session: ${try_serialize($session, (error4) => {
      throw new Error(`Failed to serialize session data: ${error4.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options3.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error3)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page && page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page && page.path)},
						query: new URLSearchParams(${page ? s$1(page.query.toString()) : ""}),
						params: ${page && s$1(page.params)}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options3.service_worker) {
    init2 += `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options3.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options3.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options3.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url="${url}"`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n			")}
		`.replace(/^\t{2}/gm, "");
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options3.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options3.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(err);
    return null;
  }
}
function serialize_error(error3) {
  if (!error3)
    return null;
  let serialized = try_serialize(error3);
  if (!serialized) {
    const { name, message, stack } = error3;
    serialized = try_serialize({ ...error3, name, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error3 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error3 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error3}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error3 };
    }
    return { status, error: error3 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  return loaded;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options3,
  state,
  route,
  page,
  node,
  $session,
  context,
  prerender_enabled,
  is_leaf,
  is_error,
  status,
  error: error3
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let loaded;
  const page_proxy = new Proxy(page, {
    get: (target, prop, receiver) => {
      if (prop === "query" && prerender_enabled) {
        throw new Error("Cannot access query on a page with prerendering enabled");
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  if (module2.load) {
    const load_input = {
      page: page_proxy,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        const resolved = resolve(request.path, url.split("?")[0]);
        let response;
        const filename = resolved.replace(options3.paths.assets, "").slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options3.manifest.assets.find((d2) => d2.file === filename || d2.file === filename_html);
        if (asset) {
          response = options3.read ? new Response(options3.read(asset.file), {
            headers: asset.type ? {
              "content-type": asset.type
            } : {}
          }) : await fetch(`http://${page.host}/${asset.file}`, opts);
        } else if (resolved.startsWith("/") && !resolved.startsWith("//")) {
          const relative = resolved;
          const headers = { ...opts.headers };
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers.cookie = request.headers.cookie;
            if (!headers.authorization) {
              headers.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url.includes("?") ? url.slice(url.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers,
            path: relative,
            rawBody: opts.body,
            query: new URLSearchParams(search)
          }, options3, {
            fetched: url,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = {
                ...opts.headers,
                cookie: request.headers.cookie
              };
            }
          }
          const external_request = new Request(url, opts);
          response = await options3.hooks.serverFetch.call(null, external_request);
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 !== "etag" && key2 !== "set-cookie")
                    headers[key2] = value;
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":${escape(body)}}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      context: { ...context }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error3;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize(loaded),
    context: loaded.context || context,
    fetched,
    uses_credentials
  };
}
var escaped = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape(str2) {
  let result = '"';
  for (let i = 0; i < str2.length; i += 1) {
    const char = str2.charAt(i);
    const code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str2.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str2[++i];
      } else {
        result += `\\u${code.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
var absolute = /^([a-z]+:)?\/?\//;
function resolve(base2, path2) {
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path2);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path2.slice(path_match[0].length).split("/") : path2.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function coalesce_to_error(err) {
  return err instanceof Error ? err : new Error(JSON.stringify(err));
}
async function respond_with_error({ request, options: options3, state, $session, status, error: error3 }) {
  const default_layout = await options3.load_component(options3.manifest.layout);
  const default_error = await options3.load_component(options3.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options3,
    state,
    route: null,
    page,
    node: default_layout,
    $session,
    context: {},
    prerender_enabled: is_prerender_enabled(options3, default_error, state),
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options3,
      state,
      route: null,
      page,
      node: default_error,
      $session,
      context: loaded ? loaded.context : {},
      prerender_enabled: is_prerender_enabled(options3, default_error, state),
      is_leaf: false,
      is_error: true,
      status,
      error: error3
    })
  ];
  try {
    return await render_response({
      options: options3,
      $session,
      page_config: {
        hydrate: options3.hydrate,
        router: options3.router,
        ssr: options3.ssr
      },
      status,
      error: error3,
      branch,
      page
    });
  } catch (err) {
    const error4 = coalesce_to_error(err);
    options3.handle_error(error4, request);
    return {
      status: 500,
      headers: {},
      body: error4.stack
    };
  }
}
function is_prerender_enabled(options3, node, state) {
  return options3.prerender && (!!node.module.prerender || !!state.prerender && state.prerender.all);
}
async function respond$1(opts) {
  const { request, options: options3, state, $session, route } = opts;
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id ? options3.load_component(id) : void 0));
  } catch (err) {
    const error4 = coalesce_to_error(err);
    options3.handle_error(error4, request);
    return await respond_with_error({
      request,
      options: options3,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options3);
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: ""
    };
  }
  let branch = [];
  let status = 200;
  let error3;
  ssr:
    if (page_config.ssr) {
      let context = {};
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              ...opts,
              node,
              context,
              prerender_enabled: is_prerender_enabled(options3, node, state),
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            if (loaded.loaded.redirect) {
              return {
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              };
            }
            if (loaded.loaded.error) {
              ({ status, error: error3 } = loaded.loaded);
            }
          } catch (err) {
            const e = coalesce_to_error(err);
            options3.handle_error(e, request);
            status = 500;
            error3 = e;
          }
          if (loaded && !error3) {
            branch.push(loaded);
          }
          if (error3) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options3.load_component(route.b[i]);
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node({
                    ...opts,
                    node: error_node,
                    context: node_loaded.context,
                    prerender_enabled: is_prerender_enabled(options3, error_node, state),
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error3
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options3);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e = coalesce_to_error(err);
                  options3.handle_error(e, request);
                  continue;
                }
              }
            }
            return await respond_with_error({
              request,
              options: options3,
              state,
              $session,
              status,
              error: error3
            });
          }
        }
        if (loaded && loaded.loaded.context) {
          context = {
            ...context,
            ...loaded.loaded.context
          };
        }
      }
    }
  try {
    return await render_response({
      ...opts,
      page_config,
      status,
      error: error3,
      branch: branch.filter(Boolean)
    });
  } catch (err) {
    const error4 = coalesce_to_error(err);
    options3.handle_error(error4, request);
    return await respond_with_error({
      ...opts,
      status: 500,
      error: error4
    });
  }
}
function get_page_config(leaf, options3) {
  return {
    ssr: "ssr" in leaf ? !!leaf.ssr : options3.ssr,
    router: "router" in leaf ? !!leaf.router : options3.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options3.hydrate
  };
}
async function render_page(request, route, options3, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const match = route.pattern.exec(request.path);
  const params = route.params(match);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  const $session = await options3.hooks.getSession(request);
  const response = await respond$1({
    request,
    options: options3,
    state,
    $session,
    route,
    page
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        (map.get(key) || []).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
var ReadOnlyFormData = class {
  #map;
  constructor(map) {
    this.#map = map;
  }
  get(key) {
    const value = this.#map.get(key);
    return value && value[0];
  }
  getAll(key) {
    return this.#map.get(key);
  }
  has(key) {
    return this.#map.has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key] of this.#map)
      yield key;
  }
  *values() {
    for (const [, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield value[i];
      }
    }
  }
};
function parse_body(raw, headers) {
  if (!raw || typeof raw !== "string")
    return raw;
  const [type, ...directives] = headers["content-type"].split(/;\s*/);
  switch (type) {
    case "text/plain":
      return raw;
    case "application/json":
      return JSON.parse(raw);
    case "application/x-www-form-urlencoded":
      return get_urlencoded(raw);
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(raw, boundary.slice("boundary=".length));
    }
    default:
      throw new Error(`Invalid Content-Type ${type}`);
  }
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str2) => {
    const [key, value] = str2.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    const headers = {};
    raw_headers.split("\r\n").forEach((str2) => {
      const [raw_header, ...raw_directives] = str2.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      headers[name] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data;
}
async function respond(incoming, options3, state = {}) {
  if (incoming.path !== "/" && options3.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options3.trailing_slash === "never" || !has_trailing_slash && options3.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path2 = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: options3.paths.base + path2 + (q ? `?${q}` : "")
        }
      };
    }
  }
  const headers = lowercase_keys(incoming.headers);
  const request = {
    ...incoming,
    headers,
    body: parse_body(incoming.rawBody, headers),
    params: {},
    locals: {}
  };
  try {
    return await options3.hooks.handle({
      request,
      resolve: async (request2) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options3,
            $session: await options3.hooks.getSession(request2),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        for (const route of options3.manifest.routes) {
          if (!route.pattern.test(decodeURI(request2.path)))
            continue;
          const response = route.type === "endpoint" ? await render_endpoint(request2, route) : await render_page(request2, route, options3, state);
          if (response) {
            if (response.status === 200) {
              if (!/(no-store|immutable)/.test(response.headers["cache-control"])) {
                const etag = `"${hash(response.body || "")}"`;
                if (request2.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: ""
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        const $session = await options3.hooks.getSession(request2);
        return await respond_with_error({
          request: request2,
          options: options3,
          state,
          $session,
          status: 404,
          error: new Error(`Not found: ${request2.path}`)
        });
      }
    });
  } catch (err) {
    const e = coalesce_to_error(err);
    options3.handle_error(e, request);
    return {
      status: 500,
      headers: {},
      body: options3.dev ? e.stack : e.message
    };
  }
}

// .svelte-kit/output/server/app.js
var import_fs = __toModule(require("fs"));
var import_path = __toModule(require("path"));
var import_gray_matter = __toModule(require_gray_matter());
var import_mdsvex = __toModule(require_main_cjs());
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
Promise.resolve();
var escaped2 = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape2(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped2[match]);
}
function each(items, fn) {
  let str2 = "";
  for (let i = 0; i < items.length; i += 1) {
    str2 += fn(items[i], i);
  }
  return str2;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(parent_component ? parent_component.$$.context : context || []),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape2(value)) : `"${value}"`}`}`;
}
function afterUpdate() {
}
var css = {
  code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n<\/script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\tclip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}\\n</style>"],"names":[],"mappings":"AAsDC,iBAAiB,eAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,SAAS,CAAE,MAAM,GAAG,CAAC,CACrB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${``}`;
});
var base = "";
var assets = "";
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en" data-theme="halloween">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<div id="svelte">' + body + "</div>\n</html>\n";
var options2 = null;
var default_settings = { paths: { "base": "", "assets": "" } };
function init(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  const hooks = get_hooks(user_hooks);
  options2 = {
    amp: false,
    dev: false,
    entry: {
      file: assets + "/_app/start-b2e1cb70.js",
      css: [assets + "/_app/assets/start-8077b9bf.css"],
      js: [assets + "/_app/start-b2e1cb70.js", assets + "/_app/chunks/vendor-812c555e.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => assets + "/_app/" + entry_lookup[id],
    get_stack: (error22) => String(error22),
    handle_error: (error22, request) => {
      hooks.handleError({ error: error22, request });
      error22.stack = options2.get_stack(error22);
    },
    hooks,
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    prerender: true,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var d = decodeURIComponent;
var empty = () => ({});
var manifest = {
  assets: [{ "file": "favicon.png", "size": 1571, "type": "image/png" }],
  layout: "src/routes/__layout.svelte",
  error: ".svelte-kit/build/components/error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/posts\.json$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return posts_json;
      })
    },
    {
      type: "page",
      pattern: /^\/blog\/2018-01-16-berkenalan-dengan-vuejs\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/blog/2018-01-16-berkenalan-dengan-vuejs.md"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/([^/]+?)\.json$/,
      params: (m) => ({ slug: d(m[1]) }),
      load: () => Promise.resolve().then(function() {
        return _slug__json;
      })
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
  handleError: hooks.handleError || (({ error: error22 }) => console.error(error22.stack)),
  serverFetch: hooks.serverFetch || fetch
});
var module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(function() {
    return error2;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index;
  }),
  "src/routes/blog/2018-01-16-berkenalan-dengan-vuejs.md": () => Promise.resolve().then(function() {
    return _20180116BerkenalanDenganVuejs;
  })
};
var metadata_lookup = { "src/routes/__layout.svelte": { "entry": "pages/__layout.svelte-06f73a44.js", "css": ["assets/pages/__layout.svelte-d323f3c5.css"], "js": ["pages/__layout.svelte-06f73a44.js", "chunks/vendor-812c555e.js"], "styles": [] }, ".svelte-kit/build/components/error.svelte": { "entry": "error.svelte-eb65ec09.js", "css": [], "js": ["error.svelte-eb65ec09.js", "chunks/vendor-812c555e.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "pages/index.svelte-973a5231.js", "css": [], "js": ["pages/index.svelte-973a5231.js", "chunks/vendor-812c555e.js"], "styles": [] }, "src/routes/blog/2018-01-16-berkenalan-dengan-vuejs.md": { "entry": "pages/blog/2018-01-16-berkenalan-dengan-vuejs.md-fdfdb836.js", "css": [], "js": ["pages/blog/2018-01-16-berkenalan-dengan-vuejs.md-fdfdb836.js", "chunks/vendor-812c555e.js"], "styles": [] } };
async function load_component(file) {
  const { entry, css: css2, js, styles } = metadata_lookup[file];
  return {
    module: await module_lookup[file](),
    entry: assets + "/_app/" + entry,
    css: css2.map((dep) => assets + "/_app/" + dep),
    js: js.map((dep) => assets + "/_app/" + dep),
    styles
  };
}
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options2, { prerender });
}
async function get$1() {
  const cwd = process.cwd();
  const POSTS_DIR = import_path.default.join(cwd, "src/routes/blog");
  const posts = import_fs.default.readdirSync(POSTS_DIR).map((fileName) => {
    const fileMd = import_fs.default.readFileSync(import_path.default.join(POSTS_DIR, fileName), "utf8");
    const { data, content: rawContent } = (0, import_gray_matter.default)(fileMd);
    const { title, date, slug, description } = data;
    let excerpt = "";
    return {
      title: title || slug,
      slug,
      date,
      excerpt,
      description
    };
  });
  return { body: JSON.stringify(posts) };
}
var posts_json = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$1
});
var getPostsContent = (location) => {
  const directories = import_fs.default.readdirSync(location).filter((element) => import_fs.default.lstatSync(`${location}/${element}`).isDirectory());
  const articles = [];
  directories.forEach((element) => {
    const contentPath = `${location}/${element}.md`;
    if (import_fs.default.existsSync(contentPath)) {
      const content = import_fs.default.readFileSync(contentPath, { encoding: "utf-8" });
      articles.push({ slug: element, content });
    }
  });
  return articles;
};
var getPost = async (content, body = true) => {
  const transformedContent = await (0, import_mdsvex.compile)(content);
  const {
    datePublished,
    featuredImage,
    featuredImageAlt,
    ogImage,
    ogSquareImage,
    postTitle,
    seoMetaDescription,
    twitterImage
  } = transformedContent.data.fm;
  let result = {
    datePublished,
    featuredImage,
    featuredImageAlt,
    ogImage,
    ogSquareImage,
    postTitle,
    seoMetaDescription,
    twitterImage
  };
  if (body) {
    result = { ...result, body: transformedContent.code };
  }
  return result;
};
async function get({ params }) {
  const { slug } = params;
  const __dirname = import_path.default.resolve();
  const location = import_path.default.join(__dirname, "./src/routes/");
  const articles = await getPostsContent(location);
  const article = articles.find((element) => element.slug === slug);
  const post = await getPost(article.content, true);
  if (post) {
    return { body: JSON.stringify({ post: { ...post, slug } }) };
  }
}
var _slug__json = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get
});
var Header = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<header class="${"text-gray-600 body-font bg-yellow-200"}"><div class="${"container mx-auto flex flex-wrap p-5 flex-col md:flex-row items-center"}"><a class="${"flex title-font font-medium items-center text-gray-900 mb-4 md:mb-0"}"><span class="${"ml-3 text-2xl"}">Nusendra</span></a>
		<nav class="${"md:ml-auto flex flex-wrap items-center text-base justify-center"}"><a class="${"mr-5 hover:text-gray-900"}">Home</a>
			<a class="${"mr-5 hover:text-gray-900"}">Blog</a>
			<a class="${"mr-5 hover:text-gray-900"}">Course</a>
			<a class="${"mr-5 hover:text-gray-900"}">Now</a>
			<a class="${"mr-5 hover:text-gray-900"}">Contact</a></nav></div></header>`;
});
var Footer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<footer class="${"text-gray-600 body-font bg-yellow-300"}"><div class="${"container px-5 py-8 mx-auto flex items-center sm:flex-row flex-col"}"><a class="${"flex title-font font-medium items-center md:justify-start justify-center text-gray-900"}"><span class="${"ml-3 text-xl"}">Nusendra.com</span></a>
		<p class="${"text-sm text-gray-500 sm:ml-4 sm:pl-4 sm:border-l-2 sm:border-gray-200 sm:py-2 sm:mt-0 mt-4"}">\xA9 2021 - build with love by
			<a href="${"https://twitter.com/nusendra_"}" class="${"text-gray-600 ml-1"}" rel="${"noopener noreferrer"}" target="${"_blank"}">@nusendra_</a></p>
		<span class="${"inline-flex sm:ml-auto sm:mt-0 mt-4 justify-center sm:justify-start"}"><a class="${"text-gray-500"}" href="${"https://www.facebook.com/andraeinstein"}" target="${"_blank"}"><svg fill="${"currentColor"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" stroke-width="${"2"}" class="${"w-5 h-5"}" viewBox="${"0 0 24 24"}"><path d="${"M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"}"></path></svg></a>
			<a class="${"ml-3 text-gray-500"}" href="${"https://twitter.com/nusendra_"}" target="${"_blank"}"><svg fill="${"currentColor"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" stroke-width="${"2"}" class="${"w-5 h-5"}" viewBox="${"0 0 24 24"}"><path d="${"M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"}"></path></svg></a>
			<a class="${"ml-3 text-gray-500"}" href="${"https://www.instagram.com/nusendra_/"}" target="${"_blank"}"><svg fill="${"none"}" stroke="${"currentColor"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" stroke-width="${"2"}" class="${"w-5 h-5"}" viewBox="${"0 0 24 24"}"><rect width="${"20"}" height="${"20"}" x="${"2"}" y="${"2"}" rx="${"5"}" ry="${"5"}"></rect><path d="${"M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37zm1.5-4.87h.01"}"></path></svg></a></span></div></footer>`;
});
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Header, "MyHeader").$$render($$result, {}, {}, {})}
${slots.default ? slots.default({}) : ``}
${validate_component(Footer, "MyFooter").$$render($$result, {}, {}, {})}`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout
});
function load$1({ error: error22, status }) {
  return { props: { error: error22, status } };
}
var Error$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { status } = $$props;
  let { error: error22 } = $$props;
  if ($$props.status === void 0 && $$bindings.status && status !== void 0)
    $$bindings.status(status);
  if ($$props.error === void 0 && $$bindings.error && error22 !== void 0)
    $$bindings.error(error22);
  return `<h1>${escape2(status)}</h1>

<pre>${escape2(error22.message)}</pre>



${error22.frame ? `<pre>${escape2(error22.frame)}</pre>` : ``}
${error22.stack ? `<pre>${escape2(error22.stack)}</pre>` : ``}`;
});
var error2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Error$1,
  load: load$1
});
var YoutubeCard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { imageSource } = $$props;
  let { imageAlt } = $$props;
  let { titleTag } = $$props;
  let { title } = $$props;
  let { totalVideos } = $$props;
  if ($$props.imageSource === void 0 && $$bindings.imageSource && imageSource !== void 0)
    $$bindings.imageSource(imageSource);
  if ($$props.imageAlt === void 0 && $$bindings.imageAlt && imageAlt !== void 0)
    $$bindings.imageAlt(imageAlt);
  if ($$props.titleTag === void 0 && $$bindings.titleTag && titleTag !== void 0)
    $$bindings.titleTag(titleTag);
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.totalVideos === void 0 && $$bindings.totalVideos && totalVideos !== void 0)
    $$bindings.totalVideos(totalVideos);
  return `<div class="${"xl:w-1/4 md:w-1/2 p-4"}"><div class="${"bg-gray-200 p-6 rounded-lg"}"><img class="${"h-38 rounded w-full object-center mb-6"}"${add_attribute("src", imageSource, 0)}${add_attribute("alt", imageAlt, 0)}>
    <div class="${"flex justify-between mb-2"}"><h3 class="${"tracking-widest text-indigo-500 text-xs font-medium title-font"}">${escape2(titleTag)}</h3>
      <span class="${"text-xs text-gray-900 font-medium title-font"}">${escape2(totalVideos)} videos
      </span></div>
    <h2 class="${"text-lg text-gray-900 font-medium title-font"}"><strong>${escape2(title)}</strong></h2></div></div>`;
});
var BlogList = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<div class="${"py-8 flex flex-wrap md:flex-nowrap"}"><div class="${"md:w-64 md:mb-0 mb-6 flex-shrink-0 flex flex-col"}"><span class="${"font-semibold title-font text-gray-700"}">CATEGORY</span>
    <span class="${"mt-1 text-gray-500 text-sm"}">12 Jun 2019</span></div>
  <div class="${"md:flex-grow"}"><h2 class="${"text-2xl font-medium text-gray-900 title-font mb-2"}">Bitters hashtag waistcoat fashion axe chia unicorn
    </h2>
    <p class="${"leading-relaxed"}">Glossier echo park pug, church-key sartorial biodiesel vexillologist
      pop-up snackwave ramps cornhole. Marfa 3 wolf moon party messenger bag
      selfies, poke vaporware kombucha lumbersexual pork belly polaroid hoodie
      portland craft beer.
    </p>
    <a class="${"text-indigo-500 inline-flex items-center mt-4"}">Learn More
      <svg class="${"w-4 h-4 ml-2"}" viewBox="${"0 0 24 24"}" stroke="${"currentColor"}" stroke-width="${"2"}" fill="${"none"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}"><path d="${"M5 12h14"}"></path><path d="${"M12 5l7 7-7 7"}"></path></svg></a></div></div>`;
});
async function load({ page, fetch: fetch2 }) {
  const url = `/posts.json`;
  const res = await fetch2(url);
  const posts = await res.json();
  return { props: { posts } };
}
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { posts } = $$props;
  if ($$props.posts === void 0 && $$bindings.posts && posts !== void 0)
    $$bindings.posts(posts);
  return `<section class="${"text-gray-600 body-font bg-gray-100"}"><div class="${"container px-5 py-24 mx-auto"}"><div class="${"flex flex-wrap w-full mb-20"}"><div class="${"lg:w-1/2 w-full mb-6 lg:mb-0"}"><h1 class="${"sm:text-3xl text-2xl font-medium title-font mb-2 text-gray-900"}">Latest Youtube Playlists
				</h1></div>
			<p class="${"lg:w-1/2 w-full leading-relaxed text-gray-500"}">Saya membuat playlist youtube yang membahas mengenai programming mulai
				dari dasar hingga bisa diimplementasikan ke dunia nyata. Video yang saya
				buat adalah seputar JavaScript, TypeScript, Design Pattern, dan Vuejs.
				Semoga playlist dibawah ini berguna untuk teman teman semuanya.
			</p></div>
		<div class="${"flex flex-wrap -m-4"}">${validate_component(YoutubeCard, "YoutubeCard").$$render($$result, {
    imageSource: "https://i.ibb.co/tm5QJcr/VUE3-ADVANCE-1.png",
    imageAlt: "vue3 advance",
    titleTag: "Frontend, Vuejs",
    title: "Vue3 Tingkat Lanjut",
    totalVideos: "13"
  }, {}, {})}
			${validate_component(YoutubeCard, "YoutubeCard").$$render($$result, {
    imageSource: "https://i.ibb.co/v1x0J5R/VUE3-ADVANCE.png",
    imageAlt: "vue3 composition api",
    titleTag: "Frontend, Vuejs",
    title: "Vue3 Composition API",
    totalVideos: "13"
  }, {}, {})}
			${validate_component(YoutubeCard, "YoutubeCard").$$render($$result, {
    imageSource: "https://i.ibb.co/7JfFFRv/vue3-dasar.png",
    imageAlt: "vue3 dasar",
    titleTag: "Frontend, Vuejs",
    title: "Vue3 Tingkat Dasar",
    totalVideos: "30"
  }, {}, {})}
			${validate_component(YoutubeCard, "YoutubeCard").$$render($$result, {
    imageSource: "https://i.ibb.co/n0xjW1L/ts-design-pattern.png",
    imageAlt: "typescript design pattern",
    titleTag: "Backend, TypeScript",
    title: "TypeScript Design Pattern",
    totalVideos: "18"
  }, {}, {})}
			${validate_component(YoutubeCard, "YoutubeCard").$$render($$result, {
    imageSource: "https://i.ibb.co/brf0Cpt/ts-oop.png",
    imageAlt: "typescript oop",
    titleTag: "Backend, TypeScript",
    title: "TypeScript OOP",
    totalVideos: "30"
  }, {}, {})}
			${validate_component(YoutubeCard, "YoutubeCard").$$render($$result, {
    imageSource: "https://i.ibb.co/LRqWHtz/ts-express.png",
    imageAlt: "typescript expressjs",
    titleTag: "Backend, TypeScript",
    title: "TypeScript & ExpressJS",
    totalVideos: "25"
  }, {}, {})}
			${validate_component(YoutubeCard, "YoutubeCard").$$render($$result, {
    imageSource: "https://i.ibb.co/YZLBtYT/ts-dasar.png",
    imageAlt: "typescript dasar",
    titleTag: "Backend, TypeScript",
    title: "TypeScript Tingkat Dasar",
    totalVideos: "25"
  }, {}, {})}</div></div></section>

<section class="${"text-gray-600 body-font overflow-hidden"}"><div class="${"container px-5 py-24 mx-auto"}"><div class="${"-my-8 divide-y-2 divide-gray-100"}"><h1 class="${"sm:text-3xl text-2xl font-medium title-font mb-2 text-gray-900"}">Latest Blog Posts
			</h1>
			${each(posts, (item, i) => `<li>${escape2(item.title)}
				</li>`)}
			${validate_component(BlogList, "BlogList").$$render($$result, {}, {}, {})}
			${validate_component(BlogList, "BlogList").$$render($$result, {}, {}, {})}
			${validate_component(BlogList, "BlogList").$$render($$result, {}, {}, {})}</div></div></section>`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes,
  load
});
var MarkdownLayout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { title } = $$props;
  let { coverImageUrl } = $$props;
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.coverImageUrl === void 0 && $$bindings.coverImageUrl && coverImageUrl !== void 0)
    $$bindings.coverImageUrl(coverImageUrl);
  return `${$$result.head += `${$$result.title = `<title>${escape2(title)}</title>`, ""}<meta property="${"og:title"}"${add_attribute("content", title, 0)} data-svelte="svelte-1t7mdn8"><meta property="${"og:image"}"${add_attribute("content", coverImageUrl, 0)} data-svelte="svelte-1t7mdn8">`, ""}

<article class="${"prose lg:prose-xl"}"><h1>${escape2(title)}</h1>
	${slots.default ? slots.default({}) : ``}
	<a href="${"/blog"}">Back to blog index</a></article>`;
});
var metadata = {
  "title": "Berkenalan dengan VueJS",
  "date": "2018-01-15T07:29:36.000Z",
  "tags": ["javascript", "vuejs"],
  "draft": false,
  "description": "Berkenalan dengan VueJS merupakan sebuah awal untuk menjalin cinta dengan si dia. Untuk mempelajari dan mendalami si dia (VueJS), maka kita perlu kenalan dulu sama si dia. Yuk belajar bareng..",
  "slug": "berkenalan-dengan-vuejs"
};
var _2018_01_16_berkenalan_dengan_vuejs = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(MarkdownLayout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata), {}, { default: () => `<p>asdffdsaasdf</p>` })}`;
});
var _20180116BerkenalanDenganVuejs = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _2018_01_16_berkenalan_dengan_vuejs,
  metadata
});

// .svelte-kit/netlify/entry.js
init();
async function handler(event) {
  const { path: path2, httpMethod, headers, rawQuery, body, isBase64Encoded } = event;
  const query = new URLSearchParams(rawQuery);
  const encoding = isBase64Encoded ? "base64" : headers["content-encoding"] || "utf-8";
  const rawBody = typeof body === "string" ? Buffer.from(body, encoding) : body;
  const rendered = await render({
    method: httpMethod,
    headers,
    path: path2,
    query,
    rawBody
  });
  if (rendered) {
    return {
      isBase64Encoded: false,
      statusCode: rendered.status,
      ...splitHeaders(rendered.headers),
      body: rendered.body
    };
  }
  return {
    statusCode: 404,
    body: "Not found"
  };
}
function splitHeaders(headers) {
  const h = {};
  const m = {};
  for (const key in headers) {
    const value = headers[key];
    const target = Array.isArray(value) ? m : h;
    target[key] = value;
  }
  return {
    headers: h,
    multiValueHeaders: m
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
